<?xml version="1.0" encoding="UTF-8"?><!--
Copyright (c) 2002-2003 World Wide Web Consortium,
(Massachusetts Institute of Technology, Institut National de
Recherche en Informatique et en Automatique, Keio University). All
Rights Reserved. This program is distributed under the W3C's Document
Intellectual Property License. This program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See W3C License http://www.w3.org/Consortium/Legal/ for more details.
--><!--This file is an extract of interface definitions from Document Object Model (DOM) Level 3 Core Specification--><library xmlns:xlink="http://www.w3.org/1999/xlink">
	<exception name="DOMException" id="ID-17189187">
		<descr>
			<p>DOM operations only raise exceptions in "exceptional" circumstances, i.e., when an operation is impossible to perform (either for logical reasons, because data is lost, or because the implementation has become unstable). In general, DOM methods return specific error values in ordinary processing situations, such as out-of-bound errors when using<code>NodeList</code>.</p>
			<p>Implementations should raise other exceptions under other circumstances. For example, implementations should raise an implementation-dependent exception if a<code>null</code>argument is passed when<code>null</code>was not expected.</p>
			<p>Some languages and object systems do not support the concept of exceptions. For such systems, error conditions may be indicated using native error reporting mechanisms. For some bindings, for example, methods may return error codes similar to those listed in the corresponding method descriptions.</p>
		</descr>
		<component id="ID-146F692A" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="ID-258A00AF" name="ExceptionCode">
		<descr>
			<p>An integer indicating the type of error generated.</p>
			<note>
				<p>Other numeric codes are reserved for W3C for possible future use.</p>
			</note>
		</descr>
		<constant id="DOMException-INDEX_SIZE_ERR" name="INDEX_SIZE_ERR" type="unsigned short" value="1">
			<descr>
				<p>If index or size is negative, or greater than the allowed value.</p>
			</descr>
		</constant>
		<constant id="DOMException-DOMSTRING_SIZE_ERR" name="DOMSTRING_SIZE_ERR" type="unsigned short" value="2">
			<descr>
				<p>If the specified range of text does not fit into a<code>DOMString</code>.</p>
			</descr>
		</constant>
		<constant id="DOMException-HIERARCHY_REQUEST_ERR" name="HIERARCHY_REQUEST_ERR" type="unsigned short" value="3">
			<descr>
				<p>If any<code>Node</code>is inserted somewhere it doesn't belong.</p>
			</descr>
		</constant>
		<constant id="DOMException-WRONG_DOCUMENT_ERR" name="WRONG_DOCUMENT_ERR" type="unsigned short" value="4">
			<descr>
				<p>If a<code>Node</code>is used in a different document than the one that created it (that doesn't support it).</p>
			</descr>
		</constant>
		<constant id="DOMException-INVALID_CHARACTER_ERR" name="INVALID_CHARACTER_ERR" type="unsigned short" value="5">
			<descr>
				<p>If an invalid or illegal character is specified, such as in an XML name.</p>
			</descr>
		</constant>
		<constant id="DOMException-NO_DATA_ALLOWED_ERR" name="NO_DATA_ALLOWED_ERR" type="unsigned short" value="6">
			<descr>
				<p>If data is specified for a<code>Node</code>which does not support data.</p>
			</descr>
		</constant>
		<constant id="DOMException-NO_MODIFICATION_ALLOWED_ERR" name="NO_MODIFICATION_ALLOWED_ERR" type="unsigned short" value="7">
			<descr>
				<p>If an attempt is made to modify an object where modifications are not allowed.</p>
			</descr>
		</constant>
		<constant id="DOMException-NOT_FOUND_ERR" name="NOT_FOUND_ERR" type="unsigned short" value="8">
			<descr>
				<p>If an attempt is made to reference a<code>Node</code>in a context where it does not exist.</p>
			</descr>
		</constant>
		<constant id="DOMException-NOT_SUPPORTED_ERR" name="NOT_SUPPORTED_ERR" type="unsigned short" value="9">
			<descr>
				<p>If the implementation does not support the requested type of object or operation.</p>
			</descr>
		</constant>
		<constant id="DOMException-INUSE_ATTRIBUTE_ERR" name="INUSE_ATTRIBUTE_ERR" type="unsigned short" value="10">
			<descr>
				<p>If an attempt is made to add an attribute that is already in use elsewhere.</p>
			</descr>
		</constant>
		<constant id="DOMException-INVALID_STATE_ERR" name="INVALID_STATE_ERR" type="unsigned short" value="11" since="DOM Level 2">
			<descr>
				<p>If an attempt is made to use an object that is not, or is no longer, usable.</p>
			</descr>
		</constant>
		<constant id="DOMException-SYNTAX_ERR" name="SYNTAX_ERR" type="unsigned short" value="12" since="DOM Level 2">
			<descr>
				<p>If an invalid or illegal string is specified.</p>
			</descr>
		</constant>
		<constant id="DOMException-INVALID_MODIFICATION_ERR" name="INVALID_MODIFICATION_ERR" type="unsigned short" value="13" since="DOM Level 2">
			<descr>
				<p>If an attempt is made to modify the type of the underlying object.</p>
			</descr>
		</constant>
		<constant id="DOMException-NAMESPACE_ERR" name="NAMESPACE_ERR" type="unsigned short" value="14" since="DOM Level 2">
			<descr>
				<p>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</p>
			</descr>
		</constant>
		<constant id="DOMException-INVALID_ACCESS_ERR" name="INVALID_ACCESS_ERR" type="unsigned short" value="15" since="DOM Level 2">
			<descr>
				<p>If a parameter or an operation is not supported by the underlying object.</p>
			</descr>
		</constant>
		<constant id="DOMException-VALIDATION_ERR" name="VALIDATION_ERR" type="unsigned short" value="16" since="DOM Level 3">
			<descr>
				<p>If a call to a method such as<code>insertBefore</code>or<code>removeChild</code>would make the<code>Node</code>invalid with respect to<termref def="dt-partially-valid">"partial validity"</termref>, this exception would be raised and the operation would not be done. This code is used in<bibref role="informative" ref="DOMVal"/>. Refer to this specification for further information.</p>
			</descr>
		</constant>
		<constant id="DOMException-TYPE_MISMATCH_ERR" name="TYPE_MISMATCH_ERR" type="unsigned short" value="17" since="DOM Level 3">
			<descr>
				<p>If the type of an object is incompatible with the expected type of the parameter associated to the object.</p>
			</descr>
		</constant>
	</group>
	<interface name="DOMStringList" id="DOMStringList" since="DOM Level 3">
		<descr>
			<p>The<code>DOMStringList</code>interface provides the abstraction of an ordered collection of<code>DOMString</code>values, without defining or constraining how this collection is implemented. The items in the<code>DOMStringList</code>are accessible via an integral index, starting from 0.</p>
		</descr>
		<method name="item" id="DOMStringList-item">
			<descr>
				<p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of<code>DOMString</code>s in the list, this returns<code>null</code>.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The<code>DOMString</code>at the<code>index</code>th position in the<code>DOMStringList</code>, or<code>null</code>if that is not a valid index.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="length" id="DOMStringList-length">
			<descr>
				<p>The number of<code>DOMString</code>s in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p>
			</descr>
		</attribute>
		<method name="contains" id="DOMStringList-contains">
			<descr>
				<p>Test if a string is part of this<code>DOMStringList</code>.</p>
			</descr>
			<parameters>
				<param name="str" type="DOMString" attr="in">
					<descr>
						<p>The string to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the string has been found,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="NameList" id="NameList" since="DOM Level 3">
		<descr>
			<p>The<code>NameList</code>interface provides the abstraction of an ordered collection of parallel pairs of name and namespace values (which could be null values), without defining or constraining how this collection is implemented. The items in the<code>NameList</code>are accessible via an integral index, starting from 0.</p>
		</descr>
		<method name="getName" id="NameList-getName">
			<descr>
				<p>Returns the<code>index</code>th name item in the collection.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The name at the<code>index</code>th position in the<code>NameList</code>, or<code>null</code>if there is no name for the specified index or if the index is out of range.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getNamespaceURI" id="NameList-getNamespaceURI">
			<descr>
				<p>Returns the<code>index</code>th namespaceURI item in the collection.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The namespace URI at the<code>index</code>th position in the<code>NameList</code>, or<code>null</code>if there is no name for the specified index or if the index is out of range.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="length" id="NameList-length">
			<descr>
				<p>The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p>
			</descr>
		</attribute>
		<method name="contains" id="NameList-contains">
			<descr>
				<p>Test if a name is part of this<code>NameList</code>.</p>
			</descr>
			<parameters>
				<param name="str" type="DOMString" attr="in">
					<descr>
						<p>The name to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the name has been found,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="containsNS" id="NameList-containsNS">
			<descr>
				<p>Test if the pair namespaceURI/name is part of this<code>NameList</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The namespace URI to look for.</p>
					</descr>
				</param>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the pair namespaceURI/name has been found,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DOMImplementationList" id="DOMImplementationList" since="DOM Level 3">
		<descr>
			<p>The<code>DOMImplementationList</code>interface provides the abstraction of an ordered collection of DOM implementations, without defining or constraining how this collection is implemented. The items in the<code>DOMImplementationList</code>are accessible via an integral index, starting from 0.</p>
		</descr>
		<method name="item" id="DOMImplementationList-item">
			<descr>
				<p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of<code>DOMImplementation</code>s in the list, this returns<code>null</code>.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMImplementation">
				<descr>
					<p>The<code>DOMImplementation</code>at the<code>index</code>th position in the<code>DOMImplementationList</code>, or<code>null</code>if that is not a valid index.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="length" id="DOMImplementationList-length">
			<descr>
				<p>The number of<code>DOMImplementation</code>s in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="DOMImplementationSource" id="DOMImplementationSource" since="DOM Level 3">
		<descr>
			<p>This interface permits a DOM implementer to supply one or more implementations, based upon requested features and versions, as specified in<specref ref="DOMFeatures"/>. Each implemented<code>DOMImplementationSource</code>object is listed in the binding-specific list of available sources so that its<code>DOMImplementation</code>objects are made available.</p>
		</descr>
		<method name="getDOMImplementation" id="ID-getDOMImpl">
			<descr>
				<p>A method to request the first DOM implementation that supports the specified features.</p>
			</descr>
			<parameters>
				<param name="features" type="DOMString" attr="in">
					<descr>
						<p>A string that specifies which features and versions are required. This is a space separated list in which each feature is specified by its name optionally followed by a space and a version number.</p>
						<p>This method returns the first item of the list returned by<code>getDOMImplementationList</code>.</p>
						<p>As an example, the string<code>"XML 3.0 Traversal +Events 2.0"</code>will request a DOM implementation that supports the module "XML" for its 3.0 version, a module that support of the "Traversal" module for any version, and the module "Events" for its 2.0 version. The module "Events" must be accessible using the method<code>Node.getFeature()</code>and<code>DOMImplementation.getFeature()</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMImplementation">
				<descr>
					<p>The first DOM implementation that support the desired features, or<code>null</code>if this source has none.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getDOMImplementationList" id="ID-getDOMImpls">
			<descr>
				<p>A method to request a list of DOM implementations that support the specified features and versions, as specified in<specref ref="DOMFeatures"/>.</p>
			</descr>
			<parameters>
				<param name="features" type="DOMString" attr="in">
					<descr>
						<p>A string that specifies which features and versions are required. This is a space separated list in which each feature is specified by its name optionally followed by a space and a version number. This is something like: "XML 3.0 Traversal +Events 2.0"</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMImplementationList">
				<descr>
					<p>A list of DOM implementations that support the desired features.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DOMImplementation" id="ID-102161490">
		<descr>
			<p>The<code>DOMImplementation</code>interface provides a number of methods for performing operations that are independent of any particular instance of the document object model.</p>
		</descr>
		<method name="hasFeature" id="ID-5CED94D7">
			<descr>
				<p>Test if the DOM implementation implements a specific feature and version, as specified in<specref ref="DOMFeatures"/>.</p>
			</descr>
			<parameters>
				<param name="feature" type="DOMString" attr="in">
					<descr>
						<p>The name of the feature to test.</p>
					</descr>
				</param>
				<param name="version" type="DOMString" attr="in">
					<descr>
						<p>This is the version number of the feature to test.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the feature is implemented in the specified version,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createDocumentType" id="Level-2-Core-DOM-createDocType" since="DOM Level 2">
			<descr>
				<p>Creates an empty<code>DocumentType</code>node. Entity declarations and notations are not made available. Entity reference expansions and default attribute additions do not occur..</p>
			</descr>
			<parameters>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-qualifiedname">qualified name</termref>of the document type to be created.</p>
					</descr>
				</param>
				<param name="publicId" type="DOMString" attr="in">
					<descr>
						<p>The external subset public identifier.</p>
					</descr>
				</param>
				<param name="systemId" type="DOMString" attr="in">
					<descr>
						<p>The external subset system identifier.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DocumentType">
				<descr>
					<p>A new<code>DocumentType</code>node with<code>Node.ownerDocument</code>set to<code>null</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to<bibref ref="XML"/>.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createDocument" id="Level-2-Core-DOM-createDocument" since="DOM Level 2">
			<descr>
				<p>Creates a DOM Document object of the specified type with its document element.</p>
				<p>Note that based on the<code>DocumentType</code>given to create the document, the implementation may instantiate specialized<code>Document</code>objects that support additional features than the "Core", such as "HTML"<bibref role="informative" ref="DOM2HTML"/>. On the other hand, setting the<code>DocumentType</code>after the document was created makes this very unlikely to happen. Alternatively, specialized<code>Document</code>creation methods, such as<code>createHTMLDocument</code>
					<bibref role="informative" ref="DOM2HTML"/>, can be used to obtain specific types of<code>Document</code>objects.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the document element to create or<code>null</code>.</p>
					</descr>
				</param>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-qualifiedname">qualified name</termref>of the document element to be created or<code>null</code>.</p>
					</descr>
				</param>
				<param name="doctype" type="DocumentType" attr="in">
					<descr>
						<p>The type of document to be created or<code>null</code>.</p>
						<p>When<code>doctype</code>is not<code>null</code>, its<code>Node.ownerDocument</code>attribute is set to the document being created.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Document">
				<descr>
					<p>A new<code>Document</code>object with its document element. If the<code>NamespaceURI</code>,<code>qualifiedName</code>, and<code>doctype</code>are<code>null</code>, the returned<code>Document</code>is empty with no document element.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to<bibref ref="XML"/>.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>is<code>null</code>and the<code>namespaceURI</code>is different from<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from ""<bibref ref="Namespaces"/>, or if the DOM implementation does not support the<code>"XML"</code>feature but a non-null namespace URI was provided, since namespaces were defined by XML.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>doctype</code>has already been used with a different document or was created from a different implementation.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getFeature" id="DOMImplementation3-getFeature" since="DOM Level 3">
			<descr>
				<p>This method returns a specialized object which implements the specialized APIs of the specified feature and version, as specified in<specref ref="DOMFeatures"/>. The specialized object may also be obtained by using binding-specific casting methods but is not necessarily expected to, as discussed in<specref ref="Embedded-DOM"/>. This method also allow the implementation to provide specialized objects which do not support the<code>DOMImplementation</code>interface.</p>
			</descr>
			<parameters>
				<param name="feature" type="DOMString" attr="in">
					<descr>
						<p>The name of the feature requested. Note that any plus sign "+" prepended to the name of the feature will be ignored since it is not significant in the context of this method.</p>
					</descr>
				</param>
				<param name="version" type="DOMString" attr="in">
					<descr>
						<p>This is the version number of the feature to test.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMObject">
				<descr>
					<p>Returns an object which implements the specialized APIs of the specified feature and version, if any, or<code>null</code>if there is no object which implements interfaces associated with that feature. If the<code>DOMObject</code>returned by this method implements the<code>DOMImplementation</code>interface, it must delegate to the primary core<code>DOMImplementation</code>and not return results inconsistent with the primary core<code>DOMImplementation</code>such as<code>hasFeature</code>,<code>getFeature</code>, etc.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DocumentFragment" inherits="Node" id="ID-B63ED1A3">
		<descr>
			<p>
				<code>DocumentFragment</code>is a "lightweight" or "minimal"<code>Document</code>object. It is very common to want to be able to extract a portion of a document's tree or to create a new fragment of a document. Imagine implementing a user command like cut or rearranging a document by moving fragments around. It is desirable to have an object which can hold such fragments and it is quite natural to use a Node for this purpose. While it is true that a<code>Document</code>object could fulfill this role, a<code>Document</code>object can potentially be a heavyweight object, depending on the underlying implementation. What is really needed for this is a very lightweight object.<code>DocumentFragment</code>is such an object.</p>
			<p>Furthermore, various operations -- such as inserting nodes as children of another<code>Node</code>-- may take<code>DocumentFragment</code>objects as arguments; this results in all the child nodes of the<code>DocumentFragment</code>being moved to the child list of this node.</p>
			<p>The children of a<code>DocumentFragment</code>node are zero or more nodes representing the tops of any sub-trees defining the structure of the document.<code>DocumentFragment</code>nodes do not need to be<termref def="dt-well-formed">well-formed XML documents</termref>(although they do need to follow the rules imposed upon well-formed XML parsed entities, which can have multiple top nodes). For example, a<code>DocumentFragment</code>might have only one child and that child node could be a<code>Text</code>node. Such a structure model represents neither an HTML document nor a well-formed XML document.</p>
			<p>When a<code>DocumentFragment</code>is inserted into a<code>Document</code>(or indeed any other<code>Node</code>that may take children) the children of the<code>DocumentFragment</code>and not the<code>DocumentFragment</code>itself are inserted into the<code>Node</code>. This makes the<code>DocumentFragment</code>very useful when the user wishes to create nodes that are<termref def="dt-sibling">siblings</termref>; the<code>DocumentFragment</code>acts as the parent of these nodes so that the user can use the standard methods from the<code>Node</code>interface, such as<code>Node.insertBefore</code>and<code>Node.appendChild</code>.</p>
		</descr>
	</interface>
	<interface name="Document" inherits="Node" id="i-Document">
		<descr>
			<p>The<code>Document</code>interface represents the entire HTML or XML document. Conceptually, it is the<termref def="dt-root-node">root</termref>of the document tree, and provides the primary access to the document's data.</p>
			<p>Since elements, text nodes, comments, processing instructions, etc. cannot exist outside the context of a<code>Document</code>, the<code>Document</code>interface also contains the factory methods needed to create these objects. The<code>Node</code>objects created have a<code>ownerDocument</code>attribute which associates them with the<code>Document</code>within whose context they were created.</p>
		</descr>
		<attribute id="ID-B63ED1A31" name="doctype" type="DocumentType" readonly="yes" version="DOM Level 3">
			<descr>
				<p>The Document Type Declaration (see<code>DocumentType</code>) associated with this document. For XML documents without a document type declaration this returns<code>null</code>. For HTML documents, a<code>DocumentType</code>object may be returned, independently of the presence or absence of document type declaration in the HTML document.</p>
				<p>This provides direct access to the<code>DocumentType</code>node, child node of this<code>Document</code>. This node can be set at document creation time and later changed through the use of child nodes manipulation methods, such as<code>Node.insertBefore</code>, or<code>Node.replaceChild</code>. Note, however, that while some implementations may instantiate different types of<code>Document</code>objects supporting additional features than the "Core", such as "HTML"<bibref role="informative" ref="DOM2HTML"/>, based on the<code>DocumentType</code>specified at creation time, changing it afterwards is very unlikely to result in a change of the features supported.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="implementation" type="DOMImplementation" id="ID-1B793EBA">
			<descr>
				<p>The<code>DOMImplementation</code>object that handles this document. A DOM application may use objects from multiple implementations.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="documentElement" type="Element" id="ID-87CD092">
			<descr>
				<p>This is a<termref def="dt-convenience">convenience</termref>attribute that allows direct access to the child node that is the<termref def="dt-document-element">document element</termref>of the document.</p>
			</descr>
		</attribute>
		<method name="createElement" id="ID-2141741547">
			<descr>
				<p>Creates an element of the type specified. Note that the instance returned implements the<code>Element</code>interface, so attributes can be specified directly on the returned object.</p>
				<p>In addition, if there are known attributes with default values,<code>Attr</code>nodes representing them are automatically created and attached to the element.</p>
				<p>To create an element with a<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, use the<code>createElementNS</code>method.</p>
			</descr>
			<parameters>
				<param name="tagName" type="DOMString" attr="in">
					<descr>
						<p>The name of the element type to instantiate. For XML, this is case-sensitive, otherwise it depends on the case-sensitivity of the markup language in use. In that case, the name is mapped to the canonical form of that markup by the DOM implementation.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Element">
				<descr>
					<p>A new<code>Element</code>object with the<code>nodeName</code>attribute set to<code>tagName</code>, and<code>localName</code>,<code>prefix</code>, and<code>namespaceURI</code>set to<code>null</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createDocumentFragment" id="ID-35CB04B5">
			<descr>
				<p>Creates an empty<code>DocumentFragment</code>object.</p>
			</descr>
			<parameters/>
			<returns type="DocumentFragment">
				<descr>
					<p>A new<code>DocumentFragment</code>.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createTextNode" id="ID-1975348127">
			<descr>
				<p>Creates a<code>Text</code>node given the specified string.</p>
			</descr>
			<parameters>
				<param name="data" type="DOMString" attr="in">
					<descr>
						<p>The data for the node.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Text">
				<descr>
					<p>The new<code>Text</code>object.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createComment" id="ID-1334481328">
			<descr>
				<p>Creates a<code>Comment</code>node given the specified string.</p>
			</descr>
			<parameters>
				<param name="data" type="DOMString" attr="in">
					<descr>
						<p>The data for the node.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Comment">
				<descr>
					<p>The new<code>Comment</code>object.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createCDATASection" id="ID-D26C0AF8">
			<descr>
				<p>Creates a<code>CDATASection</code>node whose value is the specified string.</p>
			</descr>
			<parameters>
				<param name="data" type="DOMString" attr="in">
					<descr>
						<p>The data for the<code>CDATASection</code>contents.</p>
					</descr>
				</param>
			</parameters>
			<returns type="CDATASection">
				<descr>
					<p>The new<code>CDATASection</code>object.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createProcessingInstruction" id="ID-135944439">
			<descr>
				<p>Creates a<code>ProcessingInstruction</code>node given the specified name and data strings.</p>
			</descr>
			<parameters>
				<param name="target" type="DOMString" attr="in">
					<descr>
						<p>The target part of the processing instruction.</p>
						<p>Unlike<code>Document.createElementNS</code>or<code>Document.createAttributeNS</code>, no namespace well-formed checking is done on the target name. Applications should invoke<code>Document.normalizeDocument()</code>with the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to<code>true</code>in order to ensure that the target name is namespace well-formed.</p>
					</descr>
				</param>
				<param name="data" type="DOMString" attr="in">
					<descr>
						<p>The data for the node.</p>
					</descr>
				</param>
			</parameters>
			<returns type="ProcessingInstruction">
				<descr>
					<p>The new<code>ProcessingInstruction</code>object.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified target is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createAttribute" id="ID-1084891198">
			<descr>
				<p>Creates an<code>Attr</code>of the given name. Note that the<code>Attr</code>instance can then be set on an<code>Element</code>using the<code>setAttributeNode</code>method.</p>
				<p>To create an attribute with a<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, use the<code>createAttributeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>A new<code>Attr</code>object with the<code>nodeName</code>attribute set to<code>name</code>, and<code>localName</code>,<code>prefix</code>, and<code>namespaceURI</code>set to<code>null</code>. The value of the attribute is the empty string.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createEntityReference" id="ID-392B75AE">
			<descr>
				<p>Creates an<code>EntityReference</code>object. In addition, if the referenced entity is known, the child list of the<code>EntityReference</code>node is made the same as that of the corresponding<code>Entity</code>node.</p>
				<note>
					<p>If any descendant of the<code>Entity</code>node has an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>, the corresponding descendant of the created<code>EntityReference</code>node is also unbound; (its<code>namespaceURI</code>is<code>null</code>). The DOM Level 2 and 3 do not support any mechanism to resolve namespace prefixes in this case.</p>
				</note>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the entity to reference.</p>
						<p>Unlike<code>Document.createElementNS</code>or<code>Document.createAttributeNS</code>, no namespace well-formed checking is done on the entity name. Applications should invoke<code>Document.normalizeDocument()</code>with the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to<code>true</code>in order to ensure that the entity name is namespace well-formed.</p>
					</descr>
				</param>
			</parameters>
			<returns type="EntityReference">
				<descr>
					<p>The new<code>EntityReference</code>object.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getElementsByTagName" id="ID-A6C9094">
			<descr>
				<p>Returns a<code>NodeList</code>of all the<code>Elements</code>in<termref def="dt-document-order">document order</termref>with a given tag name and are contained in the document.</p>
			</descr>
			<parameters>
				<param name="tagname" type="DOMString" attr="in">
					<descr>
						<p>The name of the tag to match on. The special value "*" matches all tags. For XML, the<code>tagname</code>parameter is case-sensitive, otherwise it depends on the case-sensitivity of the markup language in use.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NodeList">
				<descr>
					<p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="importNode" id="Core-Document-importNode" since="DOM Level 2">
			<descr>
				<p>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node. The returned node has no parent; (<code>parentNode</code>is<code>null</code>).</p>
				<p>For all nodes, importing a node creates a node object owned by the importing document, with attribute values identical to the source node's<code>nodeName</code>and<code>nodeType</code>, plus the attributes related to namespaces (<code>prefix</code>,<code>localName</code>, and<code>namespaceURI</code>). As in the<code>cloneNode</code>operation, the source node is not altered. User data associated to the imported node is not carried over. However, if any<code>UserDataHandlers</code>has been specified along with the associated data these handlers will be called with the appropriate parameters before this method returns.</p>
				<p>Additional information is copied as appropriate to the<code>nodeType</code>, attempting to mirror the behavior expected if a fragment of XML or HTML source was copied from one document to another, recognizing that the two documents may have different DTDs in the XML case. The following list describes the specifics for each type of node.<glist>
						<gitem>
							<label>ATTRIBUTE_NODE</label>
							<def>
								<p>The<code>ownerElement</code>attribute is set to<code>null</code>and the<code>specified</code>flag is set to<code>true</code>on the generated<code>Attr</code>. The<termref def="dt-descendant">descendants</termref>of the source<code>Attr</code>are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p>
								<p>Note that the<code>deep</code>parameter has no effect on<code>Attr</code>nodes; they always carry their children with them when imported.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_FRAGMENT_NODE</label>
							<def>
								<p>If the<code>deep</code>option was set to<code>true</code>, the<termref def="dt-descendant">descendants</termref>of the source<code>DocumentFragment</code>are recursively imported and the resulting nodes reassembled under the imported<code>DocumentFragment</code>to form the corresponding subtree. Otherwise, this simply generates an empty<code>DocumentFragment</code>.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_NODE</label>
							<def>
								<p>
									<code>Document</code>nodes cannot be imported.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_TYPE_NODE</label>
							<def>
								<p>
									<code>DocumentType</code>nodes cannot be imported.</p>
							</def>
						</gitem>
						<gitem>
							<label>ELEMENT_NODE</label>
							<def>
								<p>
									<emph>Specified</emph>attribute nodes of the source element are imported, and the generated<code>Attr</code>nodes are attached to the generated<code>Element</code>. Default attributes are<emph>not</emph>copied, though if the document being imported into defines default attributes for this element name, those are assigned. If the<code>importNode</code>
									<code>deep</code>parameter was set to<code>true</code>, the<termref def="dt-descendant">descendants</termref>of the source element are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p>
							</def>
						</gitem>
						<gitem>
							<label>ENTITY_NODE</label>
							<def>
								<p>
									<code>Entity</code>nodes can be imported, however in the current release of the DOM the<code>DocumentType</code>is readonly. Ability to add these imported nodes to a<code>DocumentType</code>will be considered for addition to a future release of the DOM.</p>
								<p>On import, the<code>publicId</code>,<code>systemId</code>, and<code>notationName</code>attributes are copied. If a<code>deep</code>import is requested, the<termref def="dt-descendant">descendants</termref>of the the source<code>Entity</code>are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p>
							</def>
						</gitem>
						<gitem>
							<label>ENTITY_REFERENCE_NODE</label>
							<def>
								<p>Only the<code>EntityReference</code>itself is copied, even if a<code>deep</code>import is requested, since the source and destination documents might have defined the entity differently. If the document being imported into provides a definition for this entity name, its value is assigned.</p>
							</def>
						</gitem>
						<gitem>
							<label>NOTATION_NODE</label>
							<def>
								<p>
									<code>Notation</code>nodes can be imported, however in the current release of the DOM the<code>DocumentType</code>is readonly. Ability to add these imported nodes to a<code>DocumentType</code>will be considered for addition to a future release of the DOM.</p>
								<p>On import, the<code>publicId</code>and<code>systemId</code>attributes are copied.</p>
								<p>Note that the<code>deep</code>parameter has no effect on this type of nodes since they cannot have any children.</p>
							</def>
						</gitem>
						<gitem>
							<label>PROCESSING_INSTRUCTION_NODE</label>
							<def>
								<p>The imported node copies its<code>target</code>and<code>data</code>values from those of the source node.</p>
								<p>Note that the<code>deep</code>parameter has no effect on this type of nodes since they cannot have any children.</p>
							</def>
						</gitem>
						<gitem>
							<label>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</label>
							<def>
								<p>These three types of nodes inheriting from<code>CharacterData</code>copy their<code>data</code>and<code>length</code>attributes from those of the source node.</p>
								<p>Note that the<code>deep</code>parameter has no effect on these types of nodes since they cannot have any children.</p>
							</def>
						</gitem>
					</glist>
				</p>
			</descr>
			<parameters>
				<param name="importedNode" type="Node" attr="in">
					<descr>
						<p>The node to import.</p>
					</descr>
				</param>
				<param name="deep" type="boolean" attr="in">
					<descr>
						<p>If<code>true</code>, recursively import the subtree under the specified node; if<code>false</code>, import only the node itself, as explained above. This has no effect on nodes that cannot have any children, and on<code>Attr</code>, and<code>EntityReference</code>nodes.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The imported node that belongs to this<code>Document</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException" version="DOM Level 3">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the type of node being imported is not supported.</p>
						<p>INVALID_CHARACTER_ERR: Raised if one of the imported names is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute. This may happen when importing an XML 1.1<bibref role="informative" ref="XML11"/>element into an XML 1.0 document, for instance.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createElementNS" id="ID-DocCrElNS" since="DOM Level 2">
			<descr>
				<p>Creates an element of the given<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the namespaceURI parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the element to create.</p>
					</descr>
				</param>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-qualifiedname">qualified name</termref>of the element type to instantiate.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Element">
				<descr>
					<p>A new<code>Element</code>object with the following attributes:</p>
					<table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value">
						<tbody>
							<tr>
								<th rowspan="1" colspan="1">Attribute</th>
								<th rowspan="1" colspan="1">Value</th>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.nodeName</code>
								</td>
								<td rowspan="1" colspan="1">
									<code>qualifiedName</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.namespaceURI</code>
								</td>
								<td rowspan="1" colspan="1">
									<code>namespaceURI</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.prefix</code>
								</td>
								<td rowspan="1" colspan="1">prefix, extracted from<code>qualifiedName</code>, or<code>null</code>if there is no prefix</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.localName</code>
								</td>
								<td rowspan="1" colspan="1">
									<termref def="dt-localname">local name</termref>, extracted from<code>qualifiedName</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Element.tagName</code>
								</td>
								<td rowspan="1" colspan="1">
									<code>qualifiedName</code>
								</td>
							</tr>
						</tbody>
					</table>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified<code>qualifiedName</code>is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from ""<bibref ref="Namespaces"/>, or if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "", or if the<code>namespaceURI</code>is "" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p>
						<p>NOT_SUPPORTED_ERR: Always thrown if the current document does not support the<code>"XML"</code>feature, since namespaces were defined by XML.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createAttributeNS" id="ID-DocCrAttrNS" since="DOM Level 2">
			<descr>
				<p>Creates an attribute of the given<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to create.</p>
					</descr>
				</param>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-qualifiedname">qualified name</termref>of the attribute to instantiate.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>A new<code>Attr</code>object with the following attributes:</p>
					<table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value">
						<tbody>
							<tr>
								<th rowspan="1" colspan="1">Attribute</th>
								<th rowspan="1" colspan="1">Value</th>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.nodeName</code>
								</td>
								<td rowspan="1" colspan="1">qualifiedName</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.namespaceURI</code>
								</td>
								<td rowspan="1" colspan="1">
									<code>namespaceURI</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.prefix</code>
								</td>
								<td rowspan="1" colspan="1">prefix, extracted from<code>qualifiedName</code>, or<code>null</code>if there is no prefix</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.localName</code>
								</td>
								<td rowspan="1" colspan="1">
									<termref def="dt-localname">local name</termref>, extracted from<code>qualifiedName</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Attr.name</code>
								</td>
								<td rowspan="1" colspan="1">
									<code>qualifiedName</code>
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									<code>Node.nodeValue</code>
								</td>
								<td rowspan="1" colspan="1">the empty string</td>
							</tr>
						</tbody>
					</table>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified<code>qualifiedName</code>is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "", if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "", or if the<code>namespaceURI</code>is "" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p>
						<p>NOT_SUPPORTED_ERR: Always thrown if the current document does not support the<code>"XML"</code>feature, since namespaces were defined by XML.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getElementsByTagNameNS" id="ID-getElBTNNS" since="DOM Level 2">
			<descr>
				<p>Returns a<code>NodeList</code>of all the<code>Elements</code>with a given<termref def="dt-localname">local name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>in<termref def="dt-document-order">document order</termref>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the elements to match on. The special value<code>"*"</code>matches all namespaces.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the elements to match on. The special value "*" matches all local names.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NodeList">
				<descr>
					<p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getElementById" id="ID-getElBId" since="DOM Level 2">
			<descr>
				<p>Returns the<code>Element</code>that has an ID attribute with the given value. If no such element exists, this returns<code>null</code>. If more than one element has an ID attribute with that value, what is returned is undefined.</p>
				<p>The DOM implementation is expected to use the attribute<code>Attr.isId</code>to determine if an attribute is of type ID.</p>
				<note>
					<p>Attributes with the name "ID" or "id" are not of type ID unless so defined.</p>
				</note>
			</descr>
			<parameters>
				<param name="elementId" type="DOMString" attr="in">
					<descr>
						<p>The unique<code>id</code>value for an element.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Element">
				<descr>
					<p>The matching element or<code>null</code>if there is none.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute readonly="yes" type="DOMString" name="inputEncoding" id="Document3-inputEncoding" since="DOM Level 3">
			<descr>
				<p>An attribute specifying the encoding used for this document at the time of the parsing. This is<code>null</code>when it is not known, such as when the<code>Document</code>was created in memory.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Document3-encoding" since="DOM Level 3">
			<descr>
				<p>An attribute specifying, as part of the, the encoding of this document. This is<code>null</code>when unspecified or when it is not known, such as when the<code>Document</code>was created in memory.</p>
			</descr>
		</attribute>
		<attribute readonly="no" type="boolean" name="xmlStandalone" id="Document3-standalone" since="DOM Level 3">
			<descr>
				<p>An attribute specifying, as part of the, whether this document is standalone. This is<code>false</code>when unspecified.</p>
				<note>
					<p>No verification is done on the value when setting this attribute. Applications should use<code>Document.normalizeDocument()</code>with the "<termref def="parameter-validate">validate</termref>" parameter to verify if the value matches theas defined in<bibref ref="XML"/>.</p>
				</note>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if this document does not support the "XML" feature.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<attribute readonly="no" type="DOMString" name="xmlVersion" id="Document3-version" since="DOM Level 3">
			<descr>
				<p>An attribute specifying, as part of the, the version number of this document. If there is no declaration and if this document supports the "XML" feature, the value is<code>"1.0"</code>. If this document does not support the "XML" feature, the value is always<code>null</code>. Changing this attribute will affect methods that check for invalid characters in XML names. Application should invoke<code>Document.normalizeDocument()</code>in order to check for invalid characters in the<code>Node</code>s that are already part of this<code>Document</code>.</p>
				<p>DOM applications may use the<code>DOMImplementation.hasFeature(feature, version)</code>method with parameter values "XMLVersion" and "1.0" (respectively) to determine if an implementation supports<bibref ref="XML"/>. DOM applications may use the same method with parameter values "XMLVersion" and "1.1" (respectively) to determine if an implementation supports<bibref ref="XML11"/>. In both cases, in order to support XML, an implementation must also support the "XML" feature defined in this specification.<code>Document</code>objects supporting a version of the "XMLVersion" feature must not raise a<code>NOT_SUPPORTED_ERR</code>exception for the same version number when using<code>Document.xmlVersion</code>.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the version is set to a value that is not supported by this<code>Document</code>or if this document does not support the "XML" feature.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<attribute readonly="no" type="boolean" name="strictErrorChecking" id="Document3-strictErrorChecking" since="DOM Level 3">
			<descr>
				<p>An attribute specifying whether error checking is enforced or not. When set to<code>false</code>, the implementation is free to not test every possible error case normally defined on DOM operations, and not raise any<code>DOMException</code>on DOM operations or report errors while using<code>Document.normalizeDocument()</code>. In case of error, the behavior is undefined. This attribute is<code>true</code>by default.</p>
			</descr>
		</attribute>
		<attribute name="documentURI" id="Document3-documentURI" type="DOMString" readonly="no" since="DOM Level 3">
			<descr>
				<p>The location of the document or<code>null</code>if undefined or if the<code>Document</code>was created using<code>DOMImplementation.createDocument</code>. No lexical checking is performed when setting this attribute; this could result in a<code>null</code>value returned when using<code>Node.baseURI</code>.</p>
				<p>Beware that when the<code>Document</code>supports the feature "HTML"<bibref role="informative" ref="DOM2HTML"/>, the href attribute of the HTML BASE element takes precedence over this attribute when computing<code>Node.baseURI</code>.</p>
			</descr>
		</attribute>
		<method name="adoptNode" id="Document3-adoptNode" since="DOM Level 3">
			<descr>
				<p>Attempts to adopt a node from another document to this document. If supported, it changes the<code>ownerDocument</code>of the source node, its children, as well as the attached attribute nodes if there are any. If the source node has a parent it is first removed from the child list of its parent. This effectively allows moving a subtree from one document to another (unlike<code>importNode()</code>which create a copy of the source node instead of moving it). When it fails, applications should use<code>Document.importNode()</code>instead. Note that if the adopted node is already part of this document (i.e. the source and target document are the same), this method still has the effect of removing the source node from the child list of its parent, if any. The following list describes the specifics for each type of node.<glist>
						<gitem>
							<label>ATTRIBUTE_NODE</label>
							<def>
								<p>The<code>ownerElement</code>attribute is set to<code>null</code>and the<code>specified</code>flag is set to<code>true</code>on the adopted<code>Attr</code>. The descendants of the source<code>Attr</code>are recursively adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_FRAGMENT_NODE</label>
							<def>
								<p>The descendants of the source node are recursively adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_NODE</label>
							<def>
								<p>
									<code>Document</code>nodes cannot be adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>DOCUMENT_TYPE_NODE</label>
							<def>
								<p>
									<code>DocumentType</code>nodes cannot be adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>ELEMENT_NODE</label>
							<def>
								<p>
									<emph>Specified</emph>attribute nodes of the source element are adopted. Default attributes are discarded, though if the document being adopted into defines default attributes for this element name, those are assigned. The descendants of the source element are recursively adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>ENTITY_NODE</label>
							<def>
								<p>
									<code>Entity</code>nodes cannot be adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>ENTITY_REFERENCE_NODE</label>
							<def>
								<p>Only the<code>EntityReference</code>node itself is adopted, the descendants are discarded, since the source and destination documents might have defined the entity differently. If the document being imported into provides a definition for this entity name, its value is assigned.</p>
							</def>
						</gitem>
						<gitem>
							<label>NOTATION_NODE</label>
							<def>
								<p>
									<code>Notation</code>nodes cannot be adopted.</p>
							</def>
						</gitem>
						<gitem>
							<label>PROCESSING_INSTRUCTION_NODE, TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</label>
							<def>
								<p>These nodes can all be adopted. No specifics.</p>
							</def>
						</gitem>
					</glist>
				</p>
				<note>
					<p>Since it does not create new nodes unlike the<code>Document.importNode()</code>method, this method does not raise an<code>INVALID_CHARACTER_ERR</code>exception, and applications should use the<code>Document.normalizeDocument()</code>method to check if an imported name is not an XML name according to the XML version in use.</p>
				</note>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="source">
					<descr>
						<p>The node to move into this document.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The adopted node, or<code>null</code>if this operation fails, such as when the source node comes from a different implementation.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the source node is of type<code>DOCUMENT</code>,<code>DOCUMENT_TYPE</code>.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the source node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<attribute readonly="yes" type="DOMConfiguration" name="domConfig" id="Document3-domConfig" since="DOM Level 3">
			<descr>
				<p>The configuration used when<code>Document.normalizeDocument()</code>is invoked.</p>
			</descr>
		</attribute>
		<method name="normalizeDocument" id="Document3-normalizeDocument" since="DOM Level 3">
			<descr>
				<p>This method acts as if the document was going through a save and load cycle, putting the document in a "normal" form. As a consequence, this method updates the replacement tree of<code>EntityReference</code>nodes and normalizes<code>Text</code>nodes, as defined in the method<code>Node.normalize()</code>.</p>
				<p>Otherwise, the actual result depends on the features being set on the<code>Document.domConfig</code>object and governing what operations actually take place. Noticeably this method could also make the document<termref def="dt-namespace-well-formed">namespace well-formed</termref>according to the algorithm described in<specref ref="normalizeDocumentAlgo"/>, check the character normalization, remove the<code>CDATASection</code>nodes, etc. See<code>DOMConfiguration</code>for details.</p>
				<eg role="code" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">// Keep in the document the information defined // in the XML Information Set (Java example) DOMConfiguration docConfig = myDocument.getDomConfig(); docConfig.setParameter("infoset", Boolean.TRUE); myDocument.normalizeDocument();</eg>
				<p>Mutation events, when supported, are generated to reflect the changes occurring on the document.</p>
				<p>If errors occur during the invocation of this method, such as an attempt to update a<termref def="dt-readonly-node">read-only node</termref>or a<code>Node.nodeName</code>contains an invalid character according to the XML version in use, errors or warnings (<code>DOMError.SEVERITY_ERROR</code>or<code>DOMError.SEVERITY_WARNING</code>) will be reported using the<code>DOMErrorHandler</code>object associated with the "<termref def="parameter-error-handler">error-handler</termref>" parameter. Note this method might also report fatal errors (<code>DOMError.SEVERITY_FATAL_ERROR</code>) if an implementation cannot recover from an error.</p>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="renameNode" id="Document3-renameNode" since="DOM Level 3">
			<descr>
				<p>Rename an existing node of type<code>ELEMENT_NODE</code>or<code>ATTRIBUTE_NODE</code>.</p>
				<p>When possible this simply changes the name of the given node, otherwise this creates a new node with the specified name and replaces the existing node with the new node as described below.</p>
				<p>If simply changing the name of the given node is not possible, the following operations are performed: a new node is created, any registered event listener is registered on the new node, any user data attached to the old node is removed from that node, the old node is removed from its parent if it has one, the children are moved to the new node, if the renamed node is an<code>Element</code>its attributes are moved to the new node, the new node is inserted at the position the old node used to have in its parent's child nodes list if it has one, the user data that was attached to the old node is attached to the new node.</p>
				<p>When the node being renamed is an<code>Element</code>only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use<code>Document.normalizeDocument()</code>to guarantee these attributes are up-to-date.</p>
				<p>When the node being renamed is an<code>Attr</code>that is attached to an<code>Element</code>, the node is first removed from the<code>Element</code>attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</p>
				<p>In addition,</p>
				<ulist>
					<item>
						<p>a user data event<code>NODE_RENAMED</code>is fired,</p>
					</item>
					<item>
						<p>when the implementation supports the feature "MutationNameEvents", each mutation operation involved in this method fires the appropriate event, and in the end the event {<code>http://www.w3.org/2001/xml-events</code>,<code>DOMElementNameChanged</code>} or {<code>http://www.w3.org/2001/xml-events</code>,<code>DOMAttributeNameChanged</code>} is fired.</p>
					</item>
				</ulist>
			</descr>
			<parameters>
				<param name="n" type="Node" attr="in">
					<descr>
						<p>The node to rename.</p>
					</descr>
				</param>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The new<termref def="dt-namespaceURI">namespace URI</termref>.</p>
					</descr>
				</param>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The new<termref def="dt-qualifiedname">qualified name</termref>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The renamed node. This is either the specified node or the new node that was created to replace the specified node.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised when the type of the specified node is neither<code>ELEMENT_NODE</code>nor<code>ATTRIBUTE_NODE</code>, or if the implementation does not support the renaming of the<termref def="dt-document-element">document element</termref>.</p>
						<p>INVALID_CHARACTER_ERR: Raised if the new qualified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>WRONG_DOCUMENT_ERR: Raised when the specified node was created from a different document than this document.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from ""<bibref ref="Namespaces"/>. Also raised, when the node being renamed is an attribute, if the<code>qualifiedName</code>, or its prefix, is "xmlns" and the<code>namespaceURI</code>is different from "".</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Node" id="ID-1950641247">
		<descr>
			<p>The<code>Node</code>interface is the primary datatype for the entire Document Object Model. It represents a single node in the document tree. While all objects implementing the<code>Node</code>interface expose methods for dealing with children, not all objects implementing the<code>Node</code>interface may have children. For example,<code>Text</code>nodes may not have children, and adding children to such nodes results in a<code>DOMException</code>being raised.</p>
			<p>The attributes<code>nodeName</code>,<code>nodeValue</code>and<code>attributes</code>are included as a mechanism to get at node information without casting down to the specific derived interface. In cases where there is no obvious mapping of these attributes for a specific<code>nodeType</code>(e.g.,<code>nodeValue</code>for an<code>Element</code>or<code>attributes</code>for a<code>Comment</code>), this returns<code>null</code>. Note that the specialized interfaces may contain additional and more convenient mechanisms to get and set the relevant information.</p>
		</descr>
		<group id="ID-1841493061" name="NodeType">
			<descr>
				<p>An integer indicating which type of node this is.</p>
				<note>
					<p>Numeric codes up to 200 are reserved to W3C for possible future use.</p>
				</note>
			</descr>
			<constant id="Node-ELEMENT_NODE" name="ELEMENT_NODE" type="unsigned short" value="1">
				<descr>
					<p>The node is an<code>Element</code>.</p>
				</descr>
			</constant>
			<constant id="Node-ATTRIBUTE_NODE" name="ATTRIBUTE_NODE" type="unsigned short" value="2">
				<descr>
					<p>The node is an<code>Attr</code>.</p>
				</descr>
			</constant>
			<constant id="Node-TEXT_NODE" name="TEXT_NODE" type="unsigned short" value="3">
				<descr>
					<p>The node is a<code>Text</code>node.</p>
				</descr>
			</constant>
			<constant id="Node-CDATA_SECTION_NODE" name="CDATA_SECTION_NODE" type="unsigned short" value="4">
				<descr>
					<p>The node is a<code>CDATASection</code>.</p>
				</descr>
			</constant>
			<constant id="Node-ENTITY_REFERENCE_NODE" name="ENTITY_REFERENCE_NODE" type="unsigned short" value="5">
				<descr>
					<p>The node is an<code>EntityReference</code>.</p>
				</descr>
			</constant>
			<constant id="Node-ENTITY_NODE" name="ENTITY_NODE" type="unsigned short" value="6">
				<descr>
					<p>The node is an<code>Entity</code>.</p>
				</descr>
			</constant>
			<constant id="Node-PROCESSING_INSTRUCTION_NODE" name="PROCESSING_INSTRUCTION_NODE" type="unsigned short" value="7">
				<descr>
					<p>The node is a<code>ProcessingInstruction</code>.</p>
				</descr>
			</constant>
			<constant id="Node-COMMENT_NODE" name="COMMENT_NODE" type="unsigned short" value="8">
				<descr>
					<p>The node is a<code>Comment</code>.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_NODE" name="DOCUMENT_NODE" type="unsigned short" value="9">
				<descr>
					<p>The node is a<code>Document</code>.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_TYPE_NODE" name="DOCUMENT_TYPE_NODE" type="unsigned short" value="10">
				<descr>
					<p>The node is a<code>DocumentType</code>.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_FRAGMENT_NODE" name="DOCUMENT_FRAGMENT_NODE" type="unsigned short" value="11">
				<descr>
					<p>The node is a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
			<constant id="Node-NOTATION_NODE" name="NOTATION_NODE" type="unsigned short" value="12">
				<descr>
					<p>The node is a<code>Notation</code>.</p>
				</descr>
			</constant>
		</group>
		<p>The values of<code>nodeName</code>,<code>nodeValue</code>, and<code>attributes</code>vary according to the node type as follows:<table cellpadding="3" summary="Layout table: the first cell contains the name of the            interface, the second contains the value of the nodeName attribute            for this interface, the third contains the value of the nodeValue            attribute for this interface and the fourth contains the value of            the attributes attribute for this interface" border="1">
				<tbody>
					<tr>
						<th rowspan="1" colspan="1">Interface</th>
						<th rowspan="1" colspan="1">nodeName</th>
						<th rowspan="1" colspan="1">nodeValue</th>
						<th rowspan="1" colspan="1">attributes</th>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Attr</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>Attr.name</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>Attr.value</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>CDATASection</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>"#cdata-section"</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the CDATA Section</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Comment</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>"#comment"</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the comment</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Document</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>"#document"</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>DocumentFragment</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>"#document-fragment"</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>DocumentType</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>DocumentType.name</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Element</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>Element.tagName</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>NamedNodeMap</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Entity</code>
						</td>
						<td rowspan="1" colspan="1">entity name</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>EntityReference</code>
						</td>
						<td rowspan="1" colspan="1">name of entity referenced</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Notation</code>
						</td>
						<td rowspan="1" colspan="1">notation name</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>ProcessingInstruction</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>ProcessingInstruction.target</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>ProcessingInstruction.data</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">
							<code>Text</code>
						</td>
						<td rowspan="1" colspan="1">
							<code>"#text"</code>
						</td>
						<td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the text node</td>
						<td rowspan="1" colspan="1">
							<code>null</code>
						</td>
					</tr>
				</tbody>
			</table>
		</p>
		<attribute type="DOMString" readonly="yes" name="nodeName" id="ID-F68D095">
			<descr>
				<p>The name of this node, depending on its type; see the table above.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="nodeValue" id="ID-F68D080" readonly="no">
			<descr>
				<p>The value of this node, depending on its type; see the table above. When it is defined to be<code>null</code>, setting it has no effect, including if the node is<termref def="dt-readonly-node">read-only</termref>.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly and if it is not defined to be<code>null</code>.</p>
					</descr>
				</exception>
			</setraises>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute type="unsigned short" name="nodeType" readonly="yes" id="ID-111237558">
			<descr>
				<p>A code representing the type of the underlying object, as defined above.</p>
			</descr>
		</attribute>
		<attribute type="Node" readonly="yes" name="parentNode" id="ID-1060184317">
			<descr>
				<p>The<termref def="dt-parent">parent</termref>of this node. All nodes, except<code>Attr</code>,<code>Document</code>,<code>DocumentFragment</code>,<code>Entity</code>, and<code>Notation</code>may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute type="NodeList" readonly="yes" name="childNodes" id="ID-1451460987">
			<descr>
				<p>A<code>NodeList</code>that contains all children of this node. If there are no children, this is a<code>NodeList</code>containing no nodes.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="Node" name="firstChild" id="ID-169727388">
			<descr>
				<p>The first child of this node. If there is no such node, this returns<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="Node" name="lastChild" id="ID-61AD09FB">
			<descr>
				<p>The last child of this node. If there is no such node, this returns<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="Node" name="previousSibling" id="ID-640FB3C8">
			<descr>
				<p>The node immediately preceding this node. If there is no such node, this returns<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="Node" name="nextSibling" id="ID-6AC54C2F">
			<descr>
				<p>The node immediately following this node. If there is no such node, this returns<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="NamedNodeMap" name="attributes" id="ID-84CF096">
			<descr>
				<p>A<code>NamedNodeMap</code>containing the attributes of this node (if it is an<code>Element</code>) or<code>null</code>otherwise.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="Document" name="ownerDocument" id="node-ownerDoc" version="DOM Level 2">
			<descr>
				<p>The<code>Document</code>object associated with this node. This is also the<code>Document</code>object used to create new nodes. When this node is a<code>Document</code>or a<code>DocumentType</code>which is not used with any<code>Document</code>yet, this is<code>null</code>.</p>
			</descr>
		</attribute>
		<method name="insertBefore" id="ID-952280727" version="DOM Level 3">
			<descr>
				<p>Inserts the node<code>newChild</code>before the existing child node<code>refChild</code>. If<code>refChild</code>is<code>null</code>, insert<code>newChild</code>at the end of the list of children.</p>
				<p>If<code>newChild</code>is a<code>DocumentFragment</code>object, all of its children are inserted, in the same order, before<code>refChild</code>. If the<code>newChild</code>is already in the tree, it is first removed.</p>
				<note>
					<p>Inserting a node before itself is implementation dependent.</p>
				</note>
			</descr>
			<parameters>
				<param name="newChild" type="Node" attr="in">
					<descr>
						<p>The node to insert.</p>
					</descr>
				</param>
				<param name="refChild" type="Node" attr="in">
					<descr>
						<p>The reference node, i.e., the node before which the new node must be inserted.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node being inserted.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to insert is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the DOM application attempts to insert a second<code>DocumentType</code>or<code>Element</code>node.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the parent of the node being inserted is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if<code>refChild</code>is not a child of this node.</p>
						<p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the insertion of a<code>DocumentType</code>or<code>Element</code>node.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="replaceChild" id="ID-785887307" version="DOM Level 3">
			<descr>
				<p>Replaces the child node<code>oldChild</code>with<code>newChild</code>in the list of children, and returns the<code>oldChild</code>node.</p>
				<p>If<code>newChild</code>is a<code>DocumentFragment</code>object,<code>oldChild</code>is replaced by all of the<code>DocumentFragment</code>children, which are inserted in the same order. If the<code>newChild</code>is already in the tree, it is first removed.</p>
				<note>
					<p>Replacing a node with itself is implementation dependent.</p>
				</note>
			</descr>
			<parameters>
				<param name="newChild" type="Node" attr="in">
					<descr>
						<p>The new node to put in the child list.</p>
					</descr>
				</param>
				<param name="oldChild" type="Node" attr="in">
					<descr>
						<p>The node being replaced in the list.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node replaced.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to put in is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the result of the replacement operation would add a second<code>DocumentType</code>or<code>Element</code>on the<code>Document</code>node.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of the new node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if<code>oldChild</code>is not a child of this node.</p>
						<p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the replacement of the<code>DocumentType</code>child or<code>Element</code>child.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeChild" id="ID-1734834066" version="DOM Level 3">
			<descr>
				<p>Removes the child node indicated by<code>oldChild</code>from the list of children, and returns it.</p>
			</descr>
			<parameters>
				<param name="oldChild" type="Node" attr="in">
					<descr>
						<p>The node being removed.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node removed.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if<code>oldChild</code>is not a child of this node.</p>
						<p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the removal of the<code>DocumentType</code>child or the<code>Element</code>child.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="appendChild" id="ID-184E7107" version="DOM Level 3">
			<descr>
				<p>Adds the node<code>newChild</code>to the end of the list of children of this node. If the<code>newChild</code>is already in the tree, it is first removed.</p>
			</descr>
			<parameters>
				<param name="newChild" type="Node" attr="in">
					<descr>
						<p>The node to add.</p>
						<p>If it is a<code>DocumentFragment</code>object, the entire contents of the document fragment are moved into the child list of this node</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node added.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to append is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the DOM application attempts to append a second<code>DocumentType</code>or<code>Element</code>node.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the previous parent of the node being inserted is readonly.</p>
						<p>NOT_SUPPORTED_ERR: if the<code>newChild</code>node is a child of the<code>Document</code>node, this exception might be raised if the DOM implementation doesn't support the removal of the<code>DocumentType</code>child or<code>Element</code>child.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="hasChildNodes" id="ID-810594187">
			<descr>
				<p>Returns whether this node has any children.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if this node has any children,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="cloneNode" id="ID-3A0ED0A4">
			<descr>
				<p>Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent (<code>parentNode</code>is<code>null</code>) and no user data. User data associated to the imported node is not carried over. However, if any<code>UserDataHandlers</code>has been specified along with the associated data these handlers will be called with the appropriate parameters before this method returns.</p>
				<p>Cloning an<code>Element</code>copies all attributes and their values, including those generated by the XML processor to represent defaulted attributes, but this method does not copy any children it contains unless it is a deep clone. This includes text contained in an the<code>Element</code>since the text is contained in a child<code>Text</code>node. Cloning an<code>Attr</code>directly, as opposed to be cloned as part of an<code>Element</code>cloning operation, returns a specified attribute (<code>specified</code>is<code>true</code>). Cloning an<code>Attr</code>always clones its children, since they represent its value, no matter whether this is a deep clone or not. Cloning an<code>EntityReference</code>automatically constructs its subtree if a corresponding<code>Entity</code>is available, no matter whether this is a deep clone or not. Cloning any other type of node simply returns a copy of this node.</p>
				<p>Note that cloning an immutable subtree results in a mutable copy, but the children of an<code>EntityReference</code>clone are<termref def="dt-readonly-node">readonly</termref>. In addition, clones of unspecified<code>Attr</code>nodes are specified. And, cloning<code>Document</code>,<code>DocumentType</code>,<code>Entity</code>, and<code>Notation</code>nodes is implementation dependent.</p>
			</descr>
			<parameters>
				<param name="deep" type="boolean" attr="in">
					<descr>
						<p>If<code>true</code>, recursively clone the subtree under the specified node; if<code>false</code>, clone only the node itself (and its attributes, if it is an<code>Element</code>).</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The duplicate node.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method id="ID-normalize" name="normalize" version="DOM Level 3">
			<descr>
				<p>Puts all<code>Text</code>nodes in the full depth of the sub-tree underneath this<code>Node</code>, including attribute nodes, into a "normal" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates<code>Text</code>nodes, i.e., there are neither adjacent<code>Text</code>nodes nor empty<code>Text</code>nodes. This can be used to ensure that the DOM view of a document is the same as if it were saved and re-loaded, and is useful when operations (such as XPointer<bibref role="informative" ref="XPointer"/>lookups) that depend on a particular document tree structure are to be used. If the parameter "<termref def="parameter-normalize-characters">normalize-characters</termref>" of the<code>DOMConfiguration</code>object attached to the<code>Node.ownerDocument</code>is<code>true</code>, this method will also fully normalize the characters of the<code>Text</code>nodes.</p>
				<note>
					<p>In cases where the document contains<code>CDATASections</code>, the normalize operation alone may not be sufficient, since XPointers do not differentiate between<code>Text</code>nodes and<code>CDATASection</code>nodes.</p>
				</note>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isSupported" id="Level-2-Core-Node-supports" since="DOM Level 2">
			<descr>
				<p>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node, as specified in<specref ref="DOMFeatures"/>.</p>
			</descr>
			<parameters>
				<param name="feature" type="DOMString" attr="in">
					<descr>
						<p>The name of the feature to test.</p>
					</descr>
				</param>
				<param name="version" type="DOMString" attr="in">
					<descr>
						<p>This is the version number of the feature to test.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if the specified feature is supported on this node,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute readonly="yes" type="DOMString" name="namespaceURI" id="ID-NodeNSname" since="DOM Level 2">
			<descr>
				<p>The<termref def="dt-namespaceURI">namespace URI</termref>of this node, or<code>null</code>if it is unspecified (see<specref ref="Namespaces-Considerations"/>).</p>
				<p>This is not a computed value that is the result of a namespace lookup based on an examination of the namespace declarations in scope. It is merely the namespace URI given at creation time.</p>
				<p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>Document.createElement()</code>, this is always<code>null</code>.</p>
				<note>
					<p>Per the<emph>Namespaces in XML</emph>Specification<bibref ref="Namespaces"/>an attribute does not inherit its namespace from the element it is attached to. If an attribute is not explicitly given a namespace, it simply has no namespace.</p>
				</note>
			</descr>
		</attribute>
		<attribute type="DOMString" name="prefix" id="ID-NodeNSPrefix" since="DOM Level 2" readonly="no">
			<descr>
				<p>The<termref def="dt-namespaceprefix">namespace prefix</termref>of this node, or<code>null</code>if it is unspecified. When it is defined to be<code>null</code>, setting it has no effect, including if the node is<termref def="dt-readonly-node">read-only</termref>.</p>
				<p>Note that setting this attribute, when permitted, changes the<code>nodeName</code>attribute, which holds the<termref def="dt-qualifiedname">qualified name</termref>, as well as the<code>tagName</code>and<code>name</code>attributes of the<code>Element</code>and<code>Attr</code>interfaces, when applicable.</p>
				<p>Setting the prefix to<code>null</code>makes it unspecified, setting it to an empty string is implementation dependent.</p>
				<p>Note also that changing the prefix of an attribute that is known to have a default value, does not make a new attribute with the default value and the original prefix appear, since the<code>namespaceURI</code>and<code>localName</code>do not change.</p>
				<p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>createElement</code>from the<code>Document</code>interface, this is always<code>null</code>.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified prefix contains an illegal character according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NAMESPACE_ERR: Raised if the specified<code>prefix</code>is malformed per the Namespaces in XML specification, if the<code>namespaceURI</code>of this node is<code>null</code>, if the specified prefix is "xml" and the<code>namespaceURI</code>of this node is different from "", if this node is an attribute and the specified prefix is "xmlns" and the<code>namespaceURI</code>of this node is different from "", or if this node is an attribute and the<code>qualifiedName</code>of this node is "xmlns"<bibref ref="Namespaces"/>.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="localName" id="ID-NodeNSLocalN" since="DOM Level 2">
			<descr>
				<p>Returns the local part of the<termref def="dt-qualifiedname">qualified name</termref>of this node.</p>
				<p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>Document.createElement()</code>, this is always<code>null</code>.</p>
			</descr>
		</attribute>
		<method name="hasAttributes" id="ID-NodeHasAttrs" since="DOM Level 2">
			<descr>
				<p>Returns whether this node (if it is an element) has any attributes.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if this node has any attributes,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute readonly="yes" type="DOMString" name="baseURI" id="Node3-baseURI" since="DOM Level 3">
			<descr>
				<p>The absolute base URI of this node or<code>null</code>if the implementation wasn't able to obtain an absolute URI. This value is computed as described in<specref ref="baseURIs-Considerations"/>. However, when the<code>Document</code>supports the feature "HTML"<bibref role="informative" ref="DOM2HTML"/>, the base URI is computed using first the value of the href attribute of the HTML BASE element if any, and the value of the<code>documentURI</code>attribute from the<code>Document</code>interface otherwise.</p>
			</descr>
		</attribute>
		<group id="DocumentPosition" name="DocumentPosition" since="DOM Level 3">
			<descr>
				<p>A bitmask indicating the relative document position of a node with respect to another node.</p>
				<p>If the two nodes being compared are the same node, then no flags are set on the return.</p>
				<p>Otherwise, the order of two nodes is determined by looking for common containers -- containers which contain both. A node directly contains any child nodes. A node also directly contains any other nodes attached to it such as attributes contained in an element or entities and notations contained in a document type. Nodes contained in contained nodes are also contained, but less-directly as the number of intervening containers increases.</p>
				<p>If there is no common container node, then the order is based upon order between the root container of each node that is in no container. In this case, the result is disconnected and implementation-specific. This result is stable as long as these outer-most containing nodes remain in memory and are not inserted into some other containing node. This would be the case when the nodes belong to different documents or fragments, and cloning the document or inserting a fragment might change the order.</p>
				<p>If one of the nodes being compared contains the other node, then the container precedes the contained node, and reversely the contained node follows the container. For example, when comparing an element against its own attribute or child, the element node precedes its attribute node and its child node, which both follow it.</p>
				<p>If neither of the previous cases apply, then there exists a most-direct container common to both nodes being compared. In this case, the order is determined based upon the two determining nodes directly contained in this most-direct common container that either are or contain the corresponding nodes being compared.</p>
				<p>If these two determining nodes are both child nodes, then the natural DOM order of these determining nodes within the containing node is returned as the order of the corresponding nodes. This would be the case, for example, when comparing two child elements of the same element.</p>
				<p>If one of the two determining nodes is a child node and the other is not, then the corresponding node of the child node follows the corresponding node of the non-child node. This would be the case, for example, when comparing an attribute of an element with a child element of the same element.</p>
				<p>If neither of the two determining node is a child node and one determining node has a greater value of<code>nodeType</code>than the other, then the corresponding node precedes the other. This would be the case, for example, when comparing an entity of a document type against a notation of the same document type.</p>
				<p>If neither of the two determining node is a child node and<code>nodeType</code>is the same for both determining nodes, then an implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of the same nodeType are inserted into or removed from the direct container. This would be the case, for example, when comparing two attributes of the same element, and inserting or removing additional attributes might change the order between existing attributes.</p>
			</descr>
			<constant id="Node-DOCUMENT_POSITION_DISCONNECTED" name="DOCUMENT_POSITION_DISCONNECTED" type="unsigned short" value="0x01">
				<descr>
					<p>The two nodes are disconnected. Order between disconnected nodes is always implementation-specific.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_POSITION_PRECEDING" name="DOCUMENT_POSITION_PRECEDING" type="unsigned short" value="0x02">
				<descr>
					<p>The second node precedes the reference node.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_POSITION_FOLLOWING" name="DOCUMENT_POSITION_FOLLOWING" type="unsigned short" value="0x04">
				<descr>
					<p>The node follows the reference node.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_POSITION_CONTAINS" name="DOCUMENT_POSITION_CONTAINS" type="unsigned short" value="0x08">
				<descr>
					<p>The node contains the reference node. A node which contains is always preceding, too.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_POSITION_CONTAINED_BY" name="DOCUMENT_POSITION_CONTAINED_BY" type="unsigned short" value="0x10">
				<descr>
					<p>The node is contained by the reference node. A node which is contained is always following, too.</p>
				</descr>
			</constant>
			<constant id="Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" type="unsigned short" value="0x20">
				<descr>
					<p>The determination of preceding versus following is implementation-specific.</p>
				</descr>
			</constant>
		</group>
		<method name="compareDocumentPosition" id="Node3-compareDocumentPosition" since="DOM Level 3">
			<descr>
				<p>Compares the reference node, i.e. the node on which this method is being called, with a node, i.e. the one passed as a parameter, with regard to their position in the document and according to the<termref def="dt-document-order">document order</termref>.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="other">
					<descr>
						<p>The node to compare against the reference node.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Returns how the node is positioned relatively to the reference node.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: when the compared nodes are from different DOM implementations that do not coordinate to return consistent implementation-specific results.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<attribute name="textContent" id="Node3-textContent" type="DOMString" readonly="no" since="DOM Level 3">
			<descr>
				<p>This attribute returns the text content of this node and its descendants. When it is defined to be<code>null</code>, setting it has no effect. On setting, any possible children this node may have are removed and, if it the new string is not empty or<code>null</code>, replaced by a single<code>Text</code>node containing the string this attribute is set to.</p>
				<p>On getting, no serialization is performed, the returned string does not contain any markup. No whitespace normalization is performed and the returned string does not contain the white spaces in element content (see the attribute<code>Text.isElementContentWhitespace</code>). Similarly, on setting, no parsing is performed either, the input string is taken as pure textual content.</p>
				<p>The string returned is made of the text content of this node depending on its type, as defined below:</p>
				<table cellpadding="3" summary="The string returned is made of the text content of the                node. The first cell of this table contains the type of the                Node, the second cell indicates the string returned by                textContent." border="1">
					<tbody>
						<tr>
							<th rowspan="1" colspan="1">Node type</th>
							<th rowspan="1" colspan="1">Content</th>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE, DOCUMENT_FRAGMENT_NODE</td>
							<td rowspan="1" colspan="1">concatenation of the<code>textContent</code>attribute value of every child node, excluding COMMENT_NODE and PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the node has no children.</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE, PROCESSING_INSTRUCTION_NODE</td>
							<td rowspan="1" colspan="1">
								<code>nodeValue</code>
							</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE</td>
							<td rowspan="1" colspan="1">
								<emph>null</emph>
							</td>
						</tr>
					</tbody>
				</table>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
					</descr>
				</exception>
			</setraises>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<method name="isSameNode" id="Node3-isSameNode" since="DOM Level 3">
			<descr>
				<p>Returns whether this node is the same node as the given one.</p>
				<p>This method provides a way to determine whether two<code>Node</code>references returned by the implementation reference the same object. When two<code>Node</code>references are references to the same object, even if through a proxy, the references may be used completely interchangeably, such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="other">
					<descr>
						<p>The node to test against.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if the nodes are the same,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="lookupPrefix" id="Node3-lookupNamespacePrefix" since="DOM Level 3">
			<descr>
				<p>Look up the prefix associated to the given namespace URI, starting from this node. The default namespace declarations are ignored by this method.</p>
				<p>See<specref ref="lookupNamespacePrefixAlgo"/>for details on the algorithm used by this method.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="namespaceURI">
					<descr>
						<p>The namespace URI to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>Returns an associated namespace prefix if found or<code>null</code>if none is found. If more than one prefix are associated to the namespace prefix, the returned namespace prefix is implementation dependent.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isDefaultNamespace" id="Node3-isDefaultNamespace" since="DOM Level 3">
			<descr>
				<p>This method checks if the specified<code>namespaceURI</code>is the default namespace or not.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The namespace URI to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if the specified<code>namespaceURI</code>is the default namespace,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="lookupNamespaceURI" id="Node3-lookupNamespaceURI" since="DOM Level 3">
			<descr>
				<p>Look up the namespace URI associated to the given prefix, starting from this node.</p>
				<p>See<specref ref="lookupNamespaceURIAlgo"/>for details on the algorithm used by this method.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="prefix">
					<descr>
						<p>The prefix to look for. If this parameter is<code>null</code>, the method will return the default namespace URI if any.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>Returns the associated namespace URI or<code>null</code>if none is found.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isEqualNode" id="Node3-isEqualNode" since="DOM Level 3">
			<descr>
				<p>Tests whether two nodes are equal.</p>
				<p>This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested with<code>Node.isSameNode()</code>. All nodes that are the same will also be equal, though the reverse may not be true.</p>
				<p>Two nodes are equal if and only if the following conditions are satisfied:<ulist>
						<item>
							<p>The two nodes are of the same type.</p>
						</item>
						<item>
							<p>The following string attributes are equal:<code>nodeName</code>,<code>localName</code>,<code>namespaceURI</code>,<code>prefix</code>,<code>nodeValue</code>. This is: they are both<code>null</code>, or they have the same length and are character for character identical.</p>
						</item>
						<item>
							<p>The<code>attributes</code>
								<code>NamedNodeMaps</code>are equal. This is: they are both<code>null</code>, or they have the same length and for each node that exists in one map there is a node that exists in the other map and is equal, although not necessarily at the same index.</p>
						</item>
						<item>
							<p>The<code>childNodes</code>
								<code>NodeLists</code>are equal. This is: they are both<code>null</code>, or they have the same length and contain equal nodes at the same index. Note that normalization can affect equality; to avoid this, nodes should be normalized before being compared.</p>
						</item>
					</ulist>
				</p>
				<p>For two<code>DocumentType</code>nodes to be equal, the following conditions must also be satisfied:<ulist>
						<item>
							<p>The following string attributes are equal:<code>publicId</code>,<code>systemId</code>,<code>internalSubset</code>.</p>
						</item>
						<item>
							<p>The<code>entities</code>
								<code>NamedNodeMaps</code>are equal.</p>
						</item>
						<item>
							<p>The<code>notations</code>
								<code>NamedNodeMaps</code>are equal.</p>
						</item>
					</ulist>
				</p>
				<p>On the other hand, the following do not affect equality: the<code>ownerDocument</code>,<code>baseURI</code>, and<code>parentNode</code>attributes, the<code>specified</code>attribute for<code>Attr</code>nodes, the<code>schemaTypeInfo</code>attribute for<code>Attr</code>and<code>Element</code>nodes, the<code>Text.isElementContentWhitespace</code>attribute for<code>Text</code>nodes, as well as any user data or event listeners registered on the nodes.</p>
				<note>
					<p>As a general rule, anything not mentioned in the description above is not significant in consideration of equality checking. Note that future versions of this specification may take into account more attributes and implementations conform to this specification are expected to be updated accordingly.</p>
				</note>
			</descr>
			<parameters>
				<param name="arg" type="Node" attr="in">
					<descr>
						<p>The node to compare equality with.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if the nodes are equal,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getFeature" id="Node3-getFeature" since="DOM Level 3">
			<descr>
				<p>This method returns a specialized object which implements the specialized APIs of the specified feature and version, as specified in<specref ref="DOMFeatures"/>. The specialized object may also be obtained by using binding-specific casting methods but is not necessarily expected to, as discussed in<specref ref="Embedded-DOM"/>. This method also allow the implementation to provide specialized objects which do not support the<code>Node</code>interface.</p>
			</descr>
			<parameters>
				<param name="feature" type="DOMString" attr="in">
					<descr>
						<p>The name of the feature requested. Note that any plus sign "+" prepended to the name of the feature will be ignored since it is not significant in the context of this method.</p>
					</descr>
				</param>
				<param name="version" type="DOMString" attr="in">
					<descr>
						<p>This is the version number of the feature to test.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMObject">
				<descr>
					<p>Returns an object which implements the specialized APIs of the specified feature and version, if any, or<code>null</code>if there is no object which implements interfaces associated with that feature. If the<code>DOMObject</code>returned by this method implements the<code>Node</code>interface, it must delegate to the primary core<code>Node</code>and not return results inconsistent with the primary core<code>Node</code>such as attributes, childNodes, etc.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="setUserData" id="Node3-setUserData" since="DOM Level 3">
			<descr>
				<p>Associate an object to a key on this node. The object can later be retrieved from this node by calling<code>getUserData</code>with the same key.</p>
			</descr>
			<parameters>
				<param name="key" type="DOMString" attr="in">
					<descr>
						<p>The key to associate the object to.</p>
					</descr>
				</param>
				<param name="data" type="DOMUserData" attr="in">
					<descr>
						<p>The object to associate to the given key, or<code>null</code>to remove any existing association to that key.</p>
					</descr>
				</param>
				<param name="handler" type="UserDataHandler" attr="in">
					<descr>
						<p>The handler to associate to that key, or<code>null</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMUserData">
				<descr>
					<p>Returns the<code>DOMUserData</code>previously associated to the given key on this node, or<code>null</code>if there was none.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getUserData" id="Node3-getUserData" since="DOM Level 3">
			<descr>
				<p>Retrieves the object associated to a key on a this node. The object must first have been set to this node by calling<code>setUserData</code>with the same key.</p>
			</descr>
			<parameters>
				<param name="key" type="DOMString" attr="in">
					<descr>
						<p>The key the object is associated to.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMUserData">
				<descr>
					<p>Returns the<code>DOMUserData</code>associated to the given key on this node, or<code>null</code>if there was none.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="NodeList" id="ID-536297177">
		<descr>
			<p>The<code>NodeList</code>interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented.<code>NodeList</code>objects in the DOM are<termref def="td-live">live</termref>.</p>
			<p>The items in the<code>NodeList</code>are accessible via an integral index, starting from 0.</p>
		</descr>
		<method name="item" id="ID-844377136">
			<descr>
				<p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of nodes in the list, this returns<code>null</code>.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node at the<code>index</code>th position in the<code>NodeList</code>, or<code>null</code>if that is not a valid index.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="length" id="ID-203510337">
			<descr>
				<p>The number of nodes in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="NamedNodeMap" id="ID-1780488922">
		<descr>
			<p>Objects implementing the<code>NamedNodeMap</code>interface are used to represent collections of nodes that can be accessed by name. Note that<code>NamedNodeMap</code>does not inherit from<code>NodeList</code>;<code>NamedNodeMaps</code>are not maintained in any particular order. Objects contained in an object implementing<code>NamedNodeMap</code>may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a<code>NamedNodeMap</code>, and does not imply that the DOM specifies an order to these Nodes.</p>
			<p>
				<code>NamedNodeMap</code>objects in the DOM are<termref def="td-live">live</termref>.</p>
		</descr>
		<method name="getNamedItem" id="ID-1074577549">
			<descr>
				<p>Retrieves a node specified by name.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The<code>nodeName</code>of a node to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>A<code>Node</code>(of any type) with the specified<code>nodeName</code>, or<code>null</code>if it does not identify any node in this map.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="setNamedItem" id="ID-1025163788">
			<descr>
				<p>Adds a node using its<code>nodeName</code>attribute. If a node with that name is already present in this map, it is replaced by the new one. Replacing a node by itself has no effect.</p>
				<p>As the<code>nodeName</code>attribute is used to derive the name which the node must be stored under, multiple nodes of certain types (those that have a "special" string value) cannot be stored as the names would clash. This is seen as preferable to allowing nodes to be aliased.</p>
			</descr>
			<parameters>
				<param name="arg" type="Node" attr="in">
					<descr>
						<p>A node to store in this map. The node will later be accessible using the value of its<code>nodeName</code>attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>If the new<code>Node</code>replaces an existing node the replaced<code>Node</code>is returned, otherwise<code>null</code>is returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>arg</code>was created from a different document than the one that created this map.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
						<p>INUSE_ATTRIBUTE_ERR: Raised if<code>arg</code>is an<code>Attr</code>that is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p>
						<p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node doesn't belong in this NamedNodeMap. Examples would include trying to insert something other than an Attr node into an Element's map of attributes, or a non-Entity node into the DocumentType's map of Entities.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeNamedItem" id="ID-D58B193">
			<descr>
				<p>Removes a node specified by name. When this map contains the attributes attached to an element, if the removed attribute is known to have a default value, an attribute immediately appears containing the default value as well as the corresponding namespace URI, local name, and prefix when applicable.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The<code>nodeName</code>of the node to remove.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node removed from this map if a node with such a name exists.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_FOUND_ERR: Raised if there is no node named<code>name</code>in this map.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="item" id="ID-349467F9">
			<descr>
				<p>Returns the<code>index</code>th item in the map. If<code>index</code>is greater than or equal to the number of nodes in this map, this returns<code>null</code>.</p>
			</descr>
			<parameters>
				<param name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into this map.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node at the<code>index</code>th position in the map, or<code>null</code>if that is not a valid index.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="length" id="ID-6D0FB19E">
			<descr>
				<p>The number of nodes in this map. The range of valid child node indices is<code>0</code>to<code>length-1</code>inclusive.</p>
			</descr>
		</attribute>
		<method name="getNamedItemNS" id="ID-getNamedItemNS" since="DOM Level 2">
			<descr>
				<p>Retrieves a node specified by local name and namespace URI.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the node to retrieve.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the node to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>A<code>Node</code>(of any type) with the specified local name and namespace URI, or<code>null</code>if they do not identify any node in this map.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setNamedItemNS" id="ID-setNamedItemNS" since="DOM Level 2">
			<descr>
				<p>Adds a node using its<code>namespaceURI</code>and<code>localName</code>. If a node with that namespace URI and that local name is already present in this map, it is replaced by the new one. Replacing a node by itself has no effect.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="arg" type="Node" attr="in">
					<descr>
						<p>A node to store in this map. The node will later be accessible using the value of its<code>namespaceURI</code>and<code>localName</code>attributes.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>If the new<code>Node</code>replaces an existing node the replaced<code>Node</code>is returned, otherwise<code>null</code>is returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>arg</code>was created from a different document than the one that created this map.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
						<p>INUSE_ATTRIBUTE_ERR: Raised if<code>arg</code>is an<code>Attr</code>that is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p>
						<p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node doesn't belong in this NamedNodeMap. Examples would include trying to insert something other than an Attr node into an Element's map of attributes, or a non-Entity node into the DocumentType's map of Entities.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeNamedItemNS" id="ID-removeNamedItemNS" since="DOM Level 2">
			<descr>
				<p>Removes a node specified by local name and namespace URI. A removed attribute may be known to have a default value when this map contains the attributes attached to an element, as returned by the attributes attribute of the<code>Node</code>interface. If so, an attribute immediately appears containing the default value as well as the corresponding namespace URI, local name, and prefix when applicable.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the node to remove.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the node to remove.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node removed from this map if a node with such a local name and namespace URI exists.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_FOUND_ERR: Raised if there is no node with the specified<code>namespaceURI</code>and<code>localName</code>in this map.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="CharacterData" inherits="Node" id="ID-FF21A306">
		<descr>
			<p>The<code>CharacterData</code>interface extends Node with a set of attributes and methods for accessing character data in the DOM. For clarity this set is defined here rather than on each object that uses these attributes and methods. No DOM objects correspond directly to<code>CharacterData</code>, though<code>Text</code>and others do inherit the interface from it. All<code>offsets</code>in this interface start from<code>0</code>.</p>
			<p>As explained in the<code>DOMString</code>interface, text strings in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units. In the following, the term<termref def="dt-16-bit-unit">16-bit units</termref>is used whenever necessary to indicate that indexing on CharacterData is done in 16-bit units.</p>
		</descr>
		<attribute type="DOMString" name="data" id="ID-72AB8359" readonly="no">
			<descr>
				<p>The character data of the node that implements this interface. The DOM implementation may not put arbitrary limits on the amount of data that may be stored in a<code>CharacterData</code>node. However, implementation limits may mean that the entirety of a node's data may not fit into a single<code>DOMString</code>. In such cases, the user may call<code>substringData</code>to retrieve the data in appropriately sized pieces.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
					</descr>
				</exception>
			</setraises>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute type="unsigned long" name="length" readonly="yes" id="ID-7D61178C">
			<descr>
				<p>The number of<termref def="dt-16-bit-unit">16-bit units</termref>that are available through<code>data</code>and the<code>substringData</code>method below. This may have the value zero, i.e.,<code>CharacterData</code>nodes may be empty.</p>
			</descr>
		</attribute>
		<method name="substringData" id="ID-6531BCCF">
			<descr>
				<p>Extracts a range of data from the node.</p>
			</descr>
			<parameters>
				<param name="offset" type="unsigned long" attr="in">
					<descr>
						<p>Start offset of substring to extract.</p>
					</descr>
				</param>
				<param name="count" type="unsigned long" attr="in">
					<descr>
						<p>The number of 16-bit units to extract.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The specified substring. If the sum of<code>offset</code>and<code>count</code>exceeds the<code>length</code>, then all 16-bit units to the end of the data are returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p>
						<p>DOMSTRING_SIZE_ERR: Raised if the specified range of text does not fit into a<code>DOMString</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="appendData" id="ID-32791A2F">
			<descr>
				<p>Append the string to the end of the character data of the node. Upon success,<code>data</code>provides access to the concatenation of<code>data</code>and the<code>DOMString</code>specified.</p>
			</descr>
			<parameters>
				<param name="arg" type="DOMString" attr="in">
					<descr>
						<p>The<code>DOMString</code>to append.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="insertData" id="ID-3EDB695F">
			<descr>
				<p>Insert a string at the specified<termref def="dt-16-bit-unit">16-bit unit</termref>offset.</p>
			</descr>
			<parameters>
				<param name="offset" type="unsigned long" attr="in">
					<descr>
						<p>The character offset at which to insert.</p>
					</descr>
				</param>
				<param name="arg" type="DOMString" attr="in">
					<descr>
						<p>The<code>DOMString</code>to insert.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="deleteData" id="ID-7C603781">
			<descr>
				<p>Remove a range of<termref def="dt-16-bit-unit">16-bit units</termref>from the node. Upon success,<code>data</code>and<code>length</code>reflect the change.</p>
			</descr>
			<parameters>
				<param name="offset" type="unsigned long" attr="in">
					<descr>
						<p>The offset from which to start removing.</p>
					</descr>
				</param>
				<param name="count" type="unsigned long" attr="in">
					<descr>
						<p>The number of 16-bit units to delete. If the sum of<code>offset</code>and<code>count</code>exceeds<code>length</code>then all 16-bit units from<code>offset</code>to the end of the data are deleted.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="replaceData" id="ID-E5CBA7FB">
			<descr>
				<p>Replace the characters starting at the specified<termref def="dt-16-bit-unit">16-bit unit</termref>offset with the specified string.</p>
			</descr>
			<parameters>
				<param name="offset" type="unsigned long" attr="in">
					<descr>
						<p>The offset from which to start replacing.</p>
					</descr>
				</param>
				<param name="count" type="unsigned long" attr="in">
					<descr>
						<p>The number of 16-bit units to replace. If the sum of<code>offset</code>and<code>count</code>exceeds<code>length</code>, then all 16-bit units to the end of the data are replaced; (i.e., the effect is the same as a<code>remove</code>method call with the same range, followed by an<code>append</code>method invocation).</p>
					</descr>
				</param>
				<param name="arg" type="DOMString" attr="in">
					<descr>
						<p>The<code>DOMString</code>with which the range must be replaced.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Attr" inherits="Node" id="ID-637646024">
		<descr>
			<p>The<code>Attr</code>interface represents an attribute in an<code>Element</code>object. Typically the allowable values for the attribute are defined in a schema associated with the document.</p>
			<p>
				<code>Attr</code>objects inherit the<code>Node</code>interface, but since they are not actually child nodes of the element they describe, the DOM does not consider them part of the document tree. Thus, the<code>Node</code>attributes<code>parentNode</code>,<code>previousSibling</code>, and<code>nextSibling</code>have a<code>null</code>value for<code>Attr</code>objects. The DOM takes the view that attributes are properties of elements rather than having a separate identity from the elements they are associated with; this should make it more efficient to implement such features as default attributes associated with all elements of a given type. Furthermore,<code>Attr</code>nodes may not be immediate children of a<code>DocumentFragment</code>. However, they can be associated with<code>Element</code>nodes contained within a<code>DocumentFragment</code>. In short, users and implementors of the DOM need to be aware that<code>Attr</code>nodes have some things in common with other objects inheriting the<code>Node</code>interface, but they also are quite distinct.</p>
			<p>The attribute's effective value is determined as follows: if this attribute has been explicitly assigned any value, that value is the attribute's effective value; otherwise, if there is a declaration for this attribute, and that declaration includes a default value, then that default value is the attribute's effective value; otherwise, the attribute does not exist on this element in the structure model until it has been explicitly added. Note that the<code>Node.nodeValue</code>attribute on the<code>Attr</code>instance can also be used to retrieve the string version of the attribute's value(s).</p>
			<p>If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with<code>specified</code>set to<code>false</code>. Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and<code>specified</code>set to<code>false</code>. If validation occurred while invoking<code>Document.normalizeDocument()</code>, attribute nodes with<code>specified</code>equals to<code>false</code>are recomputed according to the default attribute values provided by the schema. If no default value is associate with this attribute in the schema, the attribute node is discarded.</p>
			<p>In XML, where the value of an attribute can contain entity references, the child nodes of the<code>Attr</code>node may be either<code>Text</code>or<code>EntityReference</code>nodes (when these are in use; see the description of<code>EntityReference</code>for discussion).</p>
			<p>The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as<termref def="dt-tokenized">tokenized</termref>.</p>
			<p>The way attribute value normalization is performed by the DOM implementation depends on how much the implementation knows about the schema in use. Typically, the<code>value</code>and<code>nodeValue</code>attributes of an<code>Attr</code>node initially returns the normalized value given by the parser. It is also the case after<code>Document.normalizeDocument()</code>is called (assuming the right options have been set). But this may not be the case after mutation, independently of whether the mutation is performed by setting the string value directly or by changing the<code>Attr</code>child nodes. In particular, this is true whenare involved, given that they are not represented in the DOM and they impact attribute value normalization. On the other hand, if the implementation knows about the schema in use when the attribute value is changed, and it is of a different type than CDATA, it may normalize it again at that time. This is especially true of specialized DOM implementations, such as SVG DOM implementations, which store attribute values in an internal form different from a string.</p>
			<p>The following table gives some examples of the relations between the attribute value in the original document (parsed attribute), the value as exposed in the DOM, and the serialization of the value:</p>
			<table cellpadding="3" border="1" summary="Examples of differences between a parsed attribute,     its DOM representation, and its serialization">
				<tbody>
					<tr>
						<th rowspan="1" colspan="1">Examples</th>
						<th rowspan="1" colspan="1">Parsed attribute value</th>
						<th rowspan="1" colspan="1">Initial<code>Attr.value</code>
						</th>
						<th rowspan="1" colspan="1">Serialized attribute value</th>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Character reference</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x&amp;#178;=5"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x²=5"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x&amp;#178;=5"</eg>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Built-in character entity</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"y&amp;lt;6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"y&lt;6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"y&amp;lt;6"</eg>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Literal newline between</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5&amp;#10;y=6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5 y=6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5&amp;#10;y=6"</eg>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Normalized newline between</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5 y=6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5 y=6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">"x=5 y=6"</eg>
						</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Entity<code>e</code>with literal newline</td>
						<td rowspan="1" colspan="1">
							<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">&lt;!ENTITY e '...&amp;#10;...'&gt; [...]&gt; "x=5&amp;e;y=6"</eg>
						</td>
						<td rowspan="1" colspan="1">
							<emph>Dependent on Implementation and Load Options</emph>
						</td>
						<td rowspan="1" colspan="1">
							<emph>Dependent on Implementation and Load/Save Options</emph>
						</td>
					</tr>
				</tbody>
			</table>
		</descr>
		<attribute type="DOMString" readonly="yes" name="name" id="ID-1112119403">
			<descr>
				<p>Returns the name of this attribute. If<code>Node.localName</code>is different from<code>null</code>, this attribute is a<termref def="dt-qualifiedname">qualified name</termref>.</p>
			</descr>
		</attribute>
		<attribute type="boolean" readonly="yes" name="specified" id="ID-862529273">
			<descr>
				<p>
					<code>True</code>if this attribute was explicitly given a value in the instance document,<code>false</code>otherwise. If the application changed the value of this attribute node (even if it ends up having the same value as the default value) then it is set to<code>true</code>. The implementation may handle attributes with default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="value" id="ID-221662474" readonly="no">
			<descr>
				<p>On retrieval, the value of the attribute is returned as a string. Character and general entity references are replaced with their values. See also the method<code>getAttribute</code>on the<code>Element</code>interface.</p>
				<p>On setting, this creates a<code>Text</code>node with the unparsed contents of the string, i.e. any characters that an XML processor would recognize as markup are instead treated as literal text. See also the method<code>Element.setAttribute()</code>.</p>
				<p>Some specialized implementations, such as some<bibref ref="SVG1" role="informative"/>implementations, may do normalization automatically, even after mutation; in such case, the value on retrieval may differ from the value on setting.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<attribute name="ownerElement" type="Element" readonly="yes" id="Attr-ownerElement" since="DOM Level 2">
			<descr>
				<p>The<code>Element</code>node this attribute is attached to or<code>null</code>if this attribute is not in use.</p>
			</descr>
		</attribute>
		<attribute name="schemaTypeInfo" type="TypeInfo" id="Attr-schemaTypeInfo" since="DOM Level 3" readonly="yes">
			<descr>
				<p>The type information associated with this attribute. While the type information contained in this attribute is guarantee to be correct after loading the document or invoking<code>Document.normalizeDocument()</code>,<code>schemaTypeInfo</code>may not be reliable if the node was moved.</p>
			</descr>
		</attribute>
		<attribute name="isId" id="Attr-isId" since="DOM Level 3" readonly="yes" type="boolean">
			<descr>
				<p>Returns whether this attribute is known to be of type ID (i.e. to contain an identifier for its owner element) or not. When it is and its value is unique, the<code>ownerElement</code>of this attribute can be retrieved using the method<code>Document.getElementById</code>. The implementation could use several ways to determine if an attribute node is known to contain an identifier:</p>
				<ulist>
					<item>
						<p>If validation occurred using an XML Schema<bibref ref="XMLSchema1"/>while loading the document or while invoking<code>Document.normalizeDocument()</code>, the post-schema-validation infoset contributions (PSVI contributions) values are used to determine if this attribute is a<term>schema-determined ID attribute</term>using thedefinition in<bibref ref="XPointer"/>.</p>
					</item>
					<item>
						<p>If validation occurred using a DTD while loading the document or while invoking<code>Document.normalizeDocument()</code>, the infoset<b>[type definition]</b>value is used to determine if this attribute is a<term>DTD-determined ID attribute</term>using thedefinition in<bibref ref="XPointer"/>.</p>
					</item>
					<item>
						<p>from the use of the methods<code>Element.setIdAttribute()</code>,<code>Element.setIdAttributeNS()</code>, or<code>Element.setIdAttributeNode()</code>, i.e. it is an<term>user-determined ID attribute</term>;</p>
						<note>
							<p>XPointer framework (see section 3.2 in<bibref role="informative" ref="XPointer"/>) consider the DOM<term>user-determined ID attribute</term>as being part of the XPointer<term>externally-determined ID</term>definition.</p>
						</note>
					</item>
					<item>
						<p>using mechanisms that are outside the scope of this specification, it is then an<term>externally-determined ID attribute</term>. This includes using schema languages different from XML schema and DTD.</p>
					</item>
				</ulist>
				<p>If validation occurred while invoking<code>Document.normalizeDocument()</code>, all<term>user-determined ID attributes</term>are reset and all attribute nodes ID information are then reevaluated in accordance to the schema used. As a consequence, if the<code>Attr.schemaTypeInfo</code>attribute contains an ID type,<code>isId</code>will always return true.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="Element" inherits="Node" id="ID-745549614">
		<descr>
			<p>The<code>Element</code>interface represents an<termref def="dt-element">element</termref>in an HTML or XML document. Elements may have attributes associated with them; since the<code>Element</code>interface inherits from<code>Node</code>, the generic<code>Node</code>interface attribute<code>attributes</code>may be used to retrieve the set of all attributes for an element. There are methods on the<code>Element</code>interface to retrieve either an<code>Attr</code>object by name or an attribute value by name. In XML, where an attribute value may contain entity references, an<code>Attr</code>object should be retrieved to examine the possibly fairly complex sub-tree representing the attribute value. On the other hand, in HTML, where all attributes have simple string values, methods to directly access an attribute value can safely be used as a<termref def="dt-convenience">convenience</termref>.</p>
			<note>
				<p>In DOM Level 2, the method<code>normalize</code>is inherited from the<code>Node</code>interface where it was moved.</p>
			</note>
		</descr>
		<attribute type="DOMString" name="tagName" readonly="yes" id="ID-104682815">
			<descr>
				<p>The name of the element. If<code>Node.localName</code>is different from<code>null</code>, this attribute is a<termref def="dt-qualifiedname">qualified name</termref>. For example, in:<eg role="code" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">&lt;elementExample id="demo"&gt; ... &lt;/elementExample&gt; ,</eg>
					<code>tagName</code>has the value<code>"elementExample"</code>. Note that this is case-preserving in XML, as are all of the operations of the DOM. The HTML DOM returns the<code>tagName</code>of an HTML element in the canonical uppercase form, regardless of the case in the source HTML document.</p>
			</descr>
		</attribute>
		<method name="getAttribute" id="ID-666EE0F9">
			<descr>
				<p>Retrieves an attribute value by name.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The<code>Attr</code>value as a string, or the empty string if that attribute does not have a specified or default value.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="setAttribute" id="ID-F68F082">
			<descr>
				<p>Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter. This value is a simple string; it is not parsed as it is being set. So any markup (such as syntax to be recognized as an entity reference) is treated as literal text, and needs to be appropriately escaped by the implementation when it is written out. In order to assign an attribute value that contains entity references, the user must create an<code>Attr</code>node plus any<code>Text</code>and<code>EntityReference</code>nodes, build the appropriate subtree, and use<code>setAttributeNode</code>to assign it as the value of an attribute.</p>
				<p>To set an attribute with a qualified name and namespace URI, use the<code>setAttributeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute to create or alter.</p>
					</descr>
				</param>
				<param name="value" type="DOMString" attr="in">
					<descr>
						<p>Value to set in string form.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeAttribute" id="ID-6D6AC0F9">
			<descr>
				<p>Removes an attribute by name. If a default value for the removed attribute is defined in the DTD, a new attribute immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p>
				<p>If no attribute with this name is found, this method has no effect.</p>
				<p>To remove an attribute by local name and namespace URI, use the<code>removeAttributeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute to remove.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getAttributeNode" id="ID-217A91B8">
			<descr>
				<p>Retrieves an attribute node by name.</p>
				<p>To retrieve an attribute node by qualified name and namespace URI, use the<code>getAttributeNodeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name (<code>nodeName</code>) of the attribute to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>The<code>Attr</code>node with the specified name (<code>nodeName</code>) or<code>null</code>if there is no such attribute.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="setAttributeNode" id="ID-887236154">
			<descr>
				<p>Adds a new attribute node. If an attribute with that name (<code>nodeName</code>) is already present in the element, it is replaced by the new one. Replacing an attribute node by itself has no effect.</p>
				<p>To add a new attribute node with a qualified name and namespace URI, use the<code>setAttributeNodeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="newAttr" type="Attr" attr="in">
					<descr>
						<p>The<code>Attr</code>node to add to the attribute list.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>If the<code>newAttr</code>attribute replaces an existing attribute, the replaced<code>Attr</code>node is returned, otherwise<code>null</code>is returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newAttr</code>was created from a different document than the one that created the element.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>INUSE_ATTRIBUTE_ERR: Raised if<code>newAttr</code>is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeAttributeNode" id="ID-D589198">
			<descr>
				<p>Removes the specified attribute node. If a default value for the removed<code>Attr</code>node is defined in the DTD, a new node immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p>
			</descr>
			<parameters>
				<param name="oldAttr" type="Attr" attr="in">
					<descr>
						<p>The<code>Attr</code>node to remove from the attribute list.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>The<code>Attr</code>node that was removed.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if<code>oldAttr</code>is not an attribute of the element.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getElementsByTagName" id="ID-1938918D">
			<descr>
				<p>Returns a<code>NodeList</code>of all<termref def="dt-descendant">descendant</termref>
					<code>Elements</code>with a given tag name, in<termref def="dt-document-order">document order</termref>.</p>
			</descr>
			<parameters>
				<param name="tagname" type="DOMString" attr="in">
					<descr>
						<p>The name of the tag to match on. The special value "*" matches all tags.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NodeList">
				<descr>
					<p>A list of matching<code>Element</code>nodes.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="getAttributeNS" id="ID-ElGetAttrNS" since="DOM Level 2">
			<descr>
				<p>Retrieves an attribute value by local name and namespace URI.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to retrieve.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the attribute to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>The<code>Attr</code>value as a string, or the empty string if that attribute does not have a specified or default value.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setAttributeNS" id="ID-ElSetAttrNS" since="DOM Level 2">
			<descr>
				<p>Adds a new attribute. If an attribute with the same local name and namespace URI is already present on the element, its prefix is changed to be the prefix part of the<code>qualifiedName</code>, and its value is changed to be the<code>value</code>parameter. This value is a simple string; it is not parsed as it is being set. So any markup (such as syntax to be recognized as an entity reference) is treated as literal text, and needs to be appropriately escaped by the implementation when it is written out. In order to assign an attribute value that contains entity references, the user must create an<code>Attr</code>node plus any<code>Text</code>and<code>EntityReference</code>nodes, build the appropriate subtree, and use<code>setAttributeNodeNS</code>or<code>setAttributeNode</code>to assign it as the value of an attribute.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to create or alter.</p>
					</descr>
				</param>
				<param name="qualifiedName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-qualifiedname">qualified name</termref>of the attribute to create or alter.</p>
					</descr>
				</param>
				<param name="value" type="DOMString" attr="in">
					<descr>
						<p>The value to set in string form.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed per the Namespaces in XML specification, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "", if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "", or if the<code>namespaceURI</code>is "" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="removeAttributeNS" id="ID-ElRemAtNS" since="DOM Level 2">
			<descr>
				<p>Removes an attribute by local name and namespace URI. If a default value for the removed attribute is defined in the DTD, a new attribute immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p>
				<p>If no attribute with this local name and namespace URI is found, this method has no effect.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to remove.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the attribute to remove.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getAttributeNodeNS" id="ID-ElGetAtNodeNS" since="DOM Level 2">
			<descr>
				<p>Retrieves an<code>Attr</code>node by local name and namespace URI.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to retrieve.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the attribute to retrieve.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>The<code>Attr</code>node with the specified attribute local name and namespace URI or<code>null</code>if there is no such attribute.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setAttributeNodeNS" id="ID-ElSetAtNodeNS" since="DOM Level 2">
			<descr>
				<p>Adds a new attribute. If an attribute with that local name and that namespace URI is already present in the element, it is replaced by the new one. Replacing an attribute node by itself has no effect.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="newAttr" type="Attr" attr="in">
					<descr>
						<p>The<code>Attr</code>node to add to the attribute list.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Attr">
				<descr>
					<p>If the<code>newAttr</code>attribute replaces an existing attribute with the same<termref def="dt-localname">local name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, the replaced<code>Attr</code>node is returned, otherwise<code>null</code>is returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newAttr</code>was created from a different document than the one that created the element.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>INUSE_ATTRIBUTE_ERR: Raised if<code>newAttr</code>is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getElementsByTagNameNS" id="ID-A6C90942" since="DOM Level 2">
			<descr>
				<p>Returns a<code>NodeList</code>of all the<termref def="dt-descendant">descendant</termref>
					<code>Elements</code>with a given local name and namespace URI in<termref def="dt-document-order">document order</termref>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the elements to match on. The special value "*" matches all namespaces.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the elements to match on. The special value "*" matches all local names.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NodeList">
				<descr>
					<p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="hasAttribute" id="ID-ElHasAttr" since="DOM Level 2">
			<descr>
				<p>Returns<code>true</code>when an attribute with a given name is specified on this element or has a default value,<code>false</code>otherwise.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if an attribute with the given name is specified on this element or has a default value,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="hasAttributeNS" id="ID-ElHasAttrNS" since="DOM Level 2">
			<descr>
				<p>Returns<code>true</code>when an attribute with a given local name and namespace URI is specified on this element or has a default value,<code>false</code>otherwise.</p>
				<p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to look for.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the attribute to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if an attribute with the given local name and namespace URI is specified or has a default value on this element,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p>
					</descr>
				</exception>
			</raises>
		</method>
		<attribute name="schemaTypeInfo" type="TypeInfo" id="Element-schemaTypeInfo" since="DOM Level 3" readonly="yes">
			<descr>
				<p>The type information associated with this element.</p>
			</descr>
		</attribute>
		<method name="setIdAttribute" id="ID-ElSetIdAttr" since="DOM Level 3">
			<descr>
				<p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p>
				<p>To specify an attribute by local name and namespace URI, use the<code>setIdAttributeNS</code>method.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the attribute.</p>
					</descr>
				</param>
				<param name="isId" type="boolean" attr="in">
					<descr>
						<p>Whether the attribute is a of type ID.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setIdAttributeNS" id="ID-ElSetIdAttrNS" since="DOM Level 3">
			<descr>
				<p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute.</p>
					</descr>
				</param>
				<param name="localName" type="DOMString" attr="in">
					<descr>
						<p>The<termref def="dt-localname">local name</termref>of the attribute.</p>
					</descr>
				</param>
				<param name="isId" type="boolean" attr="in">
					<descr>
						<p>Whether the attribute is a of type ID.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setIdAttributeNode" id="ID-ElSetIdAttrNode" since="DOM Level 3">
			<descr>
				<p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p>
			</descr>
			<parameters>
				<param name="idAttr" type="Attr" attr="in">
					<descr>
						<p>The attribute node.</p>
					</descr>
				</param>
				<param name="isId" type="boolean" attr="in">
					<descr>
						<p>Whether the attribute is a of type ID.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
						<p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Text" inherits="CharacterData" id="ID-1312295772">
		<descr>
			<p>The<code>Text</code>interface inherits from<code>CharacterData</code>and represents the textual content (termedin XML) of an<code>Element</code>or<code>Attr</code>. If there is no markup inside an element's content, the text is contained in a single object implementing the<code>Text</code>interface that is the only child of the element. If there is markup, it is parsed into the<termref def="dt-infoitem">information items</termref>(elements, comments, etc.) and<code>Text</code>nodes that form the list of children of the element.</p>
			<p>When a document is first made available via the DOM, there is only one<code>Text</code>node for each block of text. Users may create adjacent<code>Text</code>nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions. The<code>Node.normalize()</code>method merges any such adjacent<code>Text</code>objects into a single node for each block of text.</p>
			<p>No lexical check is done on the content of a<code>Text</code>node and, depending on its position in the document, some characters must be escaped during serialization using character references; e.g. the characters "&lt;&amp;" if the textual content is part of an element or of an attribute, the character sequence "]]&gt;" when part of an element, the quotation mark character " or the apostrophe character ' when part of an attribute.</p>
		</descr>
		<method name="splitText" id="ID-38853C1D">
			<descr>
				<p>Breaks this node into two nodes at the specified<code>offset</code>, keeping both in the tree as<termref def="dt-sibling">siblings</termref>. After being split, this node will contain all the content up to the<code>offset</code>point. A new node of the same type, which contains all the content at and after the<code>offset</code>point, is returned. If the original node had a parent node, the new node is inserted as the next<termref def="dt-sibling">sibling</termref>of the original node. When the<code>offset</code>is equal to the length of this node, the new node has no data.</p>
			</descr>
			<parameters>
				<param name="offset" type="unsigned long" attr="in">
					<descr>
						<p>The<termref def="dt-16-bit-unit">16-bit unit</termref>offset at which to split, starting from<code>0</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Text">
				<descr>
					<p>The new node, of the same type as this node.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in<code>data</code>.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<attribute name="isElementContentWhitespace" id="Text3-isElementContentWhitespace" since="DOM Level 3" readonly="yes" type="boolean">
			<descr>
				<p>Returns whether this text node contains, often abusively called "ignorable whitespace". The text node is determined to contain whitespace in element content during the load of the document or if validation occurs while using<code>Document.normalizeDocument()</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="wholeText" id="Text3-wholeText" since="DOM Level 3">
			<descr>
				<p>Returns all text of<code>Text</code>nodes<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>to this node, concatenated in document order.</p>
				<p>For instance, in the example below<code>wholeText</code>on the<code>Text</code>node that contains "bar" returns "barfoo", while on the<code>Text</code>node that contains "foo" it returns "barfoo".</p>
				<graphic source="./images/wholeTextExmpl.png" alt="barTextNode.wholeText value is &quot;barfoo&quot;" xmlns:ns0="http://www.w3.org/1999/xlink" ns0:type="simple" ns0:show="embed" ns0:actuate="onLoad"/>
			</descr>
		</attribute>
		<method name="replaceWholeText" id="Text3-replaceWholeText" since="DOM Level 3">
			<descr>
				<p>Replaces the text of the current node and all<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>with the specified text. All<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>are removed including the current node unless it was the recipient of the replacement text.</p>
				<p>This method returns the node which received the replacement text. The returned node is:</p>
				<ulist>
					<item>
						<p>
							<code>null</code>, when the replacement text is the empty string;</p>
					</item>
					<item>
						<p>the current node, except when the current node is<termref def="dt-readonly-node">read-only</termref>;</p>
					</item>
					<item>
						<p>a new<code>Text</code>node of the same type (<code>Text</code>or<code>CDATASection</code>) as the current node inserted at the location of the replacement.</p>
					</item>
				</ulist>
				<p>For instance, in the above example calling<code>replaceWholeText</code>on the<code>Text</code>node that contains "bar" with "yo" in argument results in the following:</p>
				<graphic source="./images/wholeTextExmpl2.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) modifies the textual content of barTextNode with &quot;yo&quot;" xmlns:ns0="http://www.w3.org/1999/xlink" ns0:type="simple" ns0:show="embed" ns0:actuate="onLoad"/>
				<p>Where the nodes to be removed are read-only descendants of an<code>EntityReference</code>, the<code>EntityReference</code>must be removed instead of the read-only nodes. If any<code>EntityReference</code>to be removed has descendants that are not<code>EntityReference</code>,<code>Text</code>, or<code>CDATASection</code>nodes, the<code>replaceWholeText</code>method must fail before performing any modification of the document, raising a<code>DOMException</code>with the code<code>NO_MODIFICATION_ALLOWED_ERR</code>.</p>
				<p>For instance, in the example below calling<code>replaceWholeText</code>on the<code>Text</code>node that contains "bar" fails, because the<code>EntityReference</code>node "ent" contains an<code>Element</code>node which cannot be removed.</p>
				<graphic source="./images/wholeTextExmpl3.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) raises a NO_MODIFICATION_ALLOWED_ERR DOMException" xmlns:ns0="http://www.w3.org/1999/xlink" ns0:type="simple" ns0:show="embed" ns0:actuate="onLoad"/>
			</descr>
			<parameters>
				<param name="content" type="DOMString" attr="in">
					<descr>
						<p>The content of the replacing<code>Text</code>node.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Text">
				<descr>
					<p>The<code>Text</code>node created with the specified content.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if one of the<code>Text</code>nodes being replaced is readonly.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Comment" inherits="CharacterData" id="ID-1728279322">
		<descr>
			<p>This interface inherits from<code>CharacterData</code>and represents the content of a comment, i.e., all the characters between the starting '<code>&lt;!--</code>' and ending '<code>--&gt;</code>'. Note that this is the definition of a comment in XML, and, in practice, HTML, although some HTML tools may implement the full SGML comment structure.</p>
			<p>No lexical check is done on the content of a comment and it is therefore possible to have the character sequence<code>"--"</code>(double-hyphen) in the content, which is illegal in a comment per section 2.5 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization.</p>
		</descr>
	</interface>
	<interface name="TypeInfo" id="TypeInfo" since="DOM Level 3">
		<descr>
			<p>The<code>TypeInfo</code>interface represents a type referenced from<code>Element</code>or<code>Attr</code>nodes, specified in the<termref def="dt-schema">schemas</termref>associated with the document. The type is a pair of a<termref def="dt-namespaceURI">namespace URI</termref>and name properties, and depends on the document's schema.</p>
			<p>If the document's schema is an XML DTD<bibref ref="XML"/>, the values are computed as follows:</p>
			<ulist>
				<item>
					<p>If this type is referenced from an<code>Attr</code>node,<code>typeNamespace</code>is<code>"http://www.w3.org/TR/REC-xml"</code>and<code>typeName</code>represents the<b>[attribute type]</b>property in the<bibref ref="InfoSet"/>. If there is no declaration for the attribute,<code>typeNamespace</code>and<code>typeName</code>are<code>null</code>.</p>
				</item>
				<item>
					<p>If this type is referenced from an<code>Element</code>node,<code>typeNamespace</code>and<code>typeName</code>are<code>null</code>.</p>
				</item>
			</ulist>
			<p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</p>
			<ulist>
				<item>
					<p>If the<b>[validity]</b>property exists AND is<emph>"invalid"</emph>or<emph>"notKnown"</emph>: the {target namespace} and {name} properties of the declared type if available, otherwise<code>null</code>.</p>
					<note>
						<p>At the time of writing, the XML Schema specification does not require exposing the declared type. Thus, DOM implementations might choose not to provide type information if validity is not valid.</p>
					</note>
				</item>
				<item>
					<p>If the<b>[validity]</b>property exists and is<emph>"valid"</emph>:</p>
					<olist>
						<item>
							<p>If<b>[member type definition]</b>exists:</p>
							<olist>
								<item>
									<p>If {name} is not absent, then expose {name} and {target namespace} properties of the<b>[member type definition]</b>property;</p>
								</item>
								<item>
									<p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p>
								</item>
							</olist>
						</item>
						<item>
							<p>If the<b>[type definition]</b>property exists:<olist>
									<item>
										<p>If {name} is not absent, then expose {name} and {target namespace} properties of the<b>[type definition]</b>property;</p>
									</item>
									<item>
										<p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p>
									</item>
								</olist>
							</p>
						</item>
						<item>
							<p>If the<b>[member type definition anonymous]</b>exists:<olist>
									<item>
										<p>If it is false, then expose<b>[member type definition name]</b>and<b>[member type definition namespace]</b>properties;</p>
									</item>
									<item>
										<p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p>
									</item>
								</olist>
							</p>
						</item>
						<item>
							<p>If the<b>[type definition anonymous]</b>exists:<olist>
									<item>
										<p>If it is false, then expose<b>[type definition name]</b>and<b>[type definition namespace]</b>properties;</p>
									</item>
									<item>
										<p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p>
									</item>
								</olist>
							</p>
						</item>
					</olist>
				</item>
			</ulist>
			<note>
				<p>Other schema languages are outside the scope of the W3C and therefore should define how to represent their type systems using<code>TypeInfo</code>.</p>
			</note>
		</descr>
		<attribute name="typeName" type="DOMString" id="TypeInfo-typeName" readonly="yes">
			<descr>
				<p>The name of a type declared for the associated element or attribute, or<code>null</code>if unknown.</p>
			</descr>
		</attribute>
		<attribute name="typeNamespace" type="DOMString" id="TypeInfo-typeNamespace" readonly="yes">
			<descr>
				<p>The namespace of the type declared for the associated element or attribute or<code>null</code>if the element does not have declaration or if no namespace information is available.</p>
			</descr>
		</attribute>
		<group name="DerivationMethods" id="TypeInfo-DerivationMethods">
			<descr>
				<p>These are the available values for the<code>derivationMethod</code>parameter used by the method<code>TypeInfo.isDerivedFrom()</code>. It is a set of possible types of derivation, and the values represent bit positions. If a bit in the<code>derivationMethod</code>parameter is set to<code>1</code>, the corresponding type of derivation will be taken into account when evaluating the derivation between the reference type definition and the other type definition. When using the<code>isDerivedFrom</code>method, combining all of them in the<code>derivationMethod</code>parameter is equivalent to invoking the method for each of them separately and combining the results with the OR boolean function. This specification only defines the type of derivation for XML Schema.</p>
				<p>In addition to the types of derivation listed below, please note that:</p>
				<ulist>
					<item>
						<p>any type derives from<code>xsd:anyType</code>.</p>
					</item>
					<item>
						<p>any simple type derives from<code>xsd:anySimpleType</code>by<term>restriction</term>.</p>
					</item>
					<item>
						<p>any complex type does not derive from<code>xsd:anySimpleType</code>by<term>restriction</term>.</p>
					</item>
				</ulist>
			</descr>
			<constant id="TypeInfo-DERIVATION_RESTRICTION" name="DERIVATION_RESTRICTION" type="unsigned long" value="0x00000001">
				<descr>
					<p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the derivation byif complex types are involved, or aif simple types are involved.</p>
					<p>
						<termdef id="id-restriction" term="restriction">The reference type definition is derived by<term>restriction</term>from the other type definition if the other type definition is the same as the reference type definition, or if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and all the<emph>derivation methods</emph>involved are<term>restriction</term>.</termdef>
					</p>
				</descr>
			</constant>
			<constant id="TypeInfo-DERIVATION_EXTENSION" name="DERIVATION_EXTENSION" type="unsigned long" value="0x00000002">
				<descr>
					<p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the derivation by.</p>
					<p>
						<termdef id="id-extension" term="extension">The reference type definition is derived by<term>extension</term>from the other type definition if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and at least one of the<emph>derivation methods</emph>involved is an<term>extension</term>.</termdef>
					</p>
				</descr>
			</constant>
			<constant id="TypeInfo-DERIVATION_UNION" name="DERIVATION_UNION" type="unsigned long" value="0x00000004">
				<descr>
					<p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents theif simple types are involved.</p>
					<p>
						<termdef id="id-union" term="union">The reference type definition is derived by<term>union</term>from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by<code>DERIVATION_RESTRICTION</code>or<code>DERIVATION_EXTENSION</code>, T2 is derived from the other type definition by<code>DERIVATION_RESTRICTION</code>, T1 has {variety}<emph>union</emph>, and one of the {member type definitions} is T2. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</termdef>
					</p>
				</descr>
			</constant>
			<constant id="TypeInfo-DERIVATION_LIST" name="DERIVATION_LIST" type="unsigned long" value="0x00000008">
				<descr>
					<p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the.</p>
					<p>
						<termdef id="id-list" term="list">The reference type definition is derived by<term>list</term>from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by<code>DERIVATION_RESTRICTION</code>or<code>DERIVATION_EXTENSION</code>, T2 is derived from the other type definition by<code>DERIVATION_RESTRICTION</code>, T1 has {variety}<emph>list</emph>, and T2 is the {item type definition}. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</termdef>
					</p>
				</descr>
			</constant>
		</group>
		<method name="isDerivedFrom" id="TypeInfo-isDerivedFrom">
			<descr>
				<p>This method returns if there is a derivation between the reference type definition, i.e. the<code>TypeInfo</code>on which the method is being called, and the other type definition, i.e. the one passed as parameters.</p>
			</descr>
			<parameters>
				<param name="typeNamespaceArg" type="DOMString" attr="in">
					<descr>
						<p>the namespace of the other type definition.</p>
					</descr>
				</param>
				<param name="typeNameArg" type="DOMString" attr="in">
					<descr>
						<p>the name of the other type definition.</p>
					</descr>
				</param>
				<param name="derivationMethod" type="unsigned long" attr="in">
					<descr>
						<p>the type of derivation and conditions applied between two types, as described in the list of constants provided in this interface.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>If the document's schema is a DTD or no schema is associated with the document, this method will always return<code>false</code>.</p>
					<p>If the document's schema is an XML Schema, the method will<code>true</code>if the reference type definition is derived from the other type definition according to the derivation parameter. If the value of the parameter is<code>0</code>(no bit is set to<code>1</code>for the<code>derivationMethod</code>parameter), the method will return<code>true</code>if the other type definition can be reached by recursing any combination of {base type definition}, {item type definition}, or {member type definitions} from the reference type definition.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="UserDataHandler" id="UserDataHandler" since="DOM Level 3" role="ecmascript-function">
		<descr>
			<p>When associating an object to a key on a node using<code>Node.setUserData()</code>the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed. This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes. This interface defines that handler.</p>
		</descr>
		<group id="ID-UserDataOperation" name="OperationType">
			<descr>
				<p>An integer indicating the type of operation being performed on a node.</p>
			</descr>
			<constant id="UserDataHandler-CLONED" name="NODE_CLONED" type="unsigned short" value="1">
				<descr>
					<p>The node is cloned, using<code>Node.cloneNode()</code>.</p>
				</descr>
			</constant>
			<constant id="UserDataHandler-IMPORTED" name="NODE_IMPORTED" type="unsigned short" value="2">
				<descr>
					<p>The node is imported, using<code>Document.importNode()</code>.</p>
				</descr>
			</constant>
			<constant id="UserDataHandler-DELETED" name="NODE_DELETED" type="unsigned short" value="3">
				<descr>
					<p>The node is deleted.</p>
					<note>
						<p>This may not be supported or may not be reliable in certain environments, such as Java, where the implementation has no real control over when objects are actually deleted.</p>
					</note>
				</descr>
			</constant>
			<constant id="UserDataHandler-RENAMED" name="NODE_RENAMED" type="unsigned short" value="4">
				<descr>
					<p>The node is renamed, using<code>Document.renameNode()</code>.</p>
				</descr>
			</constant>
			<constant id="UserDataHandler-ADOPTED" name="NODE_ADOPTED" type="unsigned short" value="5">
				<descr>
					<p>The node is adopted, using<code>Document.adoptNode()</code>.</p>
				</descr>
			</constant>
		</group>
		<method name="handle" id="ID-handleUserDataEvent">
			<descr>
				<p>This method is called whenever the node for which this handler is registered is imported or cloned.</p>
				<p>DOM applications must not raise exceptions in a<code>UserDataHandler</code>. The effect of throwing exceptions from the handler is DOM implementation dependent.</p>
			</descr>
			<parameters>
				<param name="operation" type="unsigned short" attr="in">
					<descr>
						<p>Specifies the type of operation that is being performed on the node.</p>
					</descr>
				</param>
				<param name="key" type="DOMString" attr="in">
					<descr>
						<p>Specifies the key for which this handler is being called.</p>
					</descr>
				</param>
				<param name="data" type="DOMUserData" attr="in">
					<descr>
						<p>Specifies the data for which this handler is being called.</p>
					</descr>
				</param>
				<param name="src" type="Node" attr="in">
					<descr>
						<p>Specifies the node being cloned, adopted, imported, or renamed. This is<code>null</code>when the node is being deleted.</p>
					</descr>
				</param>
				<param name="dst" type="Node" attr="in">
					<descr>
						<p>Specifies the node newly created if any, or<code>null</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DOMError" id="ERROR-Interfaces-DOMError" since="DOM Level 3">
		<descr>
			<p>
				<code>DOMError</code>is an interface that describes an error.</p>
		</descr>
		<group id="DOMError-errorSeverityCodes" name="ErrorSeverity">
			<descr>
				<p>An integer indicating the severity of the error.</p>
			</descr>
			<constant name="SEVERITY_WARNING" id="ERROR-DOMError-severity-warning" type="unsigned short" value="1">
				<descr>
					<p>The severity of the error described by the<code>DOMError</code>is warning. A<code>SEVERITY_WARNING</code>will not cause the processing to stop, unless<code>DOMErrorHandler.handleError()</code>returns<code>false</code>.</p>
				</descr>
			</constant>
			<constant name="SEVERITY_ERROR" id="ERROR-DOMError-severity-error" type="unsigned short" value="2">
				<descr>
					<p>The severity of the error described by the<code>DOMError</code>is error. A<code>SEVERITY_ERROR</code>may not cause the processing to stop if the error can be recovered, unless<code>DOMErrorHandler.handleError()</code>returns<code>false</code>.</p>
				</descr>
			</constant>
			<constant name="SEVERITY_FATAL_ERROR" id="ERROR-DOMError-severity-fatal-error" type="unsigned short" value="3">
				<descr>
					<p>The severity of the error described by the<code>DOMError</code>is fatal error. A<code>SEVERITY_FATAL_ERROR</code>will cause the normal processing to stop. The return value of<code>DOMErrorHandler.handleError()</code>is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</p>
				</descr>
			</constant>
		</group>
		<attribute type="unsigned short" readonly="yes" name="severity" id="ERROR-DOMError-severity">
			<descr>
				<p>The severity of the error, either<code>SEVERITY_WARNING</code>,<code>SEVERITY_ERROR</code>, or<code>SEVERITY_FATAL_ERROR</code>.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="yes" name="message" id="ERROR-DOMError-message">
			<descr>
				<p>An implementation specific string describing the error that occurred.</p>
			</descr>
		</attribute>
		<attribute name="type" type="DOMString" readonly="yes" id="ERROR-DOMError-type">
			<descr>
				<p>A<code>DOMString</code>indicating which related data is expected in<code>relatedData</code>. Users should refer to the specification of the error in order to find its<code>DOMString</code>type and<code>relatedData</code>definitions if any.</p>
				<note>
					<p>As an example,<code>Document.normalizeDocument()</code>does generate warnings when the "<termref def="parameter-split-cdata-sections">split-cdata-sections</termref>" parameter is in use. Therefore, the method generates a<code>SEVERITY_WARNING</code>with<code>type</code>
						<code>"cdata-sections-splitted"</code>and the first<code>CDATASection</code>node in document order resulting from the split is returned by the<code>relatedData</code>attribute.</p>
				</note>
			</descr>
		</attribute>
		<attribute type="DOMObject" readonly="yes" name="relatedException" id="ERROR-DOMError-relatedException">
			<descr>
				<p>The related platform dependent exception if any.</p>
			</descr>
		</attribute>
		<attribute type="DOMObject" readonly="yes" name="relatedData" id="ERROR-DOMError-relatedData">
			<descr>
				<p>The related<code>DOMError.type</code>dependent data if any.</p>
			</descr>
		</attribute>
		<attribute type="DOMLocator" readonly="yes" name="location" id="ERROR-DOMError-location">
			<descr>
				<p>The location of the error.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="DOMErrorHandler" id="ERROR-Interfaces-DOMErrorHandler" since="DOM Level 3" role="ecmascript-function">
		<descr>
			<p>
				<code>DOMErrorHandler</code>is a callback interface that the DOM implementation can call when reporting errors that happens while processing XML data, or when doing some other processing (e.g. validating a document). A<code>DOMErrorHandler</code>object can be attached to a<code>Document</code>using the "<termref def="parameter-error-handler">error-handler</termref>" on the<code>DOMConfiguration</code>interface. If more than one error needs to be reported during an operation, the sequence and numbers of the errors passed to the error handler are implementation dependent.</p>
			<p>The application that is using the DOM implementation is expected to implement this interface.</p>
		</descr>
		<method name="handleError" id="ID-ERRORS-DOMErrorHandler-handleError">
			<descr>
				<p>This method is called on the error handler when an error occurs.</p>
				<p>If an exception is thrown from this method, it is considered to be equivalent of returning<code>true</code>.</p>
			</descr>
			<parameters>
				<param name="error" type="DOMError" attr="in">
					<descr>
						<p>The error object that describes the error. This object may be reused by the DOM implementation across multiple calls to the<code>handleError</code>method.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>If the<code>handleError</code>method returns<code>false</code>, the DOM implementation should stop the current processing when possible. If the method returns<code>true</code>, the processing may continue depending on<code>DOMError.severity</code>.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DOMLocator" id="Interfaces-DOMLocator" since="DOM Level 3">
		<descr>
			<p>
				<code>DOMLocator</code>is an interface that describes a location (e.g. where an error occurred).</p>
		</descr>
		<attribute type="long" readonly="yes" name="lineNumber" id="DOMLocator-line-number">
			<descr>
				<p>The line number this locator is pointing to, or<code>-1</code>if there is no column number available.</p>
			</descr>
		</attribute>
		<attribute type="long" readonly="yes" name="columnNumber" id="DOMLocator-column-number">
			<descr>
				<p>The column number this locator is pointing to, or<code>-1</code>if there is no column number available.</p>
			</descr>
		</attribute>
		<attribute type="long" readonly="yes" name="byteOffset" id="DOMLocator-byteOffset">
			<descr>
				<p>The byte offset into the input source this locator is pointing to or<code>-1</code>if there is no byte offset available.</p>
			</descr>
		</attribute>
		<attribute type="long" readonly="yes" name="utf16Offset" id="DOMLocator-utf16Offset">
			<descr>
				<p>The UTF-16, as defined in<bibref ref="Unicode"/>and Amendment 1 of<bibref ref="ISO10646"/>, offset into the input source this locator is pointing to or<code>-1</code>if there is no UTF-16 offset available.</p>
			</descr>
		</attribute>
		<attribute type="Node" readonly="yes" name="relatedNode" id="DOMLocator-node">
			<descr>
				<p>The node this locator is pointing to, or<code>null</code>if no node is available.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="yes" name="uri" id="DOMLocator-uri">
			<descr>
				<p>The URI this locator is pointing to, or<code>null</code>if no URI is available.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="DOMConfiguration" id="DOMConfiguration" since="DOM Level 3">
		<descr>
			<p>The<code>DOMConfiguration</code>interface represents the configuration of a document and maintains a table of recognized parameters. Using the configuration, it is possible to change<code>Document.normalizeDocument()</code>behavior, such as replacing the<code>CDATASection</code>nodes with<code>Text</code>nodes or specifying the type of the<termref def="dt-schema">schema</termref>that must be used when the validation of the<code>Document</code>is requested.<code>DOMConfiguration</code>objects are also used in<bibref role="informative" ref="DOMLS"/>in the<code>DOMParser</code>and<code>DOMSerializer</code>interfaces.</p>
			<p>The parameter names used by the<code>DOMConfiguration</code>object are defined throughout the DOM Level 3 specifications. Names are case-insensitive. To avoid possible conflicts, as a convention, names referring to parameters defined outside the DOM specification should be made unique. Because parameters are exposed as properties in the<specref ref="ecma-binding"/>, names are recommended to follow the section<quote>5.16 Identifiers</quote>of<bibref role="informative" ref="Unicode"/>with the addition of the character '-' (HYPHEN-MINUS) but it is not enforced by the DOM implementation. DOM Level 3 Core Implementations are required to recognize all parameters defined in this specification. Some parameter values may also be required to be supported by the implementation. Refer to the definition of the parameter to know if a value must be supported or not.</p>
			<note>
				<p>Parameters are similar to features and properties used in SAX2<bibref role="informative" ref="SAX"/>.</p>
			</note>
			<p>The following list of parameters defined in the DOM:</p>
			<glist>
				<gitem>
					<label id="parameter-canonical-form">
						<code>"canonical-form"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Canonicalize the document according to the rules specified in<bibref role="informative" ref="c14n"/>, such as removing the<code>DocumentType</code>node (if any) from the tree, or removing superfluous namespace declarations from each element. Note that this is limited to what can be represented in the DOM; in particular, there is no way to specify the order of the attributes in the DOM. In addition,</p>
									<p>Setting this parameter to<code>true</code>will also set the state of the parameters listed below. Later changes to the state of one of those parameters will revert "<termref def="parameter-canonical-form">canonical-form</termref>" back to<code>false</code>.</p>
									<p>Parameters set to<code>false</code>: "<termref def="parameter-entities">entities</termref>", "<termref def="parameter-normalize-characters">normalize-characters</termref>", "<termref def="parameter-cdata-sections">cdata-sections</termref>".</p>
									<p>Parameters set to<code>true</code>: "<termref def="parameter-namespaces">namespaces</termref>", "<termref def="parameter-namespace-declarations">namespace-declarations</termref>", "<termref def="parameter-well-formed">well-formed</termref>", "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>".</p>
									<p>Other parameters are not changed unless explicitly specified in the description of the parameters.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Do not canonicalize the document.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-cdata-sections">
						<code>"cdata-sections"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Keep<code>CDATASection</code>nodes in the document.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Transform<code>CDATASection</code>nodes in the document into<code>Text</code>nodes. The new<code>Text</code>node is then combined with any adjacent<code>Text</code>node.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-check-character-normalization">
						<code>"check-character-normalization"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Check if the characters in the document are, as defined in appendix B of<bibref ref="XML11"/>. When a sequence of characters is encountered that fails normalization checking, an error with the<code>DOMError.type</code>equals to "check-character-normalization-failure" is issued.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Do not check if characters are normalized.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-comments">
						<code>"comments"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Keep<code>Comment</code>nodes in the document.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Discard<code>Comment</code>nodes in the document.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-datatype-normalization">
						<code>"datatype-normalization"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Expose schema normalized values in the tree, such asin the case of XML Schema. Since this parameter requires to have<termref def="dt-schema">schema</termref>information, the "<termref def="parameter-validate">validate</termref>" parameter will also be set to<code>true</code>. Having this parameter activated when "validate" is<code>false</code>has no effect and no schema-normalization will happen.</p>
									<note>
										<p>Since the document contains the result of the XML 1.0 processing, this parameter does not apply to attribute value normalization as defined in section 3.3.3 of<bibref ref="XML"/>and is only meant for<termref def="dt-schema">schema</termref>languages other than Document Type Definition (DTD).</p>
									</note>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Do not perform schema normalization on the tree.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-element-content-whitespace">
						<code>"element-content-whitespace"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Keep all whitespaces in the document.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Discard all<code>Text</code>nodes that contain whitespaces in element content, as described in. The implementation is expected to use the attribute<code>Text.isElementContentWhitespace</code>to determine if a<code>Text</code>node should be discarded or not.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-entities">
						<code>"entities"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Keep<code>EntityReference</code>nodes in the document.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Remove all<code>EntityReference</code>nodes from the document, putting the entity expansions directly in their place.<code>Text</code>nodes are normalized, as defined in<code>Node.normalize</code>. Onlyare kept in the document.</p>
								</def>
							</gitem>
						</glist>
						<note>
							<p>This parameter does not affect<code>Entity</code>nodes.</p>
						</note>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-error-handler">
						<code>"error-handler"</code>
					</label>
					<def>
						<p>[<emph>required</emph>]</p>
						<p>Contains a<code>DOMErrorHandler</code>object. If an error is encountered in the document, the implementation will call back the<code>DOMErrorHandler</code>registered using this parameter. The implementation may provide a default<code>DOMErrorHandler</code>object.</p>
						<p>When called,<code>DOMError.relatedData</code>will contain the closest node to where the error occurred. If the implementation is unable to determine the node where the error occurs,<code>DOMError.relatedData</code>will contain the<code>Document</code>node. Mutations to the document from within an error handler will result in implementation dependent behavior.</p>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-infoset">
						<code>"infoset"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Keep in the document the information defined in the XML Information Set<bibref ref="InfoSet"/>.</p>
									<p>This forces the following parameters to<code>false</code>: "<termref def="parameter-validate-if-schema">validate-if-schema</termref>", "<termref def="parameter-entities">entities</termref>", "<termref def="parameter-datatype-normalization">datatype-normalization</termref>", "<termref def="parameter-cdata-sections">cdata-sections</termref>".</p>
									<p>This forces the following parameters to<code>true</code>: "<termref def="parameter-namespace-declarations">namespace-declarations</termref>", "<termref def="parameter-well-formed">well-formed</termref>", "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>", "<termref def="parameter-comments">comments</termref>", "<termref def="parameter-namespaces">namespaces</termref>".</p>
									<p>Other parameters are not changed unless explicitly specified in the description of the parameters.</p>
									<p>Note that querying this parameter with<code>getParameter</code>returns<code>true</code>only if the individual parameters specified above are appropriately set.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>Setting<code>infoset</code>to<code>false</code>has no effect.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-namespaces">
						<code>"namespaces"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Perform the namespace processing as defined in<specref ref="normalizeDocumentAlgo"/>.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Do not perform the namespace processing.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-namespace-declarations">
						<code>"namespace-declarations"</code>
					</label>
					<def>
						<p>This parameter has no effect if the parameter "<termref def="parameter-namespaces">namespaces</termref>" is set to<code>false</code>.</p>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Include namespace declaration attributes, specified or defaulted from the<termref def="dt-schema">schema</termref>, in the document. See also the sections "Declaring Namespaces" in<bibref ref="Namespaces"/>and<bibref ref="Namespaces11"/>.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Discard all namespace declaration attributes. The namespace prefixes (<code>Node.prefix</code>) are retained even if this parameter is set to<code>false</code>.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-normalize-characters">
						<code>"normalize-characters"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>the characters in the document as defined in appendix B of<bibref ref="XML11"/>.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Do not perform character normalization.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-schema-location">
						<code>"schema-location"</code>
					</label>
					<def>
						<p>[<emph>optional</emph>]</p>
						<p>Represent a<code>DOMString</code>object containing a list of URIs, separated by whitespaces (characters matching thedefined in section 2.3<bibref ref="XML"/>), that represents the<termref def="dt-schema">schemas</termref>against which validation should occur, i.e. the current schema. The types of schemas referenced in this list must match the type specified with<code>schema-type</code>, otherwise the behavior of an implementation is undefined.</p>
						<p>The schemas specified using this property take precedence to the schema information specified in the document itself. For namespace aware schema, if a schema specified using this property and a schema specified in the document instance (i.e. using the<code>schemaLocation</code>attribute) in a schema document (i.e. using schema<code>import</code>mechanisms) share the same<code>targetNamespace</code>, the schema specified by the user using this property will be used. If two schemas specified using this property share the same<code>targetNamespace</code>or have no namespace, the behavior is implementation dependent.</p>
						<p>If no location has been provided, this parameter is<code>null</code>.</p>
						<note>
							<p>The<code>"schema-location"</code>parameter is ignored unless the "<termref def="parameter-schema-type">schema-type</termref>" parameter value is set. It is strongly recommended that<code>Document.documentURI</code>will be set so that an implementation can successfully resolve any external entities referenced.</p>
						</note>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-schema-type">
						<code>"schema-type"</code>
					</label>
					<def>
						<p>[<emph>optional</emph>]</p>
						<p>Represent a<code>DOMString</code>object containing an absolute URI and representing the type of the<termref def="dt-schema">schema</termref>language used to validate a document against. Note that no lexical checking is done on the absolute URI.</p>
						<p>If this parameter is not set, a default value may be provided by the implementation, based on the schema languages supported and on the schema language used at load time. If no value is provided, this parameter is<code>null</code>.</p>
						<note>
							<p>For XML Schema<bibref ref="XMLSchema1"/>, applications must use the value<code>"http://www.w3.org/2001/XMLSchema"</code>. For XML DTD<bibref ref="XML"/>, applications must use the value<code>"http://www.w3.org/TR/REC-xml"</code>. Other schema languages are outside the scope of the W3C and therefore should recommend an absolute URI in order to use this method.</p>
						</note>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-split-cdata-sections">
						<code>"split-cdata-sections"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Split CDATA sections containing the CDATA section termination marker ']]&gt;'. When a CDATA section is split a warning is issued with a<code>DOMError.type</code>equals to<code>"cdata-sections-splitted"</code>and<code>DOMError.relatedData</code>equals to the first<code>CDATASection</code>node in document order resulting from the split.</p>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>]</p>
									<p>Signal an error if a<code>CDATASection</code>contains an unrepresentable character.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-validate">
						<code>"validate"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Require the validation against a<termref def="dt-schema">schema</termref>(i.e. XML schema, DTD, any other type or representation of schema) of the document as it is being normalized as defined by<bibref ref="XML"/>. If validation errors are found, or no schema was found, the error handler is notified. Schema-normalized values will not be exposed according to the schema in used unless the parameter "<termref def="parameter-datatype-normalization">datatype-normalization</termref>" is<code>true</code>.</p>
									<p>This parameter will reevaluate:</p>
									<ulist>
										<item>
											<p>Attribute nodes with<code>Attr.specified</code>equals to<code>false</code>, as specified in the description of the<code>Attr</code>interface;</p>
										</item>
										<item>
											<p>The value of the attribute<code>Text.isElementContentWhitespace</code>for all<code>Text</code>nodes;</p>
										</item>
										<item>
											<p>The value of the attribute<code>Attr.isId</code>for all<code>Attr</code>nodes;</p>
										</item>
										<item>
											<p>The attributes<code>Element.schemaTypeInfo</code>and<code>Attr.schemaTypeInfo</code>.</p>
										</item>
									</ulist>
									<note>
										<p>"<termref def="parameter-validate-if-schema">validate-if-schema</termref>" and "validate" are mutually exclusive, setting one of them to<code>true</code>will set the other one to<code>false</code>. Applications should also consider setting the parameter "<termref def="parameter-well-formed">well-formed</termref>" to<code>true</code>, which is the default for that option, when validating the document.</p>
									</note>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Do not accomplish schema processing, including the internal subset processing. Default attribute values information are kept. Note that validation might still happen if "<termref def="parameter-validate-if-schema">validate-if-schema</termref>" is<code>true</code>.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-validate-if-schema">
						<code>"validate-if-schema"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Enable validation only if a declaration for the document element can be found in a<termref def="dt-schema">schema</termref>(independently of where it is found, i.e. XML schema, DTD, or any other type or representation of schema). If validation is enabled, this parameter has the same behavior as the parameter "<termref def="parameter-validate">validate</termref>" set to<code>true</code>.</p>
									<note>
										<p>"validate-if-schema" and "<termref def="parameter-validate">validate</termref>" are mutually exclusive, setting one of them to<code>true</code>will set the other one to<code>false</code>.</p>
									</note>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>No schema processing should be performed if the document has a schema, including internal subset processing. Default attribute values information are kept. Note that validation must still happen if "<termref def="parameter-validate">validate</termref>" is<code>true</code>.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
				<gitem>
					<label id="parameter-well-formed">
						<code>"well-formed"</code>
					</label>
					<def>
						<glist>
							<gitem>
								<label>
									<code>true</code>
								</label>
								<def>
									<p>[<emph>required</emph>] (<emph>default</emph>)</p>
									<p>Check if all nodes are XML<termref def="dt-well-formed">well formed</termref>according to the XML version in use in<code>Document.xmlVersion</code>:</p>
									<ulist>
										<item>
											<p>check if the attribute<code>Node.nodeName</code>contains invalid characters according to its node type and generate a<code>DOMError</code>of type<code>"wf-invalid-character-in-node-name"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p>
										</item>
										<item>
											<p>check if the text content inside<code>Attr</code>,<code>Element</code>,<code>Comment</code>,<code>Text</code>,<code>CDATASection</code>nodes for invalid characters and generate a<code>DOMError</code>of type<code>"wf-invalid-character"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p>
										</item>
										<item>
											<p>check if the data inside<code>ProcessingInstruction</code>nodes for invalid characters and generate a<code>DOMError</code>of type<code>"wf-invalid-character"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p>
										</item>
									</ulist>
								</def>
							</gitem>
							<gitem>
								<label>
									<code>false</code>
								</label>
								<def>
									<p>[<emph>optional</emph>]</p>
									<p>Do not check for XML well-formedness.</p>
								</def>
							</gitem>
						</glist>
					</def>
				</gitem>
			</glist>
			<p>The resolution of the system identifiers associated with entities is done using<code>Document.documentURI</code>. However, when the feature "LS" defined in<bibref role="informative" ref="DOMLS"/>is supported by the DOM implementation, the parameter "resource-resolver" can also be used on<code>DOMConfiguration</code>objects attached to<code>Document</code>nodes. If this parameter is set,<code>Document.normalizeDocument()</code>will invoke the resource resolver instead of using<code>Document.documentURI</code>.</p>
		</descr>
		<method name="setParameter" id="DOMConfiguration-property">
			<descr>
				<p>Set the value of a parameter.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the parameter to set.</p>
					</descr>
				</param>
				<param name="value" type="DOMUserData" attr="in">
					<descr>
						<p>The new value or<code>null</code>if the user wishes to unset the parameter. While the type of the value parameter is defined as<code>DOMUserData</code>, the object type must match the type defined by the definition of the parameter. For example, if the parameter is<termref def="parameter-error-handler">"error-handler"</termref>, the value must be of type<code>DOMErrorHandler</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_FOUND_ERR: Raised when the parameter name is not recognized.</p>
						<p>NOT_SUPPORTED_ERR: Raised when the parameter name is recognized but the requested value cannot be set.</p>
						<p>TYPE_MISMATCH_ERR: Raised if the value type for this parameter name is incompatible with the expected value type.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="getParameter" id="DOMConfiguration-getParameter">
			<descr>
				<p>Return the value of a parameter if known.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMUserData">
				<descr>
					<p>The current object associated with the specified parameter or<code>null</code>if no object has been associated or if the parameter is not supported.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_FOUND_ERR: Raised when the parameter name is not recognized.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="canSetParameter" id="DOMConfiguration-canSetParameter">
			<descr>
				<p>Check if setting a parameter to a specific value is supported.</p>
			</descr>
			<parameters>
				<param name="name" type="DOMString" attr="in">
					<descr>
						<p>The name of the parameter to check.</p>
					</descr>
				</param>
				<param name="value" type="DOMUserData" attr="in">
					<descr>
						<p>An object. if<code>null</code>, the returned value is<code>true</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the parameter could be successfully set to the specified value, or<code>false</code>if the parameter is not recognized or the requested value is not supported. This does not change the current value of the parameter itself.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute name="parameterNames" type="DOMStringList" readonly="yes" id="DOMConfiguration-parameterNames">
			<descr>
				<p>The list of the parameters supported by this<code>DOMConfiguration</code>object and for which at least one value can be set by the application. Note that this list can also contain parameter names defined outside this specification.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="CDATASection" inherits="Text" id="ID-667469212">
		<descr>
			<p>CDATA sections are used to escape blocks of text containing characters that would otherwise be regarded as markup. The only delimiter that is recognized in a CDATA section is the "]]&gt;" string that ends the CDATA section. CDATA sections cannot be nested. Their primary purpose is for including material such as XML fragments, without needing to escape all the delimiters.</p>
			<p>The<code>CharacterData.data</code>attribute holds the text that is contained by the CDATA section. Note that this<emph>may</emph>contain characters that need to be escaped outside of CDATA sections and that, depending on the character encoding ("charset") chosen for serialization, it may be impossible to write out some characters as part of a CDATA section.</p>
			<p>The<code>CDATASection</code>interface inherits from the<code>CharacterData</code>interface through the<code>Text</code>interface. Adjacent<code>CDATASection</code>nodes are not merged by use of the<code>normalize</code>method of the<code>Node</code>interface.</p>
			<p>No lexical check is done on the content of a CDATA section and it is therefore possible to have the character sequence<code>"]]&gt;"</code>in the content, which is illegal in a CDATA section per section 2.7 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization or the cdata section must be splitted before the serialization (see also the parameter<code>"split-cdata-sections"</code>in the<code>DOMConfiguration</code>interface).</p>
			<note>
				<p>Because no markup is recognized within a<code>CDATASection</code>, character numeric references cannot be used as an escape mechanism when serializing. Therefore, action needs to be taken when serializing a<code>CDATASection</code>with a character encoding where some of the contained characters cannot be represented. Failure to do so would not produce well-formed XML.</p>
				<p>One potential solution in the serialization process is to end the CDATA section before the character, output the character using a character reference or entity reference, and open a new CDATA section for any further characters in the text node. Note, however, that some code conversion libraries at the time of writing do not return an error or exception when a character is missing from the encoding, making the task of ensuring that data is not corrupted on serialization more difficult.</p>
			</note>
		</descr>
	</interface>
	<interface name="DocumentType" inherits="Node" id="ID-412266927">
		<descr>
			<p>Each<code>Document</code>has a<code>doctype</code>attribute whose value is either<code>null</code>or a<code>DocumentType</code>object. The<code>DocumentType</code>interface in the DOM Core provides an interface to the list of entities that are defined for the document, and little else because the effect of namespaces and the various XML schema efforts on DTD representation are not clearly understood as of this writing.</p>
			<p>DOM Level 3 doesn't support editing<code>DocumentType</code>nodes.<code>DocumentType</code>nodes are<termref def="dt-readonly-node">read-only</termref>.</p>
		</descr>
		<attribute readonly="yes" name="name" type="DOMString" id="ID-1844763134">
			<descr>
				<p>The name of DTD; i.e., the name immediately following the<code>DOCTYPE</code>keyword.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="entities" type="NamedNodeMap" id="ID-1788794630">
			<descr>
				<p>A<code>NamedNodeMap</code>containing the general entities, both external and internal, declared in the DTD. Parameter entities are not contained. Duplicates are discarded. For example in:<eg role="code" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">&lt;!DOCTYPE ex SYSTEM "ex.dtd" [ &lt;!ENTITY foo "foo"&gt; &lt;!ENTITY bar "bar"&gt; &lt;!ENTITY bar "bar2"&gt; &lt;!ENTITY % baz "baz"&gt; ]&gt; &lt;ex/&gt;</eg>the interface provides access to<code>foo</code>and the first declaration of<code>bar</code>but not the second declaration of<code>bar</code>or<code>baz</code>. Every node in this map also implements the<code>Entity</code>interface.</p>
				<p>The DOM Level 2 does not support editing entities, therefore<code>entities</code>cannot be altered in any way.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="notations" type="NamedNodeMap" id="ID-D46829EF">
			<descr>
				<p>A<code>NamedNodeMap</code>containing the notations declared in the DTD. Duplicates are discarded. Every node in this map also implements the<code>Notation</code>interface.</p>
				<p>The DOM Level 2 does not support editing notations, therefore<code>notations</code>cannot be altered in any way.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="publicId" type="DOMString" id="ID-Core-DocType-publicId" since="DOM Level 2">
			<descr>
				<p>The public identifier of the external subset.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="systemId" type="DOMString" id="ID-Core-DocType-systemId" since="DOM Level 2">
			<descr>
				<p>The system identifier of the external subset. This may be an absolute URI or not.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="internalSubset" type="DOMString" id="ID-Core-DocType-internalSubset" since="DOM Level 2">
			<descr>
				<p>The internal subset as a string, or<code>null</code>if there is none. This is does not contain the delimiting square brackets.</p>
				<note>
					<p>The actual content returned depends on how much information is available to the implementation. This may vary depending on various parameters, including the XML processor used to build the document.</p>
				</note>
			</descr>
		</attribute>
	</interface>
	<interface name="Notation" inherits="Node" id="ID-5431D1B9">
		<descr>
			<p>This interface represents a notation declared in the DTD. A notation either declares, by name, the format of an unparsed entity (seeof the XML 1.0 specification<bibref ref="XML"/>), or is used for formal declaration of processing instruction targets (seeof the XML 1.0 specification<bibref ref="XML"/>). The<code>nodeName</code>attribute inherited from<code>Node</code>is set to the declared name of the notation.</p>
			<p>The DOM Core does not support editing<code>Notation</code>nodes; they are therefore<termref def="dt-readonly-node">readonly</termref>.</p>
			<p>A<code>Notation</code>node does not have any parent.</p>
		</descr>
		<attribute readonly="yes" name="publicId" type="DOMString" id="ID-54F2B4D0">
			<descr>
				<p>The public identifier of this notation. If the public identifier was not specified, this is<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="systemId" type="DOMString" id="ID-E8AAB1D0">
			<descr>
				<p>The system identifier of this notation. If the system identifier was not specified, this is<code>null</code>. This may be an absolute URI or not.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="Entity" inherits="Node" id="ID-527DCFF2">
		<descr>
			<p>This interface represents a known entity, either parsed or unparsed, in an XML document. Note that this models the entity itself<emph>not</emph>the entity declaration.</p>
			<p>The<code>nodeName</code>attribute that is inherited from<code>Node</code>contains the name of the entity.</p>
			<p>An XML processor may choose to completely expand entities before the structure model is passed to the DOM; in this case there will be no<code>EntityReference</code>nodes in the document tree.</p>
			<p>XML does not mandate that a non-validating XML processor read and process entity declarations made in the external subset or declared in parameter entities. This means that parsed entities declared in the external subset need not be expanded by some classes of applications, and that the replacement text of the entity may not be available. When theis available, the corresponding<code>Entity</code>node's child list represents the structure of that replacement value. Otherwise, the child list is empty.</p>
			<p>DOM Level 3 does not support editing<code>Entity</code>nodes; if a user wants to make changes to the contents of an<code>Entity</code>, every related<code>EntityReference</code>node has to be replaced in the structure model by a clone of the<code>Entity</code>'s contents, and then the desired changes must be made to each of those clones instead.<code>Entity</code>nodes and all their<termref def="dt-descendant">descendants</termref>are<termref def="dt-readonly-node">readonly</termref>.</p>
			<p>An<code>Entity</code>node does not have any parent.</p>
			<note>
				<p>If the entity contains an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>, the<code>namespaceURI</code>of the corresponding node in the<code>Entity</code>node subtree is<code>null</code>. The same is true for<code>EntityReference</code>nodes that refer to this entity, when they are created using the<code>createEntityReference</code>method of the<code>Document</code>interface.</p>
			</note>
		</descr>
		<attribute readonly="yes" name="publicId" type="DOMString" id="ID-D7303025">
			<descr>
				<p>The public identifier associated with the entity if specified, and<code>null</code>otherwise.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="systemId" type="DOMString" id="ID-D7C29F3E">
			<descr>
				<p>The system identifier associated with the entity if specified, and<code>null</code>otherwise. This may be an absolute URI or not.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" name="notationName" type="DOMString" id="ID-6ABAEB38">
			<descr>
				<p>For unparsed entities, the name of the notation for the entity. For parsed entities, this is<code>null</code>.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="inputEncoding" id="Entity3-inputEncoding" since="DOM Level 3">
			<descr>
				<p>An attribute specifying the encoding used for this entity at the time of parsing, when it is an external parsed entity. This is<code>null</code>if it an entity from the internal subset or if it is not known.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Entity3-encoding" since="DOM Level 3">
			<descr>
				<p>An attribute specifying, as part of the text declaration, the encoding of this entity, when it is an external parsed entity. This is<code>null</code>otherwise.</p>
			</descr>
		</attribute>
		<attribute readonly="yes" type="DOMString" name="xmlVersion" id="Entity3-version" since="DOM Level 3">
			<descr>
				<p>An attribute specifying, as part of the text declaration, the version number of this entity, when it is an external parsed entity. This is<code>null</code>otherwise.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="EntityReference" inherits="Node" id="ID-11C98490">
		<descr>
			<p>
				<code>EntityReference</code>nodes may be used to represent an entity reference in the tree. Note that character references and references to predefined entities are considered to be expanded by the HTML or XML processor so that characters are represented by their Unicode equivalent rather than by an entity reference. Moreover, the XML processor may completely expand references to entities while building the<code>Document</code>, instead of providing<code>EntityReference</code>nodes. If it does provide such nodes, then for an<code>EntityReference</code>node that represents a reference to a known entity an<code>Entity</code>exists, and the subtree of the<code>EntityReference</code>node is a copy of the<code>Entity</code>node subtree. However, the latter may not be true when an entity contains an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>. In such a case, because the namespace prefix resolution depends on where the entity reference is, the<termref def="dt-descendant">descendants</termref>of the<code>EntityReference</code>node may be bound to different<termref def="dt-namespaceURI">namespace URIs</termref>. When an<code>EntityReference</code>node represents a reference to an unknown entity, the node has no children and its replacement value, when used by<code>Attr.value</code>for example, is empty.</p>
			<p>As for<code>Entity</code>nodes,<code>EntityReference</code>nodes and all their<termref def="dt-descendant">descendants</termref>are<termref def="dt-readonly-node">readonly</termref>.</p>
			<note>
				<p>
					<code>EntityReference</code>nodes may cause element content and attribute value normalization problems when, such as in XML 1.0 and XML Schema, the normalization is performed after entity reference are expanded.</p>
			</note>
		</descr>
	</interface>
	<interface name="ProcessingInstruction" inherits="Node" id="ID-1004215813">
		<descr>
			<p>The<code>ProcessingInstruction</code>interface represents a "processing instruction", used in XML as a way to keep processor-specific information in the text of the document.</p>
			<p>No lexical check is done on the content of a processing instruction and it is therefore possible to have the character sequence<code>"?&gt;"</code>in the content, which is illegal a processing instruction per section 2.6 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization.</p>
		</descr>
		<attribute readonly="yes" type="DOMString" name="target" id="ID-1478689192">
			<descr>
				<p>The target of this processing instruction. XML defines this as being the first<termref def="dt-token">token</termref>following the markup that begins the processing instruction.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="data" id="ID-837822393" readonly="no">
			<descr>
				<p>The content of this processing instruction. This is from the first non white space character after the target to the character immediately preceding the<code>?&gt;</code>.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
	</interface>
	<interface id="i18n-methods-StringExtend" name="StringExtend">
		<descr>
			<p>Extensions to a language's native String class or interface</p>
		</descr>
		<method id="i18n-methods-StringExtend-findOffset16" name="findOffset16">
			<descr>
				<p>Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access.</p>
				<note>
					<p>You can always round-trip from a UTF-32 offset to a UTF-16 offset and back. You can round-trip from a UTF-16 offset to a UTF-32 offset and back if and only if the offset16 is not in the middle of a surrogate pair. Unmatched surrogates count as a single UTF-16 value.</p>
				</note>
			</descr>
			<parameters>
				<param name="offset32" type="int" attr="in">
					<descr>
						<p>UTF-32 offset.</p>
					</descr>
				</param>
			</parameters>
			<returns type="int">
				<descr>
					<p>UTF-16 offset</p>
				</descr>
			</returns>
			<raises>
				<exception name="StringIndexOutOfBoundsException">
					<descr>
						<p>if<code>offset32</code>is out of bounds.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method id="i18n-methods-StringExtend-findOffset32" name="findOffset32">
			<descr>
				<p>Returns the UTF-32 offset corresponding to a UTF-16 offset. Used for random access. To find the UTF-32 length of a string, use:<eg xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">len32 = findOffset32(source, source.length());</eg>
				</p>
				<note>
					<p>If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset of the<emph>end</emph>of the pair is returned; that is, the index of the char after the end of the pair. You can always round-trip from a UTF-32 offset to a UTF-16 offset and back. You can round-trip from a UTF-16 offset to a UTF-32 offset and back if and only if the offset16 is not in the middle of a surrogate pair. Unmatched surrogates count as a single UTF-16 value.</p>
				</note>
			</descr>
			<parameters>
				<param attr="in" type="int" name="offset16">
					<descr>
						<p>UTF-16 offset</p>
					</descr>
				</param>
			</parameters>
			<returns type="int">
				<descr>
					<p>UTF-32 offset</p>
				</descr>
			</returns>
			<raises>
				<exception name="StringIndexOutOfBoundsException">
					<descr>
						<p>if offset16 is out of bounds.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Event" id="Events-Event" since="DOM Level 2">
		<descr>
			<p>The<code>Event</code>interface is used to provide contextual information about an event to the listener processing the event. An object which implements the<code>Event</code>interface is passed as the parameter to an<code>EventListener</code>. More specific context information is passed to event listeners by deriving additional interfaces from<code>Event</code>which contain information directly relating to the type of event they represent. These derived interfaces are also implemented by the object passed to the event listener.</p>
			<p>To create an instance of the<code>Event</code>interface, use the<code>DocumentEvent.createEvent("Event")</code>method call.</p>
		</descr>
		<group id="Events-Event-eventPhaseType" name="PhaseType">
			<descr>
				<p>An integer indicating which phase of the event flow is being processed as defined in<specref ref="Events-flow"/>.</p>
			</descr>
			<constant name="CAPTURING_PHASE" id="CAPTURING_PHASE" type="unsigned short" value="1">
				<descr>
					<p>The current event phase is the<termref def="dt-capture-phase">capture phase</termref>.</p>
				</descr>
			</constant>
			<constant name="AT_TARGET" id="AT_TARGET" type="unsigned short" value="2">
				<descr>
					<p>The current event is in the<termref def="dt-capture-phase">target phase</termref>, i.e. it is being evaluated at the<termref def="dt-event-target">event target</termref>.</p>
				</descr>
			</constant>
			<constant name="BUBBLING_PHASE" id="BUBBLING_PHASE" type="unsigned short" value="3">
				<descr>
					<p>The current event phase is the<termref def="dt-bubbling-phase">bubbling phase</termref>.</p>
				</descr>
			</constant>
		</group>
		<attribute type="DOMString" name="type" readonly="yes" id="Events-Event-type">
			<descr>
				<p>The name should be anas defined in<bibref ref="Namespaces"/>and is case-sensitive.</p>
				<p>If the attribute<code>Event.namespaceURI</code>is different from<code>null</code>, this attribute represents a<termref def="dt-localname">local name</termref>.</p>
			</descr>
		</attribute>
		<attribute type="EventTarget" name="target" readonly="yes" id="Events-Event-target">
			<descr>
				<p>Used to indicate the<termref def="dt-event-target">event target</termref>. This attribute contains the<termref def="dt-target-node">target node</termref>when used with the<specref ref="Events-flow"/>.</p>
			</descr>
		</attribute>
		<attribute type="EventTarget" name="currentTarget" readonly="yes" id="Events-Event-currentTarget">
			<descr>
				<p>Used to indicate the<code>EventTarget</code>whose<code>EventListeners</code>are currently being processed. This is particularly useful during the capture and bubbling phases. This attribute could contain the<termref def="dt-target-node">target node</termref>or a target ancestor when used with the<specref ref="Events-flow"/>.</p>
			</descr>
		</attribute>
		<attribute type="unsigned short" name="eventPhase" readonly="yes" id="Events-Event-eventPhase">
			<descr>
				<p>Used to indicate which phase of event flow is currently being accomplished.</p>
			</descr>
		</attribute>
		<attribute type="boolean" name="bubbles" readonly="yes" id="Events-Event-canBubble">
			<descr>
				<p>Used to indicate whether or not an event is a bubbling event. If the event can bubble the value is<code>true</code>, otherwise the value is<code>false</code>.</p>
			</descr>
		</attribute>
		<attribute type="boolean" name="cancelable" readonly="yes" id="Events-Event-canCancel">
			<descr>
				<p>Used to indicate whether or not an event can have its default action prevented (see also<specref ref="Events-flow-cancelation"/>). If the default action can be prevented the value is<code>true</code>, otherwise the value is<code>false</code>.</p>
			</descr>
		</attribute>
		<attribute type="DOMTimeStamp" name="timeStamp" readonly="yes" id="Events-Event-timeStamp">
			<descr>
				<p>Used to specify the time (in milliseconds relative to the epoch) at which the event was created. Due to the fact that some systems may not provide this information the value of<code>timeStamp</code>may be not available for all events. When not available, a value of<code>0</code>will be returned. Examples of epoch time are the time of the system start or 0:0:0 UTC 1st January 1970.</p>
			</descr>
		</attribute>
		<method name="stopPropagation" id="Events-Event-stopPropagation">
			<descr>
				<p>This method is used to prevent event listeners of the same group to be triggered but its effect is deferred until all event listeners attached on the<code>currentTarget</code>have been triggered (see<specref ref="Events-propagation-and-groups"/>). Once it has been called, further calls to that method have no additional effect.</p>
				<note>
					<p>This method does not prevent the default action from being invoked; use<code>preventDefault</code>for that effect.</p>
				</note>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="preventDefault" id="Events-Event-preventDefault">
			<descr>
				<p>If an event is cancelable, the<code>preventDefault</code>method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur (see also<specref ref="Events-flow-cancelation"/>), and thus independently of event groups. Calling this method for a non-cancelable event has no effect.</p>
				<note>
					<p>This method does not stop the event propagation; use<code>stopPropagation</code>or<code>stopImmediatePropagation</code>for that effect.</p>
				</note>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initEvent" id="Events-Event-initEvent">
			<descr>
				<p>The<code>initEvent</code>method is used to initialize the value of an<code>Event</code>created through the<code>DocumentEvent.createEvent</code>method. This method may only be called before the<code>Event</code>has been dispatched via the<code>EventTarget.dispatchEvent()</code>method. If the method is called several times before invoking<code>EventTarget.dispatchEvent</code>, only the final invocation takes precedence. This method has no effect if called after the event has been dispatched. If called from a subclass of the<code>Event</code>interface only the values specified in this method are modified, all other attributes are left unchanged.</p>
				<p>This method sets the<code>Event.type</code>attribute to<code>eventTypeArg</code>, and<code>Event.namespaceURI</code>to<code>null</code>. To initialize an event with a namespace URI, use the<code>Event.initEventNS(namespaceURIArg, eventTypeArg, ...)</code>method.</p>
			</descr>
			<parameters>
				<param name="eventTypeArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>Event.type</code>.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>Event.bubbles</code>. This parameter overrides the intrinsic bubbling behavior of the event.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>Event.cancelable</code>. This parameter overrides the intrinsic cancelable behavior of the event.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute readonly="yes" type="DOMString" name="namespaceURI" id="Events-Event-namespaceURI" since="DOM Level 3">
			<descr>
				<p>The<termref def="dt-namespaceURI">namespace URI</termref>associated with this event at creation time, or<code>null</code>if it is unspecified.</p>
				<p>For events initialized with a DOM Level 2 Events method, such as<code>Event.initEvent()</code>, this is always<code>null</code>.</p>
			</descr>
		</attribute>
		<method name="isCustom" id="Events-Event-isCustom" since="DOM Level 3">
			<descr>
				<p>This method will always return<code>false</code>, unless the event implements the<code>CustomEvent</code>interface.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>
						<code>false</code>, unless the event object implements the<code>CustomEvent</code>interface.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="stopImmediatePropagation" id="Events-Event-stopImmediatePropagation" since="DOM Level 3">
			<descr>
				<p>This method is used to prevent event listeners of the same group to be triggered and, unlike<code>stopPropagation</code>its effect is immediate (see<specref ref="Events-propagation-and-groups"/>). Once it has been called, further calls to that method have no additional effect.</p>
				<note>
					<p>This method does not prevent the default action from being invoked; use<code>Event.preventDefault()</code>for that effect.</p>
				</note>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isDefaultPrevented" id="Events-Event-isDefaultPrevented" since="DOM Level 3">
			<descr>
				<p>This method will return<code>true</code>if the method<code>Event.preventDefault()</code>has been called for this event,<code>false</code>otherwise.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if<code>Event.preventDefault()</code>has been called for this event.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initEventNS" id="Events-Event-initEventNS" since="DOM Level 3">
			<descr>
				<p>The<code>initEventNS</code>method is used to initialize the value of an<code>Event</code>object and has the same behavior as<code>Event.initEvent()</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURIArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>Event.namespaceuRI</code>, the<termref def="dt-namespaceURI">namespace URI</termref>associated with this event, or<code>null</code>if no namespace.</p>
					</descr>
				</param>
				<param name="eventTypeArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>Event.type</code>, the<termref def="dt-localname">local name</termref>of the event type.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="EventTarget" id="Events-EventTarget" since="DOM Level 2">
		<descr>
			<p>The<code>EventTarget</code>interface is implemented by all the objects which could be<termref def="dt-event-target">event targets</termref>in an implementation which supports the<specref ref="Events-flows"/>. The interface allows registration, removal or query of event listeners, and dispatch of events to an event target.</p>
			<p>When used with<specref ref="Events-flow"/>, this interface is implemented by all<termref def="dt-target-node">target nodes</termref>and target ancestors, i.e. all DOM<code>Nodes</code>of the tree support this interface when the implementation conforms to DOM Level 3 Events and, therefore, this interface can be obtained by using binding-specific casting methods on an instance of the<code>Node</code>interface.</p>
			<p>Invoking<code>addEventListener</code>or<code>addEventListenerNS</code>multiple times on the same<code>EventTarget</code>with the same parameters (<code>namespaceURI</code>,<code>type</code>,<code>listener</code>, and<code>useCapture</code>) is considered to be a no-op and thus independently of the event group. They do not cause the<code>EventListener</code>to be called more than once and do not cause a change in the triggering order. In order to guarantee that an event listener will be added to the event target for the specified event group, one needs to invoke<code>removeEventListener</code>or<code>removeEventListenerNS</code>first.</p>
		</descr>
		<method name="addEventListener" id="Events-EventTarget-addEventListener">
			<descr>
				<p>This method allows the registration of an event listener in the default group and, depending on the<code>useCapture</code>parameter, on the capture phase of the DOM event flow or its target and bubbling phases.</p>
			</descr>
			<parameters>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>associated with the event for which the user is registering.</p>
					</descr>
				</param>
				<param name="listener" type="EventListener" attr="in">
					<descr>
						<p>The<code>listener</code>parameter takes an object implemented by the user which implements the<code>EventListener</code>interface and contains the method to be called when the event occurs.</p>
					</descr>
				</param>
				<param name="useCapture" type="boolean" attr="in">
					<descr>
						<p>If true,<code>useCapture</code>indicates that the user wishes to add the event listener for the<termref def="dt-capture-phase">capture phase</termref>only, i.e. this event listener will not be triggered during the<termref def="dt-target-phase">target</termref>and<termref def="dt-bubbling-phase">bubbling</termref>phases. If<code>false</code>, the event listener will only be triggered during the target and bubbling phases.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="removeEventListener" id="Events-EventTarget-removeEventListener">
			<descr>
				<p>This method allows the removal of event listeners from the default group.</p>
				<p>Calling<code>removeEventListener</code>with arguments which do not identify any currently registered<code>EventListener</code>on the<code>EventTarget</code>has no effect.</p>
			</descr>
			<parameters>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>for which the user registered the event listener.</p>
					</descr>
				</param>
				<param name="listener" type="EventListener" attr="in">
					<descr>
						<p>The<code>EventListener</code>to be removed.</p>
					</descr>
				</param>
				<param name="useCapture" type="boolean" attr="in">
					<descr>
						<p>Specifies whether the<code>EventListener</code>being removed was registered for the capture phase or not. If a listener was registered twice, once for the capture phase and once for the target and bubbling phases, each must be removed separately. Removal of an event listener registered for the capture phase does not affect the same event listener registered for the target and bubbling phases, and vice versa.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="dispatchEvent" id="Events-EventTarget-dispatchEvent" version="DOM Level 3">
			<descr>
				<p>This method allows the dispatch of events into the implementation's event model. The<termref def="dt-event-target">event target</termref>of the event is the<code>EventTarget</code>object on which<code>dispatchEvent</code>is called.</p>
			</descr>
			<parameters>
				<param name="evt" type="Event" attr="in">
					<descr>
						<p>The event to be dispatched.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Indicates whether any of the listeners which handled the event called<code>Event.preventDefault()</code>. If<code>Event.preventDefault()</code>was called the returned value is<code>false</code>, else it is<code>true</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="EventException">
					<descr>
						<p>UNSPECIFIED_EVENT_TYPE_ERR: Raised if the<code>Event.type</code>was not specified by initializing the event before<code>dispatchEvent</code>was called. Specification of the<code>Event.type</code>as<code>null</code>or an empty string will also trigger this exception.</p>
						<p>DISPATCH_REQUEST_ERR: Raised if the<code>Event</code>object is already being dispatched in the tree.</p>
						<p>NOT_SUPPORTED_ERR: Raised if the<code>Event</code>object has not been created using<code>DocumentEvent.createEvent()</code>or does not support the interface<code>CustomEvent</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="addEventListenerNS" id="Events-EventTargetGroup-addEventListenerNS" since="DOM Level 3">
			<descr>
				<p>This method allows the registration of an event listener in a specified group or the default group and, depending on the<code>useCapture</code>parameter, on the capture phase of the DOM event flow or its target and bubbling phases.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.namespaceURI</code>associated with the event for which the user is registering.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>associated with the event for which the user is registering.</p>
					</descr>
				</param>
				<param name="listener" type="EventListener" attr="in">
					<descr>
						<p>The<code>listener</code>parameter takes an object implemented by the user which implements the<code>EventListener</code>interface and contains the method to be called when the event occurs.</p>
					</descr>
				</param>
				<param name="useCapture" type="boolean" attr="in">
					<descr>
						<p>If true,<code>useCapture</code>indicates that the user wishes to add the event listener for the<termref def="dt-capture-phase">capture phase</termref>only, i.e. this event listener will not be triggered during the<termref def="dt-target-phase">target</termref>and<termref def="dt-bubbling-phase">bubbling</termref>phases. If<code>false</code>, the event listener will only be triggered during the target and bubbling phases.</p>
					</descr>
				</param>
				<param name="evtGroup" type="DOMObject" attr="in">
					<descr>
						<p>The object that represents the event group to associate with the<code>EventListener</code>(see also<specref ref="Events-propagation-and-groups"/>). Use<code>null</code>to attach the event listener to the default group.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
		<method name="removeEventListenerNS" id="Events-EventTargetGroup-removeEventListenerNS" since="DOM Level 3">
			<descr>
				<p>This method allows the removal of an event listener, independently of the associated event group.</p>
				<p>Calling<code>removeEventListenerNS</code>with arguments which do not identify any currently registered<code>EventListener</code>on the<code>EventTarget</code>has no effect.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.namespaceURI</code>associated with the event for which the user registered the event listener.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>associated with the event for which the user registered the event listener.</p>
					</descr>
				</param>
				<param name="listener" type="EventListener" attr="in">
					<descr>
						<p>The<code>EventListener</code>parameter indicates the<code>EventListener</code>to be removed.</p>
					</descr>
				</param>
				<param name="useCapture" type="boolean" attr="in">
					<descr>
						<p>Specifies whether the<code>EventListener</code>being removed was registered for the capture phase or not. If a listener was registered twice, once for the capture phase and once for the target and bubbling phases, each must be removed separately. Removal of an event listener registered for the capture phase does not affect the same event listener registered for the target and bubbling phases, and vice versa.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="willTriggerNS" since="DOM Level 3" id="Events3-willTriggerNS">
			<descr>
				<p>This method allows the DOM application to know if an event listener, attached to this<code>EventTarget</code>or one of its ancestors, will be triggered by the specified event type during the dispatch of the event to this event target or one of its descendants.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.namespaceURI</code>associated with the event.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>associated with the event.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if an event listener will be triggered on the<code>EventTarget</code>with the specified event type,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="hasEventListenerNS" since="DOM Level 3" id="Events3-hasEventListenerNS">
			<descr>
				<p>This method allows the DOM application to know if this<code>EventTarget</code>contains an event listener registered for the specified event type. This is useful for determining at which nodes within a hierarchy altered handling of specific event types has been introduced, but should not be used to determine whether the specified event type triggers an event listener (see<code>EventTarget.willTriggerNS()</code>).</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.namespaceURI</code>associated with the event.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>associated with the event.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if an event listener is registered on this<code>EventTarget</code>for the specified event type,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface id="Events-EventListener" name="EventListener" since="DOM Level 2" role="ecmascript-function">
		<descr>
			<p>The<code>EventListener</code>interface is the primary way for handling events. Users implement the<code>EventListener</code>interface and register their event listener on an<code>EventTarget</code>. The users should also remove their<code>EventListener</code>from its<code>EventTarget</code>after they have completed using the listener.</p>
			<p>Copying a<code>Node</code>, with methods such as<code>Node.cloneNode</code>or<code>Range.cloneContents</code>, does not copy the event listeners attached to it. Event listeners must be attached to the newly created<code>Node</code>afterwards if so desired.</p>
			<p>Moving a<code>Node</code>, with methods<code>Document.adoptNode</code>,<code>Node.appendChild</code>, or<code>Range.extractContents</code>, does not affect the event listeners attached to it.</p>
		</descr>
		<method name="handleEvent" id="Events-EventListener-handleEvent">
			<descr>
				<p>This method is called whenever an event occurs of the event type for which the<code>EventListener</code>interface was registered.</p>
			</descr>
			<parameters>
				<param name="evt" type="Event" attr="in">
					<descr>
						<p>The<code>Event</code>contains contextual information about the<termref def="dt-event">event</termref>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<exception id="Events-EventException" name="EventException" since="DOM Level 2">
		<descr>
			<p>Event operations may throw an<code>EventException</code>as specified in their method descriptions.</p>
		</descr>
		<component id="Events-EventException-code" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="Events-EventException-EventExceptionCode" name="EventExceptionCode" since="DOM Level 2">
		<descr>
			<p>An integer indicating the type of error generated.</p>
		</descr>
		<constant name="UNSPECIFIED_EVENT_TYPE_ERR" id="UNSPECIFIED_EVENT_TYPE_ERR" type="unsigned short" value="0">
			<descr>
				<p>If the<code>Event.type</code>was not specified by initializing the event before the method was called. Specification of the<code>Event.type</code>as<code>null</code>or an empty string will also trigger this exception.</p>
			</descr>
		</constant>
		<constant name="DISPATCH_REQUEST_ERR" id="DISPATCH_REQUEST_ERR" type="unsigned short" value="1" since="DOM Level 3">
			<descr>
				<p>If the<code>Event</code>object is already dispatched in the tree.</p>
			</descr>
		</constant>
	</group>
	<interface name="DocumentEvent" id="Events-DocumentEvent" since="DOM Level 2">
		<descr>
			<p>The<code>DocumentEvent</code>interface provides a mechanism by which the user can create an<code>Event</code>object of a type supported by the implementation. If the feature "Events" is supported by the<code>Document</code>object, the<code>DocumentEvent</code>interface must be implemented on the same object. If the feature "+Events" is supported by the<code>Document</code>object, an object that supports the<code>DocumentEvent</code>interface must be returned by invoking the method<code>Node.getFeature("+Events", "3.0")</code>on the<code>Document</code>object.</p>
		</descr>
		<method name="createEvent" id="Events-DocumentEvent-createEvent">
			<descr>
				<p/>
			</descr>
			<parameters>
				<param name="eventType" type="DOMString" attr="in">
					<descr>
						<p>The<code>eventType</code>parameter specifies the name of the DOM Events interface to be supported by the created event object, e.g.<code>"Event"</code>,<code>"MouseEvent"</code>,<code>"MutationEvent"</code>and so on. If the<code>Event</code>is to be dispatched via the<code>EventTarget.dispatchEvent()</code>method the appropriate event init method must be called after creation in order to initialize the<code>Event</code>'s values.</p>
						<p>As an example, a user wishing to synthesize some kind of<code>UIEvent</code>would invoke<code>DocumentEvent.createEvent("UIEvent")</code>. The<code>UIEvent.initUIEventNS()</code>method could then be called on the newly created<code>UIEvent</code>object to set the specific type of user interface event to be dispatched,<code>{"http://www.w3.org/2001/xml-events", "DOMActivate"}</code>for example, and set its context information, e.g.<code>UIEvent.detail</code>in this example.</p>
						<p>The<code>createEvent</code>method is used in creating<code>Event</code>s when it is either inconvenient or unnecessary for the user to create an<code>Event</code>themselves. In cases where the implementation provided<code>Event</code>is insufficient, users may supply their own<code>Event</code>implementations for use with the<code>EventTarget.dispatchEvent()</code>method. However, the DOM implementation needs access to the attributes<code>Event.currentTarget</code>and<code>Event.eventPhase</code>to appropriately propagate the event in the DOM tree. Therefore users'<code>Event</code>implementations might need to support the<code>CustomEvent</code>interface for that effect.</p>
						<note>
							<p>For backward compatibility reason, "UIEvents", "MouseEvents", "MutationEvents", and "HTMLEvents" feature names are valid values for the parameter<code>eventType</code>and represent respectively the interfaces "UIEvent", "MouseEvent", "MutationEvent", and "Event".</p>
						</note>
					</descr>
				</param>
			</parameters>
			<returns type="Event">
				<descr>
					<p>The newly created event object.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the implementation does not support the<code>Event</code>interface requested.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="canDispatch" id="Events-DocumentEvent-canDispatch" since="DOM Level 3">
			<descr>
				<p>Test if the implementation can generate events of a specified type.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.namespaceURI</code>of the event.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Specifies the<code>Event.type</code>of the event.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the implementation can generate and dispatch this event type,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="CustomEvent" inherits="Event" id="Events-CustomEvent" since="DOM Level 3">
		<descr>
			<p>The<code>CustomEvent</code>interface gives access to the attributes<code>Event.currentTarget</code>and<code>Event.eventPhase</code>. It is intended to be used by the DOM Events implementation to access the underlying current target and event phase while dispatching a custom<code>Event</code>in the tree; it is also intended to be implemented, and<emph>not used</emph>, by DOM applications.</p>
			<p>The methods contained in this interface are not intended to be used by a DOM application, especially during the dispatch on the<code>Event</code>object. Changing the current target or the current phase may result in unpredictable results of the event flow. The DOM Events implementation should ensure that both methods return the appropriate current target and phase before invoking each event listener on the current target to protect DOM applications from malicious event listeners.</p>
			<note>
				<p>If this interface is supported by the event object,<code>Event.isCustom()</code>must return<code>true</code>.</p>
			</note>
		</descr>
		<method name="setDispatchState" id="Events-CustomEvent-setCurrentTarget">
			<descr>
				<p>The<code>setDispatchState</code>method is used by the DOM Events implementation to set the values of<code>Event.currentTarget</code>and<code>Event.eventPhase</code>. It also reset the states of<code>isPropagationStopped</code>and<code>isImmediatePropagationStopped</code>.</p>
			</descr>
			<parameters>
				<param name="target" type="EventTarget" attr="in">
					<descr>
						<p>Specifies the new value for the<code>Event.currentTarget</code>attribute.</p>
					</descr>
				</param>
				<param name="phase" type="unsigned short" attr="in">
					<descr>
						<p>Specifies the new value for the<code>Event.eventPhase</code>attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
		<method name="isPropagationStopped" id="Events-Event-isPropagationStopped">
			<descr>
				<p>This method will return<code>true</code>if the method<code>stopPropagation()</code>has been called for this event,<code>false</code>in any other cases.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the event propagation has been stopped in the current group.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isImmediatePropagationStopped" id="Events-Event-isImmediatePropagationStopped">
			<descr>
				<p>The<code>isImmediatePropagationStopped</code>method is used by the DOM Events implementation to know if the method<code>stopImmediatePropagation()</code>has been called for this event. It returns<code>true</code>if the method has been called,<code>false</code>otherwise.</p>
			</descr>
			<parameters/>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if the event propagation has been stopped immediately in the current group.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="UIEvent" inherits="Event" id="Events-UIEvent" since="DOM Level 2">
		<descr>
			<p>The<code>UIEvent</code>interface provides specific contextual information associated with User Interface events.</p>
			<p>To create an instance of the<code>UIEvent</code>interface, use the<code>DocumentEvent.createEvent("UIEvent")</code>method call.</p>
		</descr>
		<attribute type="views::AbstractView" name="view" readonly="yes" id="Events-UIEvent-view">
			<descr>
				<p>The<code>view</code>attribute identifies the<code>AbstractView</code>from which the event was generated.</p>
			</descr>
		</attribute>
		<attribute id="Events-UIEvent-detail" name="detail" type="long" readonly="yes">
			<descr>
				<p>Specifies some detail information about the<code>Event</code>, depending on the type of event.</p>
			</descr>
		</attribute>
		<method name="initUIEvent" id="Events-Event-initUIEvent">
			<descr>
				<p>The<code>initUIEvent</code>method is used to initialize the value of a<code>UIEvent</code>object and has the same behavior as<code>Event.initEvent()</code>.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Specifies<code>UIEvent.view</code>.</p>
					</descr>
				</param>
				<param name="detailArg" type="long" attr="in">
					<descr>
						<p>Specifies<code>UIEvent.detail</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initUIEventNS" id="Events-Event-initUIEventNS" since="DOM Level 3">
			<descr>
				<p>The<code>initUIEventNS</code>method is used to initialize the value of a<code>UIEvent</code>object and has the same behavior as<code>Event.initEventNS()</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="detailArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="TextEvent" inherits="UIEvent" id="Events-TextEvent" since="DOM Level 3">
		<descr>
			<p>The<code>TextEvent</code>interface provides specific contextual information associated with Text Events.</p>
			<p>To create an instance of the<code>TextEvent</code>interface, use the<code>DocumentEvent.createEvent("TextEvent")</code>method call.</p>
		</descr>
		<attribute type="DOMString" name="data" id="Events-UIEvent-data" readonly="yes">
			<descr>
				<p>
					<code>data</code>holds the value of the characters generated by the character device. This may be a single Unicode character or a non-empty sequence of Unicode characters<bibref ref="Unicode"/>. Characters should be normalized as defined by the Unicode normalization form<term>NFC</term>, defined in<bibref ref="UnicodeNormalization"/>. This attribute cannot be null or contain the empty string.</p>
			</descr>
		</attribute>
		<method name="initTextEvent" id="Events-Event-initTextEvent">
			<descr>
				<p>The<code>initTextEvent</code>method is used to initialize the value of a<code>TextEvent</code>object and has the same behavior as<code>UIEvent.initUIEvent()</code>. The value of<code>UIEvent.detail</code>remains undefined.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="dataArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>TextEvent.data</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
		<method name="initTextEventNS" id="Events-Event-initTextEventNS">
			<descr>
				<p>The<code>initTextEventNS</code>method is used to initialize the value of a<code>TextEvent</code>object and has the same behavior as<code>UIEvent.initUIEventNS()</code>. The value of<code>UIEvent.detail</code>remains undefined.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="dataArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>TextEvent.initTextEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="MouseEvent" inherits="UIEvent" id="Events-MouseEvent" since="DOM Level 2">
		<descr>
			<p>The<code>MouseEvent</code>interface provides specific contextual information associated with Mouse events.</p>
			<p>In the case of nested elements mouse events are always targeted at the most deeply nested element. Ancestors of the targeted element may use bubbling to obtain notification of mouse events which occur within theirs descendent elements.</p>
			<p>To create an instance of the<code>MouseEvent</code>interface, use the<code>DocumentEvent.createEvent("MouseEvent")</code>method call.</p>
			<note>
				<p>When initializing<code>MouseEvent</code>objects using<code>initMouseEvent</code>or<code>initMouseEventNS</code>, implementations should use the client coordinates<code>clientX</code>and<code>clientY</code>for calculation of other coordinates (such as target coordinates exposed by<termref def="dt-DOM-Level-0">DOM Level 0</termref>implementations).</p>
			</note>
		</descr>
		<attribute type="long" name="screenX" readonly="yes" id="Events-MouseEvent-screenX">
			<descr>
				<p>The horizontal coordinate at which the event occurred relative to the origin of the screen coordinate system.</p>
			</descr>
		</attribute>
		<attribute type="long" name="screenY" readonly="yes" id="Events-MouseEvent-screenY">
			<descr>
				<p>The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.</p>
			</descr>
		</attribute>
		<attribute type="long" name="clientX" readonly="yes" id="Events-MouseEvent-clientX">
			<descr>
				<p>The horizontal coordinate at which the event occurred relative to the DOM implementation's client area.</p>
			</descr>
		</attribute>
		<attribute type="long" name="clientY" readonly="yes" id="Events-MouseEvent-clientY">
			<descr>
				<p>The vertical coordinate at which the event occurred relative to the DOM implementation's client area.</p>
			</descr>
		</attribute>
		<attribute type="boolean" name="ctrlKey" readonly="yes" id="Events-MouseEvent-ctrlKey">
			<descr>
				<p>
					<code>true</code>if the control (Ctrl) key modifier is activated.</p>
			</descr>
		</attribute>
		<attribute type="boolean" name="shiftKey" readonly="yes" id="Events-MouseEvent-shiftKey">
			<descr>
				<p>
					<code>true</code>if the shift (Shift) key modifier is activated.</p>
			</descr>
		</attribute>
		<attribute type="boolean" name="altKey" readonly="yes" id="Events-MouseEvent-altKey">
			<descr>
				<p>
					<code>true</code>if the alt (alternative) key modifier is activated.</p>
				<note>
					<p>The Option key modifier on Macintosh systems must be represented using this key modifier.</p>
				</note>
			</descr>
		</attribute>
		<attribute type="boolean" name="metaKey" readonly="yes" id="Events-MouseEvent-metaKey">
			<descr>
				<p>
					<code>true</code>if the meta (Meta) key modifier is activated.</p>
				<note>
					<p>The Command key modifier on Macintosh system must be represented using this meta key.</p>
				</note>
			</descr>
		</attribute>
		<attribute type="unsigned short" name="button" readonly="yes" id="Events-MouseEvent-button">
			<descr>
				<p>During mouse events caused by the depression or release of a mouse button,<code>button</code>is used to indicate which mouse button changed state.<code>0</code>indicates the normal button of the mouse (in general on the left or the one button on Macintosh mice, used to activate a button or select text).<code>2</code>indicates the contextual property (in general on the right, used to display a context menu) button of the mouse if present.<code>1</code>indicates the extra (in general in the middle and often combined with the mouse wheel) button. Some mice may provide or simulate more buttons, and values higher than<code>2</code>can be used to represent such buttons.</p>
			</descr>
		</attribute>
		<attribute type="EventTarget" name="relatedTarget" readonly="yes" id="Events-MouseEvent-relatedTarget">
			<descr>
				<p>Used to identify a secondary<code>EventTarget</code>related to a UI event. Currently this attribute is used with the mouseover event to indicate the<code>EventTarget</code>which the pointing device exited and with the mouseout event to indicate the<code>EventTarget</code>which the pointing device entered.</p>
			</descr>
		</attribute>
		<method name="initMouseEvent" id="Events-Event-initMouseEvent">
			<descr>
				<p>The<code>initMouseEvent</code>method is used to initialize the value of a<code>MouseEvent</code>object and has the same behavior as<code>UIEvent.initUIEvent()</code>.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="detailArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="screenXArg" type="long" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.screenX</code>.</p>
					</descr>
				</param>
				<param name="screenYArg" type="long" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.screenY</code>.</p>
					</descr>
				</param>
				<param name="clientXArg" type="long" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.clientX</code>.</p>
					</descr>
				</param>
				<param name="clientYArg" type="long" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.clientY</code>.</p>
					</descr>
				</param>
				<param name="ctrlKeyArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.ctrlKey</code>.</p>
					</descr>
				</param>
				<param name="altKeyArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.altKey</code>.</p>
					</descr>
				</param>
				<param name="shiftKeyArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.shiftKey</code>.</p>
					</descr>
				</param>
				<param name="metaKeyArg" type="boolean" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.metaKey</code>.</p>
					</descr>
				</param>
				<param name="buttonArg" type="unsigned short" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.button</code>.</p>
					</descr>
				</param>
				<param name="relatedTargetArg" type="EventTarget" attr="in">
					<descr>
						<p>Specifies<code>MouseEvent.relatedTarget</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method id="Events-MouseEvent-getModifierState" name="getModifierState" since="DOM Level 3">
			<descr>
				<p>This methods queries the state of a modifier using a key identifier. See also<specref ref="Modifiers"/>.</p>
			</descr>
			<parameters>
				<param name="keyIdentifierArg" type="DOMString" attr="in">
					<descr>
						<p>A modifier key identifier, as defined by the<code>KeyboardEvent.keyIdentifier</code>attribute. Common modifier keys are<code>"Alt"</code>,<code>"AltGraph"</code>,<code>"CapsLock"</code>,<code>"Control"</code>,<code>"Meta"</code>,<code>"NumLock"</code>,<code>"Scroll"</code>, or<code>"Shift"</code>.</p>
						<note>
							<p>If an application wishes to distinguish between right and left modifiers, this information could be deduced using keyboard events and<code>KeyboardEvent.keyLocation</code>.</p>
						</note>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if it is modifier key and the modifier is activated,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initMouseEventNS" id="Events-Event-initMouseEventNS" since="DOM Level 3">
			<descr>
				<p>The<code>initMouseEventNS</code>method is used to initialize the value of a<code>MouseEvent</code>object and has the same behavior as<code>UIEvent.initUIEventNS()</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="detailArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="screenXArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="screenYArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="clientXArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="clientYArg" type="long" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="buttonArg" type="unsigned short" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="relatedTargetArg" type="EventTarget" attr="in">
					<descr>
						<p>Refer to the<code>MouseEvent.initMouseEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="modifiersList" type="DOMString" attr="in">
					<descr>
						<p>Aseparated list of modifier key identifiers to be activated on this object. As an example,<code>"Control Alt"</code>will activated the control and alt modifiers.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="KeyboardEvent" inherits="UIEvent" id="Events-KeyboardEvent" since="DOM Level 3">
		<descr>
			<p>The<code>KeyboardEvent</code>interface provides specific contextual information associated with keyboard devices. Each keyboard event references a key using an identifier. Keyboard events are commonly directed at the element that has the focus.</p>
			<p>The<code>KeyboardEvent</code>interface provides convenient attributes for some common modifiers keys:<code>KeyboardEvent.ctrlKey</code>,<code>KeyboardEvent.shiftKey</code>,<code>KeyboardEvent.altKey</code>,<code>KeyboardEvent.metaKey</code>. These attributes are equivalent to use the method<code>KeyboardEvent.getModifierState(keyIdentifierArg)</code>with "Control", "Shift", "Alt", or "Meta" respectively.</p>
			<p>To create an instance of the<code>KeyboardEvent</code>interface, use the<code>DocumentEvent.createEvent("KeyboardEvent")</code>method call.</p>
		</descr>
		<group id="ID-KeyboardEvent-KeyLocationCode" name="KeyLocationCode">
			<descr>
				<p>This set of constants is used to indicate the location of a key on the device. In case a DOM implementation wishes to provide a new location information, a value different from the following constant values must be used.</p>
			</descr>
			<constant name="DOM_KEY_LOCATION_STANDARD" id="DOM_KEY_LOCATION_STANDARD" type="unsigned long" value="0x00">
				<descr>
					<p>The key activation is not distinguished as the left or right version of the key, and did not originate from the numeric keypad (or did not originate with a virtual key corresponding to the numeric keypad). Example: the 'Q' key on a PC 101 Key US keyboard.</p>
				</descr>
			</constant>
			<constant name="DOM_KEY_LOCATION_LEFT" id="DOM_KEY_LOCATION_LEFT" type="unsigned long" value="0x01">
				<descr>
					<p>The key activated is in the left key location (there is more than one possible location for this key). Example: the left Shift key on a PC 101 Key US keyboard.</p>
				</descr>
			</constant>
			<constant name="DOM_KEY_LOCATION_RIGHT" id="DOM_KEY_LOCATION_RIGHT" type="unsigned long" value="0x02">
				<descr>
					<p>The key activation is in the right key location (there is more than one possible location for this key). Example: the right Shift key on a PC 101 Key US keyboard.</p>
				</descr>
			</constant>
			<constant name="DOM_KEY_LOCATION_NUMPAD" id="DOM_KEY_LOCATION_NUMPAD" type="unsigned long" value="0x03">
				<descr>
					<p>The key activation originated on the numeric keypad or with a virtual key corresponding to the numeric keypad. Example: the '1' key on a PC 101 Key US keyboard located on the numeric pad.</p>
				</descr>
			</constant>
		</group>
		<attribute type="DOMString" name="keyIdentifier" id="Events-KeyboardEvent-keyIdentifier" readonly="yes">
			<descr>
				<p>
					<code>keyIdentifier</code>holds the identifier of the key. The key identifiers are defined in Appendix A.2 "<specref ref="KeySet-Set"/>". Implementations that are unable to identify a key must use the key identifier<code>"Unidentified"</code>.</p>
			</descr>
		</attribute>
		<attribute id="Events-KeyboardEvent-keylocation" name="keyLocation" type="unsigned long" readonly="yes">
			<descr>
				<p>The<code>keyLocation</code>attribute contains an indication of the location of they key on the device, as described in<specref ref="ID-KeyboardEvent-KeyLocationCode"/>.</p>
			</descr>
		</attribute>
		<attribute name="ctrlKey" id="Events-KeyboardEvent-ctrlKey" type="boolean" readonly="yes">
			<descr>
				<p>
					<code>true</code>if the control (Ctrl) key modifier is activated.</p>
			</descr>
		</attribute>
		<attribute name="shiftKey" id="Events-KeyboardEvent-shiftKey" type="boolean" readonly="yes">
			<descr>
				<p>
					<code>true</code>if the shift (Shift) key modifier is activated.</p>
			</descr>
		</attribute>
		<attribute name="altKey" id="Events-KeyboardEvent-altKey" type="boolean" readonly="yes">
			<descr>
				<p>
					<code>true</code>if the alternative (Alt) key modifier is activated.</p>
				<note>
					<p>The Option key modifier on Macintosh systems must be represented using this key modifier.</p>
				</note>
			</descr>
		</attribute>
		<attribute name="metaKey" id="Events-KeyboardEvent-metaKey" type="boolean" readonly="yes">
			<descr>
				<p>
					<code>true</code>if the meta (Meta) key modifier is activated.</p>
				<note>
					<p>The Command key modifier on Macintosh systems must be represented using this key modifier.</p>
				</note>
			</descr>
		</attribute>
		<method id="Events-KeyboardEvent-getModifierState" name="getModifierState">
			<descr>
				<p>This methods queries the state of a modifier using a key identifier. See also<specref ref="Modifiers"/>.</p>
			</descr>
			<parameters>
				<param name="keyIdentifierArg" type="DOMString" attr="in">
					<descr>
						<p>A modifier key identifier. Common modifier keys are<code>"Alt"</code>,<code>"AltGraph"</code>,<code>"CapsLock"</code>,<code>"Control"</code>,<code>"Meta"</code>,<code>"NumLock"</code>,<code>"Scroll"</code>, or<code>"Shift"</code>.</p>
						<note>
							<p>If an application wishes to distinguish between right and left modifiers, this information could be deduced using keyboard events and<code>KeyboardEvent.keyLocation</code>.</p>
						</note>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>
						<code>true</code>if it is modifier key and the modifier is activated,<code>false</code>otherwise.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initKeyboardEvent" id="Events-KeyboardEvent-initKeyboardEvent">
			<descr>
				<p>The<code>initKeyboardEvent</code>method is used to initialize the value of a<code>KeyboardEvent</code>object and has the same behavior as<code>UIEvent.initUIEvent()</code>. The value of<code>UIEvent.detail</code>remains undefined.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="keyIdentifierArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>KeyboardEvent.keyIdentifier</code>.</p>
					</descr>
				</param>
				<param name="keyLocationArg" type="unsigned long" attr="in">
					<descr>
						<p>Specifies<code>KeyboardEvent.keyLocation</code>.</p>
					</descr>
				</param>
				<param name="modifiersList" type="DOMString" attr="in">
					<descr>
						<p>Aseparated list of modifier key identifiers to be activated on this object.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
		<method name="initKeyboardEventNS" id="Events-KeyboardEvent-initKeyboardEventNS">
			<descr>
				<p>The<code>initKeyboardEventNS</code>method is used to initialize the value of a<code>KeyboardEvent</code>object and has the same behavior as<code>UIEvent.initUIEventNS()</code>. The value of<code>UIEvent.detail</code>remains undefined.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="viewArg" type="views::AbstractView" attr="in">
					<descr>
						<p>Refer to the<code>UIEvent.initUIEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="keyIdentifierArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>KeyboardEvent.initKeyboardEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="keyLocationArg" type="unsigned long" attr="in">
					<descr>
						<p>Refer to the<code>KeyboardEvent.initKeyboardEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="modifiersList" type="DOMString" attr="in">
					<descr>
						<p>Aseparated list of modifier key identifiers to be activated on this object. As an example,<code>"Control Alt"</code>will activated the control and alt modifiers.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="MutationEvent" inherits="Event" id="Events-MutationEvent" since="DOM Level 2">
		<descr>
			<p>The<code>MutationEvent</code>interface provides specific contextual information associated with Mutation events.</p>
			<p>To create an instance of the<code>MutationEvent</code>interface, use the<code>DocumentEvent.createEvent("MutationEvent")</code>method call.</p>
		</descr>
		<group id="Events-MutationEvent-attrChangeType" name="attrChangeType">
			<descr>
				<p>An integer indicating in which way the<code>Attr</code>was changed.</p>
			</descr>
			<constant name="MODIFICATION" id="MODIFICATION" type="unsigned short" value="1">
				<descr>
					<p>The<code>Attr</code>was modified in place.</p>
				</descr>
			</constant>
			<constant name="ADDITION" id="ADDITION" type="unsigned short" value="2">
				<descr>
					<p>The<code>Attr</code>was just added.</p>
				</descr>
			</constant>
			<constant name="REMOVAL" id="REMOVAL" type="unsigned short" value="3">
				<descr>
					<p>The<code>Attr</code>was just removed.</p>
				</descr>
			</constant>
		</group>
		<attribute type="Node" name="relatedNode" readonly="yes" id="Events-MutationEvent-relatedNode">
			<descr>
				<p>
					<code>relatedNode</code>is used to identify a secondary node related to a mutation event. For example, if a mutation event is dispatched to a node indicating that its parent has changed, the<code>relatedNode</code>is the changed parent. If an event is instead dispatched to a subtree indicating a node was changed within it, the<code>relatedNode</code>is the changed node. In the case of the<code>{"http://www.w3.org/2001/xml-events", "DOMAttrModified"}</code>event it indicates the<code>Attr</code>node which was modified, added, or removed.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="prevValue" readonly="yes" id="Events-MutationEvent-prevValue">
			<descr>
				<p>
					<code>prevValue</code>indicates the previous value of the<code>Attr</code>node in<code>{"http://www.w3.org/2001/xml-events", "DOMAttrModified"}</code>events, and of the<code>CharacterData</code>node in<code>{"http://www.w3.org/2001/xml-events", "DOMCharacterDataModified"}</code>events.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="newValue" readonly="yes" id="Events-MutationEvent-newValue">
			<descr>
				<p>
					<code>newValue</code>indicates the new value of the<code>Attr</code>node in<code>{"http://www.w3.org/2001/xml-events", "DOMAttrModified"}</code>events, and of the<code>CharacterData</code>node in<code>{"http://www.w3.org/2001/xml-events", "DOMCharacterDataModified"}</code>events.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="attrName" readonly="yes" id="Events-MutationEvent-attrName">
			<descr>
				<p>
					<code>attrName</code>indicates the name of the changed<code>Attr</code>node in a<code>{"http://www.w3.org/2001/xml-events", "DOMAttrModified"}</code>event.</p>
			</descr>
		</attribute>
		<attribute type="unsigned short" name="attrChange" readonly="yes" id="Events-MutationEvent-attrChange">
			<descr>
				<p>
					<code>attrChange</code>indicates the type of change which triggered the<code>{"http://www.w3.org/2001/xml-events", "DOMAttrModified"}</code>event. The values can be<code>MODIFICATION</code>,<code>ADDITION</code>, or<code>REMOVAL</code>.</p>
			</descr>
		</attribute>
		<method name="initMutationEvent" id="Events-Event-initMutationEvent">
			<descr>
				<p>The<code>initMutationEvent</code>method is used to initialize the value of a<code>MutationEvent</code>object and has the same behavior as<code>Event.initEvent()</code>.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="relatedNodeArg" type="Node" attr="in">
					<descr>
						<p>Specifies<code>MutationEvent.relatedNode</code>.</p>
					</descr>
				</param>
				<param name="prevValueArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>MutationEvent.prevValue</code>. This value may be null.</p>
					</descr>
				</param>
				<param name="newValueArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>MutationEvent.newValue</code>. This value may be null.</p>
					</descr>
				</param>
				<param name="attrNameArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>MutationEvent.attrname</code>. This value may be null.</p>
					</descr>
				</param>
				<param name="attrChangeArg" type="unsigned short" attr="in">
					<descr>
						<p>Specifies<code>MutationEvent.attrChange</code>. This value may be null.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initMutationEventNS" id="Events-Event-initMutationEventNS" since="DOM Level 3">
			<descr>
				<p>The<code>initMutationEventNS</code>method is used to initialize the value of a<code>MutationEvent</code>object and has the same behavior as<code>Event.initEventNS()</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>Event.initEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="relatedNodeArg" type="Node" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="prevValueArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="newValueArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="attrNameArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="attrChangeArg" type="unsigned short" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="MutationNameEvent" inherits="MutationEvent" id="Events-MutationNameEvent" since="DOM Level 3">
		<descr>
			<p>The<code>MutationNameEvent</code>interface provides specific contextual information associated with Mutation name event types.</p>
			<p>To create an instance of the<code>MutationNameEvent</code>interface, use the<code>Document.createEvent("MutationNameEvent")</code>method call.</p>
		</descr>
		<attribute type="DOMString" name="prevNamespaceURI" readonly="yes" id="Events-MutationNameEvent-prevNamespaceURI">
			<descr>
				<p>The previous value of the<code>relatedNode</code>'s<code>namespaceURI</code>.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" name="prevNodeName" readonly="yes" id="Events-MutationNameEvent-prevNodeName">
			<descr>
				<p>The previous value of the<code>relatedNode</code>'s<code>nodeName</code>.</p>
			</descr>
		</attribute>
		<method name="initMutationNameEvent" id="Events-Event-initMutationNameEvent" since="DOM Level 3">
			<descr>
				<p>The<code>initMutationNameEvent</code>method is used to initialize the value of a<code>MutationNameEvent</code>object and has the same behavior as<code>MutationEvent.initMutationEvent()</code>.</p>
			</descr>
			<parameters>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="relatedNodeArg" type="Node" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="prevNamespaceURIArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>MutationNameEvent.prevNamespaceURI</code>. This value may be<code>null</code>.</p>
					</descr>
				</param>
				<param name="prevNodeNameArg" type="DOMString" attr="in">
					<descr>
						<p>Specifies<code>MutationNameEvent.prevNodeName</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="initMutationNameEventNS" id="Events-Event-initMutationNameEventNS" since="DOM Level 3">
			<descr>
				<p>The<code>initMutationNameEventNS</code>method is used to initialize the value of a<code>MutationNameEvent</code>object and has the same behavior as<code>MutationEvent.initMutationEventNS()</code>.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="typeArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="canBubbleArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="cancelableArg" type="boolean" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="relatedNodeArg" type="Node" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEventNS()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="prevNamespaceURIArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
				<param name="prevNodeNameArg" type="DOMString" attr="in">
					<descr>
						<p>Refer to the<code>MutationEvent.initMutationEvent()</code>method for a description of this parameter.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<exception id="LS-LSException" name="LSException">
		<descr>
			<p>Parser or write operations may throw an<code>LSException</code>if the processing is stopped. The processing can be stopped due to a<code>DOMError</code>with a severity of<code>DOMError.SEVERITY_FATAL_ERROR</code>or a non recovered<code>DOMError.SEVERITY_ERROR</code>, or if<code>DOMErrorHandler.handleError()</code>returned<code>false</code>.</p>
			<note>
				<p>As suggested in the definition of the constants in the<code>DOMError</code>interface, a DOM implementation may choose to continue after a fatal error, but the resulting DOM tree is then implementation dependent.</p>
			</note>
		</descr>
		<component id="LS-LSException-code" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="LS-LSException-LSExceptionCode" name="LSExceptionCode">
		<descr>
			<p>An integer indicating the type of error generated.</p>
		</descr>
		<constant name="PARSE_ERR" id="PARSE_ERR" type="unsigned short" value="81">
			<descr>
				<p>If an attempt was made to load a document, or an XML Fragment, using<code>LSParser</code>and the processing has been stopped.</p>
			</descr>
		</constant>
		<constant name="SERIALIZE_ERR" id="SERIALIZE_ERR" type="unsigned short" value="82">
			<descr>
				<p>If an attempt was made to serialize a<code>Node</code>using<code>LSSerializer</code>and the processing has been stopped.</p>
			</descr>
		</constant>
	</group>
	<interface name="DOMImplementationLS" id="LS-DOMImplementation">
		<descr>
			<p>
				<code>DOMImplementationLS</code>contains the factory methods for creating Load and Save objects.</p>
			<p>The expectation is that an instance of the<code>DOMImplementationLS</code>interface can be obtained by using binding-specific casting methods on an instance of the<code>DOMImplementation</code>interface or, if the<code>Document</code>supports the feature<code>"Core"</code>version<code>"3.0"</code>defined in<bibref role="informative" ref="DOMCore"/>, by using the method<code>DOMImplementation.getFeature</code>with parameter values<code>"LS"</code>(or<code>"LS-Async"</code>) and<code>"3.0"</code>(respectively).</p>
		</descr>
		<group name="DOMImplementationLSMode" id="LS-DOMImplementationLS-DOMImplementationLSMode">
			<descr>
				<p>Integer parser mode constants.</p>
			</descr>
			<constant name="MODE_SYNCHRONOUS" id="LS-DOMImplementationLS-MODE_SYNC" type="unsigned short" value="1">
				<descr>
					<p>Create a synchronous<code>LSParser</code>.</p>
				</descr>
			</constant>
			<constant name="MODE_ASYNCHRONOUS" id="LS-DOMImplementationLS-MODE_ASYNCH" type="unsigned short" value="2">
				<descr>
					<p>Create an asynchronous<code>LSParser</code>.</p>
				</descr>
			</constant>
		</group>
		<method name="createLSParser" id="LS-DOMImplementationLS-createLSParser">
			<descr>
				<p>Create a new<code>LSParser</code>. The newly constructed parser may then be configured by means of its<code>DOMConfiguration</code>object, and used to parse documents by means of its<code>parse</code>method.</p>
			</descr>
			<parameters>
				<param name="mode" type="unsigned short" attr="in">
					<descr>
						<p>The<code>mode</code>argument is either<code>MODE_SYNCHRONOUS</code>or<code>MODE_ASYNCHRONOUS</code>, if<code>mode</code>is<code>MODE_SYNCHRONOUS</code>then the<code>LSParser</code>that is created will operate in synchronous mode, if it's<code>MODE_ASYNCHRONOUS</code>then the<code>LSParser</code>that is created will operate in asynchronous mode.</p>
					</descr>
				</param>
				<param name="schemaType" type="DOMString" attr="in">
					<descr>
						<p>An absolute URI representing the type of the<termref def="dt-schema">schema</termref>language used during the load of a<code>Document</code>using the newly created<code>LSParser</code>. Note that no lexical checking is done on the absolute URI. In order to create a<code>LSParser</code>for any kind of schema types (i.e. the LSParser will be free to use any schema found), use the value<code>null</code>.</p>
						<note>
							<p>For W3C XML Schema<bibref ref="XMLSchema1" role="informative"/>, applications must use the value<code>"http://www.w3.org/2001/XMLSchema"</code>. For XML DTD<bibref ref="XML" role="informative"/>, applications must use the value<code>"http://www.w3.org/TR/REC-xml"</code>. Other Schema languages are outside the scope of the W3C and therefore should recommend an absolute URI in order to use this method.</p>
						</note>
					</descr>
				</param>
			</parameters>
			<returns type="LSParser">
				<descr>
					<p>The newly created<code>LSParser</code>object. This<code>LSParser</code>is either synchronous or asynchronous depending on the value of the<code>mode</code>argument.</p>
					<note>
						<p>By default, the newly created<code>LSParser</code>does not contain a<code>DOMErrorHandler</code>, i.e. the value of the "" configuration parameter is<code>null</code>. However, implementations may provide a default error handler at creation time. In that case, the initial value of the<code>"error-handler"</code>configuration parameter on the new<code>LSParser</code>object contains a reference to the default error handler.</p>
					</note>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the requested mode or schema type is not supported.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createLSSerializer" id="LS-DOMImplementationLS-createLSSerializer">
			<descr>
				<p>Create a new<code>LSSerializer</code>object.</p>
			</descr>
			<parameters/>
			<returns type="LSSerializer">
				<descr>
					<p>The newly created<code>LSSerializer</code>object.</p>
					<note>
						<p>By default, the newly created<code>LSSerializer</code>has no<code>DOMErrorHandler</code>, i.e. the value of the<code>"error-handler"</code>configuration parameter is<code>null</code>. However, implementations may provide a default error handler at creation time. In that case, the initial value of the<code>"error-handler"</code>configuration parameter on the new<code>LSSerializer</code>object contains a reference to the default error handler.</p>
					</note>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createLSInput" id="LS-DOMImplementationLS-createLSInput">
			<descr>
				<p>Create a new empty input source object where<code>LSInput.characterStream</code>,<code>LSInput.byteStream</code>,<code>LSInput.stringData</code>
					<code>LSInput.systemId</code>,<code>LSInput.publicId</code>,<code>LSInput.baseURI</code>, and<code>LSInput.encoding</code>are null, and<code>LSInput.certifiedText</code>is false.</p>
			</descr>
			<parameters/>
			<returns type="LSInput">
				<descr>
					<p>The newly created input object.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="createLSOutput" id="LS-DOMImplementationLS-createLSOutput">
			<descr>
				<p>Create a new empty output destination object where<code>LSOutput.characterStream</code>,<code>LSOutput.byteStream</code>,<code>LSOutput.systemId</code>,<code>LSOutput.encoding</code>are null.</p>
			</descr>
			<parameters/>
			<returns type="LSOutput">
				<descr>
					<p>The newly created output object.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="LSParser" id="LS-LSParser">
		<descr>
			<p>An interface to an object that is able to build, or augment, a DOM tree from various input sources.</p>
			<p>
				<code>LSParser</code>provides an API for parsing XML and building the corresponding DOM document structure. A<code>LSParser</code>instance can be obtained by invoking the<code>DOMImplementationLS.createLSParser()</code>method.</p>
			<p>As specified in<bibref ref="DOMCore"/>, when a document is first made available via the LSParser:</p>
			<ulist>
				<item>
					<p>there will never be two adjacent nodes of type NODE_TEXT, and there will never be empty text nodes.</p>
				</item>
				<item>
					<p>it is expected that the<code>value</code>and<code>nodeValue</code>attributes of an<code>Attr</code>node initially return the. However, if the parameters "" and "" are set to<code>true</code>, depending on the attribute normalization used, the attribute values may differ from the ones obtained by the XML 1.0 attribute normalization.<termdef id="infoset-attribute" term="[attributes]">If the parameters "" is set to<code>false</code>, the XML 1.0 attribute normalization is guaranteed to occur, and if the attributes list does not contain namespace declarations, the<code>attributes</code>attribute on<code>Element</code>node represents the property<b>[attributes]</b>defined in<bibref ref="InfoSet"/>
						</termdef>.</p>
				</item>
			</ulist>
			<p>Asynchronous<code>LSParser</code>objects are expected to also implement the<code>events::EventTarget</code>interface so that event listeners can be registered on asynchronous<code>LSParser</code>objects.</p>
			<p>Events supported by asynchronous<code>LSParser</code>objects are:</p>
			<glist>
				<gitem>
					<label id="event-load">load</label>
					<def>
						<p>The<code>LSParser</code>finishes to load the document. See also the definition of the<code>LSLoadEvent</code>interface.</p>
					</def>
				</gitem>
				<gitem>
					<label id="event-progress">progress</label>
					<def>
						<p>The<code>LSParser</code>signals progress as data is parsed.</p>
						<p>This specification does not attempt to define exactly when progress events should be dispatched. That is intentionally left as implementation-dependent. Here is one example of how an application might dispatch progress events: Once the parser starts receiving data, a progress event is dispatched to indicate that the parsing starts. From there on, a progress event is dispatched for every 4096 bytes of data that is received and processed. This is only one example, though, and implementations can choose to dispatch progress events at any time while parsing, or not dispatch them at all.</p>
						<p>See also the definition of the<code>LSProgressEvent</code>interface.</p>
					</def>
				</gitem>
			</glist>
			<note>
				<p>All events defined in this specification use the namespace URI<code>"http://www.w3.org/2002/DOMLS"</code>.</p>
			</note>
			<p>While parsing an input source, errors are reported to the application through the error handler (<code>LSParser.domConfig</code>'s "" parameter). This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined. The types (<code>DOMError.type</code>) of errors and warnings defined by this specification are:<glist>
					<gitem>
						<label>
							<code>"check-character-normalization-failure" [error]</code>
						</label>
						<def>
							<p>Raised if the parameter "" is set to true and a string is encountered that fails normalization checking.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"doctype-not-allowed" [fatal]</code>
						</label>
						<def>
							<p>Raised if the configuration parameter "<termref def="parameter-disallow-doctype">disallow-doctype</termref>" is set to<code>true</code>and a doctype is encountered.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"no-input-specified" [fatal]</code>
						</label>
						<def>
							<p>Raised when loading a document and no input is specified in the<code>LSInput</code>object.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"pi-base-uri-not-preserved" [warning]</code>
						</label>
						<def>
							<p>Raised if a processing instruction is encountered in a location where the base URI of the processing instruction can not be preserved.</p>
							<p>One example of a case where this warning will be raised is if the configuration parameter "" is set to<code>false</code>and the following XML file is parsed:</p>
							<eg role="code" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">&lt;!DOCTYPE root [ &lt;!ENTITY e SYSTEM 'subdir/myentity.ent' ]&gt; &lt;root&gt; &amp;e; &lt;/root&gt;</eg>
							<p>And<code>subdir/myentity.ent</code>contains:</p>
							<eg role="code" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:space="preserve">&lt;one&gt; &lt;two/&gt; &lt;/one&gt; &lt;?pi 3.14159?&gt; &lt;more/&gt;</eg>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unbound-prefix-in-entity" [warning]</code>
						</label>
						<def>
							<p>An implementation dependent warning that may be raised if the configuration parameter "" is set to<code>true</code>and an unbound namespace prefix is encountered in an entity's replacement text. Raising this warning is not enforced since some existing parsers may not recognize unbound namespace prefixes in the replacement text of entities.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unknown-character-denormalization" [fatal]</code>
						</label>
						<def>
							<p>Raised if the configuration parameter "<termref def="parameter-ignore-unknown-character-denormalizations">ignore-unknown-character-denormalizations</termref>" is set to<code>false</code>and a character is encountered for which the processor cannot determine the normalization properties.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unsupported-encoding" [fatal]</code>
						</label>
						<def>
							<p>Raised if an unsupported encoding is encountered.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unsupported-media-type" [fatal]</code>
						</label>
						<def>
							<p>Raised if the configuration parameter "<termref def="parameter-supported-media-types-only">supported-media-types-only</termref>" is set to<code>true</code>and an unsupported media type is encountered.</p>
						</def>
					</gitem>
				</glist>
			</p>
			<p>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...), XML well-formedness errors, and so on.</p>
		</descr>
		<attribute type="DOMConfiguration" readonly="yes" name="domConfig" id="LS-LSParser-config">
			<descr>
				<p>The<code>DOMConfiguration</code>object used when parsing an input source. This<code>DOMConfiguration</code>is specific to the parse operation. No parameter values from this<code>DOMConfiguration</code>object are passed automatically to the<code>DOMConfiguration</code>object on the<code>Document</code>that is created, or used, by the parse operation. The DOM application is responsible for passing any needed parameter values from this<code>DOMConfiguration</code>object to the<code>DOMConfiguration</code>object referenced by the<code>Document</code>object.</p>
				<p>In addition to the parameters recognized in on theinterface defined in<bibref ref="DOMCore"/>, the<code>DOMConfiguration</code>objects for<code>LSParser</code>add or modify the following parameters:</p>
				<glist>
					<gitem>
						<label id="parameter-charset-overrides-xml-encoding">
							<code>"charset-overrides-xml-encoding"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>optional</emph>] (<emph>default</emph>)</p>
										<p>If a higher level protocol such as HTTP<bibref role="informative" ref="RFC2616"/>provides an indication of the character encoding of the input stream being processed, that will override any encoding specified in the XML declaration or the Text declaration (see also section 4.3.3, "Character Encoding in Entities", in<bibref ref="XML"/>). Explicitly setting an encoding in the<code>LSInput</code>overrides any encoding from the protocol.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>]</p>
										<p>The parser ignores any character set encoding information from higher-level protocols.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-disallow-doctype">
							<code>"disallow-doctype"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Throw a fatal<b>"doctype-not-allowed"</b>error if a doctype node is found while parsing the document. This is useful when dealing with things like SOAP envelopes where doctype nodes are not allowed.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Allow doctype nodes in the document.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-ignore-unknown-character-denormalizations">
							<code>"ignore-unknown-character-denormalizations"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>If, while verifying full normalization when<bibref ref="XML11"/>is supported, a processor encounters characters for which it cannot determine the normalization properties, then the processor will ignore any possible denormalizations caused by these characters.</p>
										<p>This parameter is ignored for<bibref ref="XML"/>.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Report an fatal<b>"unknown-character-denormalization"</b>error if a character is encountered for which the processor cannot determine the normalization properties.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-infoset">
							<code>"infoset"</code>
						</label>
						<def>
							<p>See the definition of<code>DOMConfiguration</code>for a description of this parameter. Unlike in<bibref ref="DOMCore"/>, this parameter will default to<code>true</code>for<code>LSParser</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-namespaces">
							<code>"namespaces"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Perform the namespace processing as defined in<bibref ref="Namespaces"/>and<bibref ref="Namespaces11"/>.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Do not perform the namespace processing.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-resource-resolver">
							<code>"resource-resolver"</code>
						</label>
						<def>
							<p>[<emph>required</emph>]</p>
							<p>A reference to a<code>LSResourceResolver</code>object, or null. If the value of this parameter is not null when an external resource (such as an external XML entity or an XML schema location) is encountered, the implementation will request that the<code>LSResourceResolver</code>referenced in this parameter resolves the resource.</p>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-supported-media-types-only">
							<code>"supported-media-types-only"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Check that the media type of the parsed resource is a supported media type. If an unsupported media type is encountered, a fatal error of type<b>"unsupported-media-type"</b>will be raised. The media types defined in<bibref ref="RFC3023"/>must always be accepted.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Accept any media type.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-validate">
							<code>"validate"</code>
						</label>
						<def>
							<p>See the definition of<code>DOMConfiguration</code>for a description of this parameter. Unlike in<bibref ref="DOMCore"/>, the processing of the internal subset is always accomplished, even if this parameter is set to<code>false</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-validate-if-schema">
							<code>"validate-if-schema"</code>
						</label>
						<def>
							<p>See the definition of<code>DOMConfiguration</code>for a description of this parameter. Unlike in<bibref ref="DOMCore"/>, the processing of the internal subset is always accomplished, even if this parameter is set to<code>false</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-well-formed">
							<code>"well-formed"</code>
						</label>
						<def>
							<p>See the definition of<code>DOMConfiguration</code>for a description of this parameter. Unlike in<bibref ref="DOMCore"/>, this parameter cannot be set to<code>false</code>.</p>
						</def>
					</gitem>
				</glist>
			</descr>
		</attribute>
		<attribute type="LSParserFilter" readonly="no" name="filter" id="LS-LSParser-filter">
			<descr>
				<p>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure. The filter can choose to remove elements from the document being constructed, or to terminate the parsing early.</p>
				<p>The filter is invoked after the operations requested by the<code>DOMConfiguration</code>parameters have been applied. For example, if "" is set to<code>true</code>, the validation is done before invoking the filter.</p>
			</descr>
		</attribute>
		<attribute type="boolean" readonly="yes" name="async" id="LS-LSParser-async">
			<descr>
				<p>
					<code>true</code>if the<code>LSParser</code>is asynchronous,<code>false</code>if it is synchronous.</p>
			</descr>
		</attribute>
		<attribute type="boolean" readonly="yes" name="busy" id="LS-LSParser-busy">
			<descr>
				<p>
					<code>true</code>if the<code>LSParser</code>is currently busy loading a document, otherwise<code>false</code>.</p>
			</descr>
		</attribute>
		<method name="parse" id="LS-LSParser-parse">
			<descr>
				<p>Parse an XML document from a resource identified by a<code>LSInput</code>.</p>
			</descr>
			<parameters>
				<param name="input" type="LSInput" attr="in">
					<descr>
						<p>The<code>LSInput</code>from which the source of the document is to be read.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Document">
				<descr>
					<p>If the<code>LSParser</code>is a synchronous<code>LSParser</code>, the newly created and populated<code>Document</code>is returned. If the<code>LSParser</code>is asynchronous,<code>null</code>is returned since the document object may not yet be constructed when this method returns.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if the<code>LSParser</code>'s<code>LSParser.busy</code>attribute is<code>true</code>.</p>
					</descr>
				</exception>
				<exception name="LSException">
					<descr>
						<p>PARSE_ERR: Raised if the<code>LSParser</code>was unable to load the XML document. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="parseURI" id="LS-LSParser-parseURI">
			<descr>
				<p>Parse an XML document from a location identified by a URI reference<bibref ref="URIRef"/>. If the URI contains a fragment identifier (see section 4.1 in<bibref ref="URIRef"/>), the behavior is not defined by this specification, future versions of this specification may define the behavior.</p>
			</descr>
			<parameters>
				<param name="uri" type="DOMString" attr="in">
					<descr>
						<p>The location of the XML document to be read.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Document">
				<descr>
					<p>If the<code>LSParser</code>is a synchronous<code>LSParser</code>, the newly created and populated<code>Document</code>is returned, or<code>null</code>if an error occured. If the<code>LSParser</code>is asynchronous,<code>null</code>is returned since the document object may not yet be constructed when this method returns.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if the<code>LSParser.busy</code>attribute is<code>true</code>.</p>
					</descr>
				</exception>
				<exception name="LSException">
					<descr>
						<p>PARSE_ERR: Raised if the<code>LSParser</code>was unable to load the XML document. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<group name="ACTION_TYPES" id="LS-LSParser-ACTION_TYPES">
			<descr>
				<p>A set of possible actions for the<code>parseWithContext</code>method.</p>
			</descr>
			<constant name="ACTION_APPEND_AS_CHILDREN" id="LS-LSParser-ACTION_APPEND_AS_CHILDREN" type="unsigned short" value="1">
				<descr>
					<p>Append the result of the parse operation as children of the context node. For this action to work, the context node must be an<code>Element</code>or a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
			<constant name="ACTION_REPLACE_CHILDREN" id="LS-LSParser-ACTION_REPLACE_CHILDREN" type="unsigned short" value="2">
				<descr>
					<p>Replace all the children of the context node with the result of the parse operation. For this action to work, the context node must be an<code>Element</code>, a<code>Document</code>, or a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
			<constant name="ACTION_INSERT_BEFORE" id="LS-LSParser-ACTION_INSERT_BEFORE" type="unsigned short" value="3">
				<descr>
					<p>Insert the result of the parse operation as the immediately preceding sibling of the context node. For this action to work the context node's parent must be an<code>Element</code>or a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
			<constant name="ACTION_INSERT_AFTER" id="LS-LSParser-ACTION_INSERT_AFTER" type="unsigned short" value="4">
				<descr>
					<p>Insert the result of the parse operation as the immediately following sibling of the context node. For this action to work the context node's parent must be an<code>Element</code>or a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
			<constant name="ACTION_REPLACE" id="LS-LSParser-ACTION_REPLACE" type="unsigned short" value="5">
				<descr>
					<p>Replace the context node with the result of the parse operation. For this action to work, the context node must have a parent, and the parent must be an<code>Element</code>or a<code>DocumentFragment</code>.</p>
				</descr>
			</constant>
		</group>
		<method name="parseWithContext" id="LS-LSParser-parseWithContext">
			<descr>
				<p>Parse an XML fragment from a resource identified by a<code>LSInput</code>and insert the content into an existing document at the position specified with the<code>context</code>and<code>action</code>arguments. When parsing the input stream, the context node (or its parent, depending on where the result will be inserted) is used for resolving unbound namespace prefixes. The context node's<code>ownerDocument</code>node (or the node itself if the node of type<code>DOCUMENT_NODE</code>) is used to resolve default attributes and entity references.</p>
				<p>As the new data is inserted into the document, at least one mutation event is fired per new immediate child or sibling of the context node.</p>
				<p>If the context node is a<code>Document</code>node and the action is<code>ACTION_REPLACE_CHILDREN</code>, then the document that is passed as the context node will be changed such that its<code>xmlEncoding</code>,<code>documentURI</code>,<code>xmlVersion</code>,<code>inputEncoding</code>,<code>xmlStandalone</code>, and all other such attributes are set to what they would be set to if the input source was parsed using<code>LSParser.parse()</code>.</p>
				<p>This method is always synchronous, even if the<code>LSParser</code>is asynchronous (<code>LSParser.async</code>is<code>true</code>).</p>
				<p>If an error occurs while parsing, the caller is notified through the<code>ErrorHandler</code>instance associated with the "" parameter of the<code>DOMConfiguration</code>.</p>
				<p>When calling<code>parseWithContext</code>, the values of the following configuration parameters will be ignored and their default values will always be used instead: "", "", and "". Other parameters will be treated normally, and the parser is expected to call the<code>LSParserFilter</code>just as if a whole document was parsed.</p>
			</descr>
			<parameters>
				<param name="input" type="LSInput" attr="in">
					<descr>
						<p>The<code>LSInput</code>from which the source document is to be read. The source document must be an XML fragment, i.e. anything except a complete XML document (except in the case where the context node of type<code>DOCUMENT_NODE</code>, and the action is<code>ACTION_REPLACE_CHILDREN</code>), a DOCTYPE (internal subset), entity declaration(s), notation declaration(s), or XML or text declaration(s).</p>
					</descr>
				</param>
				<param name="contextArg" type="Node" attr="in">
					<descr>
						<p>The node that is used as the context for the data that is being parsed. This node must be a<code>Document</code>node, a<code>DocumentFragment</code>node, or a node of a type that is allowed as a child of an<code>Element</code>node, e.g. it cannot be an<code>Attribute</code>node.</p>
					</descr>
				</param>
				<param name="action" type="unsigned short" attr="in">
					<descr>
						<p>This parameter describes which action should be taken between the new set of nodes being inserted and the existing children of the context node. The set of possible actions is defined in<code>ACTION_TYPES</code>above.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>Return the node that is the result of the parse operation. If the result is more than one top-level node, the first one is returned.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>HIERARCHY_REQUEST_ERR: Raised if the content cannot replace, be inserted before, after, or as a child of the context node (see also<code>Node.insertBefore</code>or<code>Node.replaceChild</code>in<bibref ref="DOMCore"/>).</p>
						<p>NOT_SUPPORTED_ERR: Raised if the<code>LSParser</code>doesn't support this method, or if the context node is of type<code>Document</code>and the DOM implementation doesn't support the replacement of the<code>DocumentType</code>child or<code>Element</code>child.</p>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if the context node is a<termref def="dt-readonly-node">read only node</termref>and the content is being appended to its child list, or if the parent node of the context node is<termref def="dt-readonly-node">read only node</termref>and the content is being inserted in its child list.</p>
						<p>INVALID_STATE_ERR: Raised if the<code>LSParser.busy</code>attribute is<code>true</code>.</p>
					</descr>
				</exception>
				<exception name="LSException">
					<descr>
						<p>PARSE_ERR: Raised if the<code>LSParser</code>was unable to load the XML fragment. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="abort" id="LS-LSParser-abort">
			<descr>
				<p>Abort the loading of the document that is currently being loaded by the<code>LSParser</code>. If the<code>LSParser</code>is currently not busy, a call to this method does nothing.</p>
			</descr>
			<parameters/>
			<returns type="void">
				<descr/>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="LSInput" id="LS-LSInput">
		<descr>
			<p>This interface represents an input source for data.</p>
			<p>This interface allows an application to encapsulate information about an input source in a single object, which may include a public identifier, a system identifier, a byte stream (possibly with a specified encoding), a base URI, and/or a character stream.</p>
			<p>The exact definitions of a byte stream and a character stream are binding dependent.</p>
			<p>The application is expected to provide objects that implement this interface whenever such objects are needed. The application can either provide its own objects that implement this interface, or it can use the generic factory method<code>DOMImplementationLS.createLSInput()</code>to create objects that implement this interface.</p>
			<p>The<code>LSParser</code>will use the<code>LSInput</code>object to determine how to read data. The<code>LSParser</code>will look at the different inputs specified in the<code>LSInput</code>in the following order to know which one to read from, the first one that is not null and not an empty string will be used:<olist>
					<item>
						<p>
							<code>LSInput.characterStream</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSInput.byteStream</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSInput.stringData</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSInput.systemId</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSInput.publicId</code>
						</p>
					</item>
				</olist>
			</p>
			<p>If all inputs are null, the<code>LSParser</code>will report a<code>DOMError</code>with its<code>DOMError.type</code>set to<code>"no-input-specified"</code>and its<code>DOMError.severity</code>set to<code>DOMError.SEVERITY_FATAL_ERROR</code>.</p>
			<p>
				<code>LSInput</code>objects belong to the application. The DOM implementation will never modify them (though it may make copies and modify the copies, if necessary).</p>
		</descr>
		<attribute type="LSReader" readonly="no" name="characterStream" id="LS-LSInput-characterStream" role="java-only">
			<descr>
				<p>An attribute of a language and binding dependent type that represents a stream of<termref def="dt-16-bit-unit">16-bit units</termref>. The application must encode the stream using UTF-16 (defined in<bibref ref="Unicode"/>and in<bibref ref="ISO10646"/>). It is not a requirement to have an XML declaration when using character streams. If an XML declaration is present, the value of the encoding attribute will be ignored.</p>
			</descr>
		</attribute>
		<attribute type="LSInputStream" readonly="no" name="byteStream" id="LS-LSInput-byteStream">
			<descr>
				<p>An attribute of a language and binding dependent type that represents a stream of bytes.</p>
				<p>If the application knows the character encoding of the byte stream, it should set the encoding attribute. Setting the encoding in this way will override any encoding specified in an XML declaration in the data.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="stringData" id="LS-LSInput-stringData">
			<descr>
				<p>String data to parse. If provided, this will always be treated as a sequence of<termref def="dt-16-bit-unit">16-bit units</termref>(UTF-16 encoded characters). It is not a requirement to have an XML declaration when using<code>stringData</code>. If an XML declaration is present, the value of the encoding attribute will be ignored.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="systemId" id="LS-LSInput-systemId">
			<descr>
				<p>The system identifier, a URI reference<bibref ref="URIRef"/>, for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</p>
				<p>If the application knows the character encoding of the object pointed to by the system identifier, it can set the encoding using the<code>encoding</code>attribute.</p>
				<p>If the specified system ID is a relative URI reference (see section 5 in<bibref ref="URIRef"/>), the DOM implementation will attempt to resolve the relative URI with the<code>baseURI</code>as the base, if that fails, the behavior is implementation dependent.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="publicId" id="LS-LSInput-publicId">
			<descr>
				<p>The public identifier for this input source. This may be mapped to an input source using an implementation dependent mechanism (such as catalogues or other mappings). The public identifier, if specified, may also be reported as part of the location information when errors are reported.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="baseURI" id="LS-LSInput-baseURI">
			<descr>
				<p>The base URI to be used (see section 5.1.4 in<bibref ref="URIRef"/>) for resolving a relative<code>systemId</code>to an absolute URI.</p>
				<p>If, when used, the base URI is itself a relative URI, an empty string, or null, the behavior is implementation dependent.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="encoding" id="LS-LSInput-encoding">
			<descr>
				<p>The character encoding, if known. The encoding must be a string acceptable for an XML encoding declaration (<bibref ref="XML"/>section 4.3.3 "Character Encoding in Entities").</p>
				<p>This attribute has no effect when the application provides a character stream or string data. For other sources of input, an encoding specified by means of this attribute will override any encoding specified in the XML declaration or the Text declaration, or an encoding obtained from a higher level protocol, such as HTTP<bibref role="informative" ref="RFC2616"/>.</p>
			</descr>
		</attribute>
		<attribute type="boolean" readonly="no" name="certifiedText" id="LS-LSInput-certifiedText">
			<descr>
				<p>If set to true, assume that the input is certified (see section 2.13 in<bibref ref="XML11"/>) when parsing<bibref ref="XML11"/>.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="LSResourceResolver" id="LS-LSResourceResolver" role="ecmascript-function">
		<descr>
			<p>
				<code>LSResourceResolver</code>provides a way for applications to redirect references to external resources.</p>
			<p>Applications needing to implement custom handling for external resources can implement this interface and register their implementation by setting the "resource-resolver" parameter of<code>DOMConfiguration</code>objects attached to<code>LSParser</code>and<code>LSSerializer</code>. It can also be register on<code>DOMConfiguration</code>objects attached to<code>Document</code>if the "LS" feature is supported.</p>
			<p>The<code>LSParser</code>will then allow the application to intercept any external entities, including the external DTD subset and external parameter entities, before including them. The top-level document entity is never passed to the<code>resolveResource</code>method.</p>
			<p>Many DOM applications will not need to implement this interface, but it will be especially useful for applications that build XML documents from databases or other specialized input sources, or for applications that use URNs.</p>
			<note>
				<p>
					<code>LSResourceResolver</code>is based on the SAX2<bibref ref="SAX"/>
					<code>EntityResolver</code>interface.</p>
			</note>
		</descr>
		<method name="resolveResource" id="LS-LSResourceResolver-resolveResource">
			<descr>
				<p>Allow the application to resolve external resources.</p>
				<p>The<code>LSParser</code>will call this method before opening any external resource, including the external DTD subset, external entities referenced within the DTD, and external entities referenced within the document element (however, the top-level document entity is not passed to this method). The application may then request that the<code>LSParser</code>resolve the external resource itself, that it use an alternative URI, or that it use an entirely different input source.</p>
				<p>Application writers can use this method to redirect external system identifiers to secure and/or local URI, to look up public identifiers in a catalogue, or to read an entity from a database or other input source (including, for example, a dialog box).</p>
			</descr>
			<parameters>
				<param name="type" type="DOMString" attr="in">
					<descr>
						<p>The type of the resource being resolved. For XML<bibref ref="XML" role="informative"/>resources (i.e. entities), applications must use the value<code>"http://www.w3.org/TR/REC-xml"</code>. For XML Schema<bibref ref="XMLSchema1" role="informative"/>, applications must use the value<code>"http://www.w3.org/2001/XMLSchema"</code>. Other types of resources are outside the scope of this specification and therefore should recommend an absolute URI in order to use this method.</p>
					</descr>
				</param>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The namespace of the resource being resolved, e.g. the target namespace of the XML Schema<bibref ref="XMLSchema1" role="informative"/>when resolving XML Schema resources.</p>
					</descr>
				</param>
				<param name="publicId" type="DOMString" attr="in">
					<descr>
						<p>The public identifier of the external entity being referenced, or<code>null</code>if no public identifier was supplied or if the resource is not an entity.</p>
					</descr>
				</param>
				<param name="systemId" type="DOMString" attr="in">
					<descr>
						<p>The system identifier, a URI reference<bibref ref="URIRef"/>, of the external resource being referenced, or<code>null</code>if no system identifier was supplied.</p>
					</descr>
				</param>
				<param name="baseURI" type="DOMString" attr="in">
					<descr>
						<p>The absolute base URI of the resource being parsed, or<code>null</code>if there is no base URI.</p>
					</descr>
				</param>
			</parameters>
			<returns type="LSInput">
				<descr>
					<p>A<code>LSInput</code>object describing the new input source, or<code>null</code>to request that the parser open a regular URI connection to the resource.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="LSParserFilter" id="LS-LSParserFilter">
		<descr>
			<p>
				<code>LSParserFilter</code>s provide applications the ability to examine nodes as they are being constructed while parsing. As each node is examined, it may be modified or removed, or the entire parse may be terminated early.</p>
			<p>At the time any of the filter methods are called by the parser, the owner Document and DOMImplementation objects exist and are accessible. The document element is never passed to the<code>LSParserFilter</code>methods, i.e. it is not possible to filter out the document element.<code>Document</code>,<code>DocumentType</code>,<code>Notation</code>,<code>Entity</code>, and<code>Attr</code>nodes are never passed to the<code>acceptNode</code>method on the filter. The child nodes of an<code>EntityReference</code>node are passed to the filter if the parameter "" is set to<code>false</code>. Note that, as described by the parameter "", unexpanded entity reference nodes are never discarded and are always passed to the filter.</p>
			<p>All validity checking while parsing a document occurs on the source document as it appears on the input stream, not on the DOM document as it is built in memory. With filters, the document in memory may be a subset of the document on the stream, and its validity may have been affected by the filtering.</p>
			<p>All default attributes must be present on elements when the elements are passed to the filter methods. All other default content must be passed to the filter methods.</p>
			<p>DOM applications must not raise exceptions in a filter. The effect of throwing exceptions from a filter is DOM implementation dependent.</p>
		</descr>
		<group name="Constants returned by startElement and acceptNode" id="LS-LSParserFilter-acceptNode-constants">
			<descr>
				<p>Constants returned by<code>startElement</code>and<code>acceptNode</code>.</p>
			</descr>
			<constant id="LS-LSParserFilter-FILTER_ACCEPT" name="FILTER_ACCEPT" type="short" value="1">
				<descr>
					<p>Accept the node.</p>
				</descr>
			</constant>
			<constant id="LS-LSParserFilter-FILTER_REJECT" name="FILTER_REJECT" type="short" value="2">
				<descr>
					<p>Reject the node and its children.</p>
				</descr>
			</constant>
			<constant id="LS-LSParserFilter-FILTER_SKIP" name="FILTER_SKIP" type="short" value="3">
				<descr>
					<p>Skip this single node. The children of this node will still be considered.</p>
				</descr>
			</constant>
			<constant id="LS-LSParserFilter-FILTER_INTERRUPT" name="FILTER_INTERRUPT" type="short" value="4">
				<descr>
					<p>Interrupt the normal processing of the document.</p>
				</descr>
			</constant>
		</group>
		<method name="startElement" id="LS-LSParserFilter-startElement">
			<descr>
				<p>The parser will call this method after each<code>Element</code>start tag has been scanned, but before the remainder of the<code>Element</code>is processed. The intent is to allow the element, including any children, to be efficiently skipped. Note that only element nodes are passed to the<code>startElement</code>function.</p>
				<p>The element node passed to<code>startElement</code>for filtering will include all of the Element's attributes, but none of the children nodes. The Element may not yet be in place in the document being constructed (it may not have a parent node.)</p>
				<p>A<code>startElement</code>filter function may access or change the attributes for the Element. Changing Namespace declarations will have no effect on namespace resolution by the parser.</p>
				<p>For efficiency, the Element node passed to the filter may not be the same one as is actually placed in the tree if the node is accepted. And the actual node (node object identity) may be reused during the process of reading in and filtering a document.</p>
			</descr>
			<parameters>
				<param name="elementArg" type="Element" attr="in">
					<descr>
						<p>The newly encountered element. At the time this method is called, the element is incomplete - it will have its attributes, but no children.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<ulist>
						<item>
							<p>
								<code>FILTER_ACCEPT</code>if the<code>Element</code>should be included in the DOM document being built.</p>
						</item>
						<item>
							<p>
								<code>FILTER_REJECT</code>if the<code>Element</code>and all of its children should be rejected.</p>
						</item>
						<item>
							<p>
								<code>FILTER_SKIP</code>if the<code>Element</code>should be skipped. All of its children are inserted in place of the skipped<code>Element</code>node.</p>
						</item>
						<item>
							<p>
								<code>FILTER_INTERRUPT</code>if the filter wants to stop the processing of the document. Interrupting the processing of the document does no longer guarantee that the resulting DOM tree is<termref def="dt-well-formed">XML well-formed</termref>. The<code>Element</code>is rejected.</p>
						</item>
					</ulist>
					<p>Returning any other values will result in unspecified behavior.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="acceptNode" id="LS-LSParserFilter-acceptNode">
			<descr>
				<p>This method will be called by the parser at the completion of the parsing of each node. The node and all of its descendants will exist and be complete. The parent node will also exist, although it may be incomplete, i.e. it may have additional children that have not yet been parsed. Attribute nodes are never passed to this function.</p>
				<p>From within this method, the new node may be freely modified - children may be added or removed, text nodes modified, etc. The state of the rest of the document outside this node is not defined, and the affect of any attempt to navigate to, or to modify any other part of the document is undefined.</p>
				<p>For validating parsers, the checks are made on the original document, before any modification by the filter. No validity checks are made on any document modifications made by the filter.</p>
				<p>If this new node is rejected, the parser might reuse the new node and any of its descendants.</p>
			</descr>
			<parameters>
				<param name="nodeArg" type="Node" attr="in">
					<descr>
						<p>The newly constructed element. At the time this method is called, the element is complete - it has all of its children (and their children, recursively) and attributes, and is attached as a child to its parent.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<ulist>
						<item>
							<p>
								<code>FILTER_ACCEPT</code>if this<code>Node</code>should be included in the DOM document being built.</p>
						</item>
						<item>
							<p>
								<code>FILTER_REJECT</code>if the<code>Node</code>and all of its children should be rejected.</p>
						</item>
						<item>
							<p>
								<code>FILTER_SKIP</code>if the<code>Node</code>should be skipped and the<code>Node</code>should be replaced by all the children of the<code>Node</code>.</p>
						</item>
						<item>
							<p>
								<code>FILTER_INTERRUPT</code>if the filter wants to stop the processing of the document. Interrupting the processing of the document does no longer guarantee that the resulting DOM tree is<termref def="dt-well-formed">XML well-formed</termref>. The<code>Node</code>is accepted and will be the last completely parsed node.</p>
						</item>
					</ulist>
				</descr>
			</returns>
			<raises/>
		</method>
		<attribute type="unsigned long" readonly="yes" name="whatToShow" id="LS-LSParserFilter-whatToShow">
			<descr>
				<p>Tells the<code>LSParser</code>what types of nodes to show to the method<code>LSParserFilter.acceptNode</code>. If a node is not shown to the filter using this attribute, it is automatically included in the DOM document being built. See<code>NodeFilter</code>for definition of the constants. The constants<code>SHOW_ATTRIBUTE</code>,<code>SHOW_DOCUMENT</code>,<code>SHOW_DOCUMENT_TYPE</code>,<code>SHOW_NOTATION</code>,<code>SHOW_ENTITY</code>, and<code>SHOW_DOCUMENT_FRAGMENT</code>are meaningless here. Those nodes will never be passed to<code>LSParserFilter.acceptNode</code>.</p>
				<p>The constants used here are defined in<bibref ref="DOM2Traversal-Range"/>.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="LSProgressEvent" id="LS-LSProgressEvent" inherits="Event">
		<descr>
			<p>This interface represents a progress event object that notifies the application about progress as a document is parsed. It extends the<code>Event</code>interface defined in<bibref ref="DOMEvents" role="informative"/>.</p>
			<p>The units used for the attributes<code>position</code>and<code>totalSize</code>are not specified and can be implementation and input dependent.</p>
		</descr>
		<attribute type="LSInput" readonly="yes" name="input" id="LS-LSProgressEvent-input">
			<descr>
				<p>The input source that is being parsed.</p>
			</descr>
		</attribute>
		<attribute type="unsigned long" readonly="yes" name="position" id="LS-LSProgressEvent-position">
			<descr>
				<p>The current position in the input source, including all external entities and other resources that have been read.</p>
			</descr>
		</attribute>
		<attribute type="unsigned long" readonly="yes" name="totalSize" id="LS-LSProgressEvent-totalSize">
			<descr>
				<p>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen. A value of<code>0</code>is returned if the total size cannot be determined or estimated.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="LSLoadEvent" id="LS-LSLoadEvent" inherits="Event">
		<descr>
			<p>This interface represents a load event object that signals the completion of a document load.</p>
		</descr>
		<attribute type="Document" readonly="yes" name="newDocument" id="LS-LSLoadEvent-document">
			<descr>
				<p>The document that finished loading.</p>
			</descr>
		</attribute>
		<attribute type="LSInput" readonly="yes" name="input" id="LS-LSLoadEvent-input">
			<descr>
				<p>The input source that was parsed.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="LSSerializer" id="LS-LSSerializer">
		<descr>
			<p>A<code>LSSerializer</code>provides an API for serializing (writing) a DOM document out into XML. The XML data is written to a string or an output stream. Any changes or fixups made during the serialization affect only the serialized data. The<code>Document</code>object and its children are never altered by the serialization operation.</p>
			<p>During serialization of XML data, namespace fixup is done as defined in<bibref ref="DOMCore"/>, Appendix B.<bibref ref="DOM2Core"/>allows empty strings as a real namespace URI. If the<code>namespaceURI</code>of a<code>Node</code>is empty string, the serialization will treat them as<code>null</code>, ignoring the prefix if any.</p>
			<p>
				<code>LSSerializer</code>accepts any node type for serialization. For nodes of type<code>Document</code>or<code>Entity</code>, well-formed XML will be created when possible (well-formedness is guaranteed if the document or entity comes from a parse operation and is unchanged since it was created). The serialized output for these node types is either as a XML document or an External XML Entity, respectively, and is acceptable input for an XML parser. For all other types of nodes the serialized form is implementation dependent.</p>
			<p>Within a<code>Document</code>,<code>DocumentFragment</code>, or<code>Entity</code>being serialized,<code>Nodes</code>are processed as follows</p>
			<ulist>
				<item>
					<p>
						<code>Document</code>nodes are written, including the XML declaration (unless the parameter "<termref def="parameter-xml-declaration">xml-declaration</termref>" is set to<code>false</code>) and a DTD subset, if one exists in the DOM. Writing a<code>Document</code>node serializes the entire document.</p>
				</item>
				<item>
					<p>
						<code>Entity</code>nodes, when written directly by<code>LSSerializer.write</code>, outputs the entity expansion but no namespace fixup is done. The resulting output will be valid as an external entity.</p>
				</item>
				<item>
					<p>If the parameter "" is set to<code>true</code>,<code>EntityReference</code>nodes are serialized as an entity reference of the form "<code>&amp;entityName;</code>" in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter "" is set to<code>false</code>, only the children of the entity reference are serialized.<code>EntityReference</code>nodes with no children (no corresponding<code>Entity</code>node or the corresponding<code>Entity</code>nodes have no children) are always serialized.</p>
				</item>
				<item>
					<p>
						<code>CDATAsections</code>containing content characters that cannot be represented in the specified output encoding are handled according to the "" parameter.</p>
					<p>If the parameter is set to<code>true</code>,<code>CDATAsections</code>are split, and the unrepresentable characters are serialized as numeric character references in ordinary content. The exact position and number of splits is not specified.</p>
					<p>If the parameter is set to<code>false</code>, unrepresentable characters in a<code>CDATAsection</code>are reported as<code>"wf-invalid-character"</code>errors if the parameter "" is set to<code>true</code>. The error is not recoverable - there is no mechanism for supplying alternative characters and continuing with the serialization.</p>
				</item>
				<item>
					<p>
						<code>DocumentFragment</code>nodes are serialized by serializing the children of the document fragment in the order they appear in the document fragment.</p>
				</item>
				<item>
					<p>All other node types (Element, Text, etc.) are serialized to their corresponding XML source form.</p>
				</item>
			</ulist>
			<note>
				<p>The serialization of a<code>Node</code>does not always generate a<termref def="dt-well-formed">well-formed</termref>XML document, i.e. a<code>LSParser</code>might throw fatal errors when parsing the resulting serialization.</p>
			</note>
			<p>Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&lt;' and '&amp;' are replaced by the predefined entities &amp;lt; and &amp;amp;. The other predefined entities (&amp;gt;, &amp;apos;, and &amp;quot;) might not be used, except where needed (e.g. using &amp;gt; in cases such as ']]&gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</p>
			<p>To allow attribute values to contain both single and double quotes, the apostrophe or single-quote character (') may be represented as "&amp;apos;", and the double-quote character (")as "&amp;quot;". New line characters and other characters that cannot be represented directly in attribute values in the output character encoding are serialized as a numeric character reference.</p>
			<p>Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a<code>DOMError</code>fatal error. An example would be serializing the element &lt;LaCañada/&gt; with<code>encoding="us-ascii"</code>. This will result with a generation of a<code>DOMError</code>"wf-invalid-character-in-node-name" (as proposed in "").</p>
			<p>When requested by setting the parameter "" on<code>LSSerializer</code>to true, character normalization is performed according to the definition ofcharacters included in appendix E of<bibref ref="XML11"/>on all data to be serialized, both markup and character data. The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.</p>
			<p>Implementations are required to support the encodings "UTF-8", "UTF-16", "UTF-16BE", and "UTF-16LE" to guarantee that data is serializable in all encodings that are required to be supported by all XML parsers. When the encoding is UTF-8, whether or not a byte order mark is serialized, or if the output is big-endian or little-endian, is implementation dependent. When the encoding is UTF-16, whether or not the output is big-endian or little-endian is implementation dependent, but a Byte Order Mark must be generated for non-character outputs, such as<code>LSOutput.byteStream</code>or<code>LSOutput.systemId</code>. If the Byte Order Mark is not generated, a "byte-order-mark-needed" warning is reported. When the encoding is UTF-16LE or UTF-16BE, the output is big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark is not be generated. In all cases, the encoding declaration, if generated, will correspond to the encoding used during the serialization (e.g.<code>encoding="UTF-16"</code>will appear if UTF-16 was requested).</p>
			<p>Namespaces are fixed up during serialization, the serialization process will verify that namespace declarations, namespace prefixes and the namespace URI associated with elements and attributes are consistent. If inconsistencies are found, the serialized form of the document will be altered to remove them. The method used for doing the namespace fixup while serializing a document is the algorithm defined in Appendix B.1, "Namespace normalization", of<bibref ref="DOMCore"/>.</p>
			<p>While serializing a document, the parameter "<termref def="parameter-discard-default-content">discard-default-content</termref>" controls whether or not non-specified data is serialized.</p>
			<p>While serializing, errors and warnings are reported to the application through the error handler (<code>LSSerializer.domConfig</code>'s "" parameter). This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined. The types (<code>DOMError.type</code>) of errors and warnings defined by this specification are:<glist>
					<gitem>
						<label>
							<code>"no-output-specified" [fatal]</code>
						</label>
						<def>
							<p>Raised when writing to a<code>LSOutput</code>if no output is specified in the<code>LSOutput</code>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unbound-prefix-in-entity-reference" [fatal]</code>
						</label>
						<def>
							<p>Raised if the configuration parameter "" is set to<code>true</code>and an entity whose replacement text contains unbound namespace prefixes is referenced in a location where there are no bindings for the namespace prefixes.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"unsupported-encoding" [fatal]</code>
						</label>
						<def>
							<p>Raised if an unsupported encoding is encountered.</p>
						</def>
					</gitem>
				</glist>
			</p>
			<p>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...) and so on.</p>
		</descr>
		<attribute type="DOMConfiguration" readonly="yes" name="domConfig" id="LS-LSSerializer-config">
			<descr>
				<p>The<code>DOMConfiguration</code>object used by the<code>LSSerializer</code>when serializing a DOM node.</p>
				<p>In addition to the parameters recognized by theinterface defined in<bibref ref="DOMCore"/>, the<code>DOMConfiguration</code>objects for<code>LSSerializer</code>adds, or modifies, the following parameters:</p>
				<glist>
					<gitem>
						<label id="parameter-canonical-form">
							<code>"canonical-form"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Writes the document according to the rules specified in<bibref role="informative" ref="c14n"/>. In addition to the behavior described in ""<bibref ref="DOMCore"/>, setting this parameter to<code>true</code>will set the parameters "<termref def="parameter-format-pretty-print">format-pretty-print</termref>", "<termref def="parameter-discard-default-content">discard-default-content</termref>", and "<termref def="parameter-xml-declaration">xml-declaration</termref>", to<code>false</code>. Setting one of those parameters to<code>true</code>will set this parameter to<code>false</code>. Serializing an XML 1.1 document when "canonical-form" is<code>true</code>will generate a fatal error.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Do not canonicalize the output.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-discard-default-content">
							<code>"discard-default-content"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Use the<code>Attr.specified</code>attribute to decide what attributes should be discarded. Note that some implementations might use whatever information available to the implementation (i.e. XML schema, DTD, the<code>Attr.specified</code>attribute, and so on) to determine what attributes and content to discard if this parameter is set to<code>true</code>.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>]</p>
										<p>Keep all attributes and all content.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-format-pretty-print">
							<code>"format-pretty-print"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Formatting the output by adding whitespace to produce a pretty-printed, indented, human-readable form. The exact form of the transformations is not specified by this specification. Pretty-printing changes the content of the document and may affect the validity of the document, validating implementations should preserve validity.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>Don't pretty-print the result.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-ignore-unknown-character-denormalizations-lsserializer">
							<code>"ignore-unknown-character-denormalizations"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>If, while verifying full normalization when<bibref ref="XML11"/>is supported, a character is encountered for which the normalization properties cannot be determined, then raise a<code>"unknown-character-denormalization"</code>warning (instead of raising an error, if this parameter is not set) and ignore any possible denormalizations caused by these characters.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>optional</emph>]</p>
										<p>Report a fatal error if a character is encountered for which the processor cannot determine the normalization properties.</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-normalize-characters">
							<code>"normalize-characters"</code>
						</label>
						<def>
							<p>This parameter is equivalent to the one defined by<code>DOMConfiguration</code>in<bibref ref="DOMCore"/>. Unlike in the Core, the default value for this parameter is<code>true</code>. While DOM implementations are not required to supportthe characters in the document according to appendix E of<bibref ref="XML11"/>, this parameter must be activated by default if supported.</p>
						</def>
					</gitem>
					<gitem>
						<label id="parameter-xml-declaration">
							<code>"xml-declaration"</code>
						</label>
						<def>
							<glist>
								<gitem>
									<label>
										<code>true</code>
									</label>
									<def>
										<p>[<emph>required</emph>] (<emph>default</emph>)</p>
										<p>If a<code>Document</code>,<code>Element</code>, or<code>Entity</code>node is serialized, the XML declaration, or text declaration, should be included. The version (<code>Document.xmlVersion</code>if the document is a Level 3 document and the version is non-null, otherwise use the value "1.0"), and the output encoding (see<code>LSSerializer.write</code>for details on how to find the output encoding) are specified in the serialized XML declaration.</p>
									</def>
								</gitem>
								<gitem>
									<label>
										<code>false</code>
									</label>
									<def>
										<p>[<emph>required</emph>]</p>
										<p>Do not serialize the XML and text declarations. Report a<code>"xml-declaration-needed"</code>warning if this will cause problems (i.e. the serialized data is of an XML version other than<bibref ref="XML"/>, or an encoding would be needed to be able to re-parse the serialized data).</p>
									</def>
								</gitem>
							</glist>
						</def>
					</gitem>
				</glist>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="newLine" id="LS-LSSerializer-newLine">
			<descr>
				<p>The end-of-line sequence of characters to be used in the XML being written out. Any string is supported, but XML treats only a certain set of characters sequence as end-of-line (See section 2.11, "End-of-Line Handling" in<bibref ref="XML"/>, if the serialized content is XML 1.0 or section 2.11, "End-of-Line Handling" in<bibref ref="XML11"/>, if the serialized content is XML 1.1). Using other character sequences than the recommended ones can result in a document that is either not serializable or not well-formed).</p>
				<p>On retrieval, the default value of this attribute is the implementation specific default end-of-line sequence. DOM implementations should choose the default to match the usual convention for text files in the environment being used. Implementations must choose a default sequence that matches one of those allowed by XML 1.0 or XML 1.1, depending on the serialized content. Setting this attribute to<code>null</code>will reset its value to the default value.</p>
				<p/>
			</descr>
		</attribute>
		<attribute type="LSSerializerFilter" readonly="no" name="filter" id="LS-LSSerializer-LSSerializerFilter">
			<descr>
				<p>When the application provides a filter, the serializer will call out to the filter before serializing each Node. The filter implementation can choose to remove the node from the stream or to terminate the serialization early.</p>
				<p>The filter is invoked after the operations requested by the<code>DOMConfiguration</code>parameters have been applied. For example, CDATA sections won't be passed to the filter if "" is set to<code>false</code>.</p>
			</descr>
		</attribute>
		<method name="write" id="LS-LSSerializer-write">
			<descr>
				<p>Serialize the specified node as described above in the general description of the<code>LSSerializer</code>interface. The output is written to the supplied<code>LSOutput</code>.</p>
				<p>When writing to a<code>LSOutput</code>, the encoding is found by looking at the encoding information that is reachable through the<code>LSOutput</code>and the item to be written (or its owner document) in this order:</p>
				<olist>
					<item>
						<p>
							<code>LSOutput.encoding</code>,</p>
					</item>
					<item>
						<p>
							<code>Document.inputEncoding</code>,</p>
					</item>
					<item>
						<p>
							<code>Document.xmlEncoding</code>.</p>
					</item>
				</olist>
				<p>If no encoding is reachable through the above properties, a default encoding of "UTF-8" will be used. If the specified encoding is not supported an "unsupported-encoding" fatal error is raised.</p>
				<p>If no output is specified in the<code>LSOutput</code>, a "no-output-specified" fatal error is raised.</p>
				<p>The implementation is responsible of associating the appropriate media type with the serialized data.</p>
				<p>When writing to a HTTP URI, a HTTP PUT is performed. When writing to other types of URIs, the mechanism for writing the data to the URI is implementation dependent.</p>
			</descr>
			<parameters>
				<param name="nodeArg" type="Node" attr="in">
					<descr>
						<p>The node to serialize.</p>
					</descr>
				</param>
				<param name="destination" type="LSOutput" attr="in">
					<descr>
						<p>The destination for the serialized DOM.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if<code>node</code>was successfully serialized. Return<code>false</code>in case the normal processing stopped but the implementation kept serializing the document; the result of the serialization being implementation dependent then.</p>
				</descr>
			</returns>
			<raises>
				<exception name="LSException">
					<descr>
						<p>SERIALIZE_ERR: Raised if the<code>LSSerializer</code>was unable to serialize the node. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="writeToURI" id="LS-LSSerializer-writeToURI">
			<descr>
				<p>A convenience method that acts as if<code>LSSerializer.write</code>was called with a<code>LSOutput</code>with no encoding specified and<code>LSOutput.systemId</code>set to the<code>uri</code>argument.</p>
			</descr>
			<parameters>
				<param name="nodeArg" type="Node" attr="in">
					<descr>
						<p>The node to serialize.</p>
					</descr>
				</param>
				<param name="uri" type="DOMString" attr="in">
					<descr>
						<p>The URI to write to.</p>
					</descr>
				</param>
			</parameters>
			<returns type="boolean">
				<descr>
					<p>Returns<code>true</code>if<code>node</code>was successfully serialized. Return<code>false</code>in case the normal processing stopped but the implementation kept serializing the document; the result of the serialization being implementation dependent then.</p>
				</descr>
			</returns>
			<raises>
				<exception name="LSException">
					<descr>
						<p>SERIALIZE_ERR: Raised if the<code>LSSerializer</code>was unable to serialize the node. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="writeToString" id="LS-LSSerializer-writeToString">
			<descr>
				<p>Serialize the specified node as described above in the general description of the<code>LSSerializer</code>interface. The output is written to a<code>DOMString</code>that is returned to the caller. The encoding used is the encoding of the<code>DOMString</code>type, i.e. UTF-16. Note that no Byte Order Mark is generated in a<code>DOMString</code>object.</p>
			</descr>
			<parameters>
				<param name="nodeArg" type="Node" attr="in">
					<descr>
						<p>The node to serialize.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>Returns the serialized data.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>DOMSTRING_SIZE_ERR: Raised if the resulting string is too long to fit in a<code>DOMString</code>.</p>
					</descr>
				</exception>
				<exception name="LSException">
					<descr>
						<p>SERIALIZE_ERR: Raised if the<code>LSSerializer</code>was unable to serialize the node. DOM applications should attach a<code>DOMErrorHandler</code>using the parameter "" if they wish to get details on the error.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="LSOutput" id="LS-LSOutput">
		<descr>
			<p>This interface represents an output destination for data.</p>
			<p>This interface allows an application to encapsulate information about an output destination in a single object, which may include a URI, a byte stream (possibly with a specified encoding), a base URI, and/or a character stream.</p>
			<p>The exact definitions of a byte stream and a character stream are binding dependent.</p>
			<p>The application is expected to provide objects that implement this interface whenever such objects are needed. The application can either provide its own objects that implement this interface, or it can use the generic factory method<code>DOMImplementationLS.createLSOutput()</code>to create objects that implement this interface.</p>
			<p>The<code>LSSerializer</code>will use the<code>LSOutput</code>object to determine where to serialize the output to. The<code>LSSerializer</code>will look at the different outputs specified in the<code>LSOutput</code>in the following order to know which one to output to, the first one that is not null and not an empty string will be used:<olist>
					<item>
						<p>
							<code>LSOutput.characterStream</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSOutput.byteStream</code>
						</p>
					</item>
					<item>
						<p>
							<code>LSOutput.systemId</code>
						</p>
					</item>
				</olist>
			</p>
			<p>
				<code>LSOutput</code>objects belong to the application. The DOM implementation will never modify them (though it may make copies and modify the copies, if necessary).</p>
		</descr>
		<attribute type="LSWriter" readonly="no" name="characterStream" id="LS-LSOutput-characterStream" role="java-only">
			<descr>
				<p>An attribute of a language and binding dependent type that represents a writable stream to which<termref def="dt-16-bit-unit">16-bit units</termref>can be output.</p>
			</descr>
		</attribute>
		<attribute type="LSOutputStream" readonly="no" name="byteStream" id="LS-LSOutput-byteStream">
			<descr>
				<p>An attribute of a language and binding dependent type that represents a writable stream of bytes.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="systemId" id="LS-LSOutput-systemId">
			<descr>
				<p>The system identifier, a URI reference<bibref ref="URIRef"/>, for this output destination.</p>
				<p>If the system ID is a relative URI reference (see section 5 in<bibref ref="URIRef"/>), the behavior is implementation dependent.</p>
			</descr>
		</attribute>
		<attribute type="DOMString" readonly="no" name="encoding" id="LS-LSOutput-encoding">
			<descr>
				<p>The character encoding to use for the output. The encoding must be a string acceptable for an XML encoding declaration (<bibref ref="XML"/>section 4.3.3 "Character Encoding in Entities"), it is recommended that character encodings registered (as charsets) with the Internet Assigned Numbers Authority<bibref ref="IANA-CHARSETS"/>should be referred to using their registered names.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="LSSerializerFilter" inherits="NodeFilter" id="LS-LSSerializerFilter">
		<descr>
			<p>
				<code>LSSerializerFilter</code>s provide applications the ability to examine nodes as they are being serialized and decide what nodes should be serialized or not. The<code>LSSerializerFilter</code>interface is based on the<code>NodeFilter</code>interface defined in<bibref ref="DOM2Traversal-Range"/>.</p>
			<p>
				<code>Document</code>,<code>DocumentType</code>,<code>DocumentFragment</code>,<code>Notation</code>,<code>Entity</code>, and children of<code>Attr</code>nodes are not passed to the filter. The child nodes of an<code>EntityReference</code>node are only passed to the filter if the<code>EntityReference</code>node is skipped by the method<code>LSParserFilter.acceptNode()</code>.</p>
			<p>When serializing an<code>Element</code>, the element is passed to the filter before any of its attributes are passed to the filter. Namespace declaration attributes, and default attributes (except in the case when "<termref def="parameter-discard-default-content">discard-default-content</termref>" is set to<code>false</code>), are never passed to the filter.</p>
			<p>The result of any attempt to modify a node passed to a<code>LSSerializerFilter</code>is implementation dependent.</p>
			<p>DOM applications must not raise exceptions in a filter. The effect of throwing exceptions from a filter is DOM implementation dependent.</p>
			<p>For efficiency, a node passed to the filter may not be the same as the one that is actually in the tree. And the actual node (node object identity) may be reused during the process of filtering and serializing a document.</p>
		</descr>
		<attribute type="unsigned long" readonly="yes" name="whatToShow" id="LS-LSSerializerFilter-whatToShow">
			<descr>
				<p>Tells the<code>LSSerializer</code>what types of nodes to show to the filter. If a node is not shown to the filter using this attribute, it is automatically serialized. See<code>NodeFilter</code>for definition of the constants. The constants<code>SHOW_DOCUMENT</code>,<code>SHOW_DOCUMENT_TYPE</code>,<code>SHOW_DOCUMENT_FRAGMENT</code>,<code>SHOW_NOTATION</code>, and<code>SHOW_ENTITY</code>are meaningless here, such nodes will never be passed to a<code>LSSerializerFilter</code>.</p>
				<p>Unlike<bibref ref="DOM2Traversal-Range"/>, the<code>SHOW_ATTRIBUTE</code>constant indicates that the<code>Attr</code>nodes are shown and passed to the filter.</p>
				<p>The constants used here are defined in<bibref ref="DOM2Traversal-Range"/>.</p>
			</descr>
		</attribute>
	</interface>
	<exception id="ExceptionVAL" name="ExceptionVAL">
		<descr>
			<p>Some Validation operations may throw an<code>ExceptionVAL</code>as described in their descriptions.</p>
		</descr>
		<component id="ExceptionVAL-code" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="ExceptionVAL-codes" name="ExceptionVALCode">
		<descr>
			<p>An integer indicating the type of error generated.</p>
		</descr>
		<constant id="ExceptionVAL-NO_SCHEMA_AVAILABLE_ERR" name="NO_SCHEMA_AVAILABLE_ERR" type="unsigned short" value="71">
			<descr>
				<p>This error occurs when the operation cannot complete due to an unavailable<termref def="dt-schema">schema</termref>.</p>
			</descr>
		</constant>
	</group>
	<interface name="DocumentEditVAL" inherits="NodeEditVAL" id="VAL-Interfaces-DocumentEditVAL">
		<descr>
			<p>This interface extends the<code>NodeEditVAL</code>interface with additional methods for document editing. An object implementing this interface must also implement the<code>Document</code>interface.</p>
		</descr>
		<attribute name="continuousValidityChecking" type="boolean" id="DocumentEditVAL-continuousValidityChecking" readonly="no">
			<descr>
				<p>An attribute specifying whether the validity of the document is continuously enforced. When the attribute is set to<code>true</code>, the implementation may raise certain exceptions, depending on the situation (see the following). This attribute is<code>false</code>by default.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the implementation does not support setting this attribute to<code>true</code>.</p>
					</descr>
				</exception>
				<exception name="ExceptionVAL">
					<descr>
						<p>NO_SCHEMA_AVAILABLE_ERR: Raised if this attribute is set to<code>true</code>and a schema is unavailable.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>VALIDATION_ERR: Raised if an operation makes this document not compliant with the<code>VAL_INCOMPLETE</code>validity type or the document is invalid, and this attribute is set to<code>true</code>.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<attribute name="domConfig" type="DOMConfiguration" readonly="yes" id="DocumentEditVAL-domConfig">
			<descr>
				<p>This allows the setting of the error handler, as described in the<bibref ref="DOMCore"/>
					<code>DOMConfiguration</code>interface. An object implementing this<code>DocumentEditVAL</code>interface and the<bibref ref="DOMCore"/>
					<code>Document</code>interface, which also has a<code>domConfig</code>attribute, needs to only implement this attribute once.</p>
			</descr>
		</attribute>
		<method name="getDefinedElements" id="DocumentEditVAL-getDefinedElements">
			<descr>
				<p>Returns list of all element information item names of<termref def="dt-global-declaration">global declaration</termref>, belonging to the specified namespace.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="namespaceURI">
					<descr>
						<p>
							<code>namespaceURI</code>of namespace. For DTDs, this is<code>null</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NameList">
				<descr>
					<p>List of all element information item names belonging to the specified namespace or<code>null</code>if no schema is available.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="validateDocument" id="VAL-Interfaces-DocumentEditVAL-validateDocument">
			<descr>
				<p>Validates the document against the schema, e.g., a DTD or an W3C XML schema or another. Any attempt to modify any part of the document while validating results in implementation-dependent behavior. In addition, the validation operation itself cannot modify the document, e.g., for default attributes. This method makes use of the error handler, as described in the<bibref ref="DOMCore"/>
					<code>DOMConfiguration</code>interface, with all errors being<code>SEVERITY_ERROR</code>as defined in the<code>DOMError</code>interface.</p>
			</descr>
			<parameters/>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="NodeEditVAL" id="VAL-Interfaces-NodeEditVAL">
		<descr>
			<p>This interface is similar to the<bibref ref="DOMCore"/>
				<code>Node</code>interface, with methods for guided document editing.</p>
		</descr>
		<group name="validationType" id="NodeEditVAL-validationType">
			<descr>
				<p>An integer indicating the validation type. Other specifications can define stricter validation types/constants by extending the<code>NodeEditVAL</code>interface.</p>
			</descr>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_WF" name="VAL_WF" type="unsigned short" value="1">
				<descr>
					<p>Check if the node is<termref def="dt-well-formed">well-formed</termref>.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_NS_WF" name="VAL_NS_WF" type="unsigned short" value="2">
				<descr>
					<p>Check if the node is<termref def="dt-namespace-well-formed">namespace well-formed</termref>.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_INCOMPLETE" name="VAL_INCOMPLETE" type="unsigned short" value="3">
				<descr>
					<p>Check if the node's immediate children are those expected by the content model. This node's trailing required children could be missing. It includes<code>VAL_NS_WF</code>.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_SCHEMA" name="VAL_SCHEMA" type="unsigned short" value="4">
				<descr>
					<p>Check if the node's entire subtree are those expected by the content model. It includes<code>VAL_NS_WF</code>.</p>
				</descr>
			</constant>
		</group>
		<group name="validationState" id="NodeEditVAL-validationState">
			<descr>
				<p>An integer indicating the validation state, or whether the operation can or cannot be done.</p>
			</descr>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_TRUE" name="VAL_TRUE" type="unsigned short" value="5">
				<descr>
					<p>True if the node is valid with regards to the operation, or if the operation can be done.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_FALSE" name="VAL_FALSE" type="unsigned short" value="6">
				<descr>
					<p>False if the node is invalid with regards to the operation, or if the operation cannot be done.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-NodeEditVAL-VAL_UNKNOWN" name="VAL_UNKNOWN" type="unsigned short" value="7">
				<descr>
					<p>The validity of the node is unknown.</p>
				</descr>
			</constant>
		</group>
		<attribute name="defaultValue" type="DOMString" readonly="yes" id="NodeEditVAL-defaultValue">
			<descr>
				<p>The default value specified in an attribute or an element declaration or<code>null</code>if unspecified. If the schema is a W3C XML schema, this is the canonical lexical representation of the default value.</p>
			</descr>
		</attribute>
		<attribute name="enumeratedValues" type="DOMStringList" readonly="yes" id="NodeEditVAL-enumeratedValues">
			<descr>
				<p>A<code>DOMStringList</code>, as described in<bibref ref="DOMCore"/>, of distinct values for an attribute or an element declaration or<code>null</code>if unspecified. If the schema is a W3C XML schema, this is a list of strings which are lexical representations corresponding to the values in the [value] property of the enumeration component for the type of the attribute or element. It is recommended that the canonical lexical representations of the values be used.</p>
			</descr>
		</attribute>
		<method name="canInsertBefore" id="VAL-Interfaces-NodeEditVAL-canInsertBefore">
			<descr>
				<p>Determines whether the<code>Node.insertBefore</code>operation would make this document not compliant with the<code>VAL_INCOMPLETE</code>validity type.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="newChild">
					<descr>
						<p>
							<code>Node</code>to be inserted.</p>
					</descr>
				</param>
				<param attr="in" type="Node" name="refChild">
					<descr>
						<p>Reference<code>Node</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canRemoveChild" id="VAL-Interfaces-NodeEditVAL-canRemoveChild">
			<descr>
				<p>Determines whether the<code>Node.removeChild</code>operation would make this document not compliant with the<code>VAL_INCOMPLETE</code>validity type.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="oldChild">
					<descr>
						<p>
							<code>Node</code>to be removed.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canReplaceChild" id="VAL-Interfaces-NodeEditVAL-canReplaceChild">
			<descr>
				<p>Determines whether the<code>Node.replaceChild</code>operation would make this document not compliant with the<code>VAL_INCOMPLETE</code>validity type.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="newChild">
					<descr>
						<p>New<code>Node</code>.</p>
					</descr>
				</param>
				<param attr="in" type="Node" name="oldChild">
					<descr>
						<p>
							<code>Node</code>to be replaced.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canAppendChild" id="VAL-Interfaces-NodeEditVAL-canAppendChild">
			<descr>
				<p>Determines whether the<code>Node.appendChild</code>operation would make this document not compliant with the<code>VAL_INCOMPLETE</code>validity type.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="newChild">
					<descr>
						<p>
							<code>Node</code>to be appended.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="nodeValidity" id="NodeEditVAL-nodeValidity">
			<descr>
				<p>Determines if the node is valid relative to thespecified in<code>valType</code>. This operation doesn't normalize before checking if it is valid. To do so, one would need to explicitly call a normalize method. The difference between this method and themethod is that the latter method only checks to determine whether the entire document is valid.</p>
			</descr>
			<parameters>
				<param name="valType" type="unsigned short" attr="in">
					<descr>
						<p>Flag to indicate thechecking to be done.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="ElementEditVAL" inherits="NodeEditVAL" id="VAL-Interfaces-ElementEditVAL">
		<descr>
			<p>This interface extends the<code>NodeEditVAL</code>interface with additional methods for guided document editing. An object implementing this interface must also implement the<code>Element</code>interface.</p>
			<p id="Level-3-VAL-Wildcards">This interface also has attributes that are a<code>NameList</code>of elements or attributes which can appear in the specified context. Some schema languages, i.e.,, define wildcards which provide for validation of attribute and element information items dependent on their namespace names but independent of their local names.</p>
			<p>To expose wildcards, the<code>NameList</code>returns the values that represent the:</p>
			<ulist>
				<item>
					<p>
						<code>{namespaceURI, name}</code>is<code>{null, ##any}</code>if<emph>any</emph>;</p>
				</item>
				<item>
					<p>
						<code>{namespaceURI, name}</code>is<code>{namespace_a, ##other}</code>if<emph>not and a namespace name (namespace_a)</emph>;</p>
				</item>
				<item>
					<p>
						<code>{namespaceURI, name}</code>is<code>{null, ##other}</code>if<emph>not and absent</emph>;</p>
				</item>
				<item>
					<p>Pairs of<code>{namespaceURI, name}</code>with values<code>{a_namespaceURI | null, null}</code>if<emph>a set whose members are either namespace names or absent</emph>.</p>
				</item>
			</ulist>
		</descr>
		<group name="ContentTypeVAL" id="ElementEditVAL-ContentTypeVAL">
			<descr>
				<p>An integer indicating the content type of an element.</p>
			</descr>
			<constant id="VAL-Interfaces-ElementEditVAL-VAL_EMPTY_CONTENTTYPE" name="VAL_EMPTY_CONTENTTYPE" type="unsigned short" value="1">
				<descr>
					<p>The content model does not allow any. If the schema is a W3C XML schema, this corresponds to the<code>empty</code>content type; and if the schema is a DTD, this corresponds to the<code>EMPTY</code>content model.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-ElementEditVAL-VAL_ANY_CONTENTTYPE" name="VAL_ANY_CONTENTTYPE" type="unsigned short" value="2">
				<descr>
					<p>The content model contains unordered child information item(s), i.e., element, processing instruction, unexpanded entity reference, character, and comment information items as defined in the. If the schema is a DTD, this corresponds to the<code>ANY</code>content model.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-ElementEditVAL-VAL_MIXED_CONTENTTYPE" name="VAL_MIXED_CONTENTTYPE" type="unsigned short" value="3">
				<descr>
					<p>The content model contains a sequence of orderedoptionally interspersed with character data. If the schema is a W3C XML schema, this corresponds to the<code>mixed</code>content type.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-ElementEditVAL-VAL_ELEMENTS_CONTENTTYPE" name="VAL_ELEMENTS_CONTENTTYPE" type="unsigned short" value="4">
				<descr>
					<p>The content model contains a sequence ofoptionally separated by whitespace. If the schema is a DTD, this is the<code>element content</code>content model; and if the schema is a W3C XML schema, this is the<code>element-only</code>content type.</p>
				</descr>
			</constant>
			<constant id="VAL-Interfaces-ElementEditVAL-VAL_SIMPLE_CONTENTTYPE" name="VAL_SIMPLE_CONTENTTYPE" type="unsigned short" value="5">
				<descr>
					<p>The content model contains. If the schema is a W3C XML schema, then the element has a content type of<code>VAL_SIMPLE_CONTENTTYPE</code>if the type of the element is a<code>simple type definition</code>, or the type of the element is a<code>complexType</code>whose<code>{content type}</code>is a<code>simple type definition</code>.</p>
				</descr>
			</constant>
		</group>
		<attribute name="allowedChildren" type="NameList" readonly="yes" id="ElementEditVAL-allowedChildren">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all possible element information items orthat can appear as children of this element, or<code>null</code>if this element has no context or schema. Duplicate pairs of {namespaceURI, name} are eliminated.</p>
			</descr>
		</attribute>
		<attribute name="allowedFirstChildren" type="NameList" readonly="yes" id="ElementEditVAL-allowedFirstChildren">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all possible element information items orthat can appear as a first child of this element, or<code>null</code>if this element has no context or schema. Duplicate pairs of {namespaceURI, name} are eliminated.</p>
			</descr>
		</attribute>
		<attribute name="allowedParents" type="NameList" readonly="yes" id="ElementEditVAL-allowedParents">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all possible element information items that can appear as a parent this element, or<code>null</code>if this element has no context or schema.</p>
			</descr>
		</attribute>
		<attribute name="allowedNextSiblings" type="NameList" readonly="yes" id="ElementEditVAL-allowedNextSiblings">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all element information items orthat can be inserted as a next sibling of this element, or<code>null</code>if this element has no context or schema. Duplicate pairs of {namespaceURI, name} are eliminated.</p>
			</descr>
		</attribute>
		<attribute name="allowedPreviousSiblings" type="NameList" readonly="yes" id="ElementEditVAL-allowedPreviousSiblings">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all element information items orthat can be inserted as a previous sibling of this element, or<code>null</code>if this element has no context or schema.</p>
			</descr>
		</attribute>
		<attribute name="allowedAttributes" type="NameList" readonly="yes" id="ElementEditVAL-allowedAttributes">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of all possible attribute information items orthat can appear as attributes of this element, or<code>null</code>if this element has no context or schema. Duplicate pairs of {namespaceURI, name} are eliminated.</p>
			</descr>
		</attribute>
		<attribute name="requiredAttributes" type="NameList" readonly="yes" id="ElementEditVAL-requiredAttributes">
			<descr>
				<p>A<code>NameList</code>, as described in<bibref ref="DOMCore"/>, of required attribute information items that must appear on this element, or<code>null</code>if this element has no context or schema.</p>
			</descr>
		</attribute>
		<attribute name="contentType" type="unsigned short" readonly="yes" id="VAL-Interfaces-ElementEditVAL-ElementEditVAL-contentType">
			<descr>
				<p>The content type of an element as defined.</p>
			</descr>
		</attribute>
		<method name="canSetTextContent" id="VAL-Interfaces-ElementEditVAL-canSetTextContent">
			<descr>
				<p>Determines if the text content of this node and its descendants can be set to the string passed in.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="possibleTextContent">
					<descr>
						<p>Possible text content string.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canSetAttribute" id="VAL-Interfaces-ElementEditVAL-ElementEditVAL-canSetAttribute">
			<descr>
				<p>Determines if the value for specified attribute can be set.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="attrname">
					<descr>
						<p>Name of attribute.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="attrval">
					<descr>
						<p>Value to be assigned to the attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canSetAttributeNode" id="VAL-Interfaces-ElementEditVAL-canSetAttributeNode">
			<descr>
				<p>Determines if an attribute node can be added.</p>
			</descr>
			<parameters>
				<param attr="in" type="Attr" name="attrNode">
					<descr>
						<p>
							<code>Node</code>in which the attribute can possibly be set.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canSetAttributeNS" id="VAL-Interfaces-ElementEditVAL-canSetAttributeNS">
			<descr>
				<p>Determines if the attribute with given namespace and qualified name can be created if not already present in the attribute list of the element. If the attribute with the same qualified name and namespaceURI is already present in the element's attribute list, it tests whether the value of the attribute and its prefix can be set to the new value.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="namespaceURI">
					<descr>
						<p>
							<code>namespaceURI</code>of namespace.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="qualifiedName">
					<descr>
						<p>Qualified name of attribute.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="value">
					<descr>
						<p>Value to be assigned to the attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canRemoveAttribute" id="VAL-Interfaces-ElementEditVAL-canRemoveAttribute">
			<descr>
				<p>Verifies if an attribute by the given name can be removed.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="attrname">
					<descr>
						<p>Name of attribute.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canRemoveAttributeNS" id="VAL-Interfaces-ElementEditVAL-canRemoveAttributeNS">
			<descr>
				<p>Verifies if an attribute by the given local name and namespace can be removed.</p>
			</descr>
			<parameters>
				<param name="namespaceURI" type="DOMString" attr="in">
					<descr>
						<p>The namespace URI of the attribute to remove.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="localName">
					<descr>
						<p>Local name of the attribute to be removed.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canRemoveAttributeNode" id="VAL-Interfaces-ElementEditVAL-canRemoveAttributeNode">
			<descr>
				<p>Determines if an attribute node can be removed.</p>
			</descr>
			<parameters>
				<param attr="in" type="Node" name="attrNode">
					<descr>
						<p>The<code>Attr</code>node to remove from the attribute list.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isElementDefined" id="VAL-Interfaces-ElementEditVAL-isElementDefined">
			<descr>
				<p>Determines if<code>name</code>is defined in the schema. This only applies to<termref def="dt-global-declaration">global declarations</termref>. This method is for non-namespace aware schemas.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="name">
					<descr>
						<p>Name of element.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="isElementDefinedNS" id="VAL-Interfaces-ElementEditVAL-isElementDefinedNS">
			<descr>
				<p>Determines if<code>name</code>in this namespace is defined in the current context. Thus not only does this apply to<termref def="dt-global-declaration">global declarations</termref>. but depending on the content, this may also apply to local definitions. This method is for namespace aware schemas.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="namespaceURI">
					<descr>
						<p>
							<code>namespaceURI</code>of namespace.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="name">
					<descr>
						<p>Name of element.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="CharacterDataEditVAL" inherits="NodeEditVAL" id="VAL-Interfaces-CharacterDataEditVAL">
		<descr>
			<p>This interface extends the<code>NodeEditVAL</code>interface with additional methods for document editing. An object implementing this interface must also implement<code>CharacterData</code>interface. When validating<code>CharacterData</code>nodes, theoperation must find the nearest parent node in order to do this; if no parent node is found,is returned. In addition, whenis passed in as an argument to the<code>NodeEditVAL.nodeValidity</code>operation to operate on such nodes, the operation considers all the text and not just some of it.</p>
		</descr>
		<method name="isWhitespaceOnly" id="VAL-Interfaces-CharacterDataEditVAL-isWhitespaceOnly">
			<descr>
				<p>Determines if character data is only whitespace.</p>
			</descr>
			<parameters/>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canSetData" id="VAL-Interfaces-CharacterDataEditVAL-canSetData">
			<descr>
				<p>Determines if character data can be set.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="arg">
					<descr>
						<p>Argument to be set.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canAppendData" id="VAL-Interfaces-CharacterDataEditVAL-canAppendData">
			<descr>
				<p>Determines if character data can be appended.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="arg">
					<descr>
						<p>Data to be appended.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="canReplaceData" id="VAL-Interfaces-CharacterDataEditVAL-canReplaceData">
			<descr>
				<p>Determines if character data can be replaced.</p>
			</descr>
			<parameters>
				<param attr="in" type="unsigned long" name="offset">
					<descr>
						<p>Offset.</p>
					</descr>
				</param>
				<param attr="in" type="unsigned long" name="count">
					<descr>
						<p>Replacement.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="arg">
					<descr>
						<p>Argument to be set.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in data, or if the specified count is negative.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="canInsertData" id="VAL-Interfaces-CharacterDataEditVAL-canInsertData">
			<descr>
				<p>Determines if character data can be inserted.</p>
			</descr>
			<parameters>
				<param attr="in" type="unsigned long" name="offset">
					<descr>
						<p>Offset.</p>
					</descr>
				</param>
				<param attr="in" type="DOMString" name="arg">
					<descr>
						<p>Argument to be set.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in data.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="canDeleteData" id="VAL-Interfaces-CharacterDataEditVAL-canDeleteData">
			<descr>
				<p>Determines if character data can be deleted.</p>
			</descr>
			<parameters>
				<param attr="in" type="unsigned long" name="offset">
					<descr>
						<p>Offset.</p>
					</descr>
				</param>
				<param attr="in" type="unsigned long" name="count">
					<descr>
						<p>Number of 16-bit units to delete.</p>
					</descr>
				</param>
			</parameters>
			<returns type="unsigned short">
				<descr>
					<p>Aconstant.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in data, or if the specified count is negative.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<exception id="XPathException" name="XPathException">
		<descr>
			<p>A new exception has been created for exceptions specific to these XPath interfaces.</p>
		</descr>
		<component id="XPathException-code" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="XPathExceptionCode" name="XPathExceptionCode">
		<descr/>
		<constant id="INVALID_EXPRESSION_ERR" name="INVALID_EXPRESSION_ERR" type="unsigned short" value="51">
			<descr>
				<p>If the expression has a syntax error or otherwise is not a legal expression according to the rules of the specific<code>XPathEvaluator</code>or contains specialized extension functions or variables not supported by this implementation.</p>
			</descr>
		</constant>
		<constant id="TYPE_ERR" name="TYPE_ERR" type="unsigned short" value="52">
			<descr>
				<p>If the expression cannot be converted to return the specified type.</p>
			</descr>
		</constant>
	</group>
	<interface id="XPathEvaluator" name="XPathEvaluator">
		<descr>
			<p>The evaluation of XPath expressions is provided by<code>XPathEvaluator</code>. In a DOM implementation which supports the XPath 3.0 feature, as described above, the<code>XPathEvaluator</code>interface will be implemented on the same object which implements the<code>Document</code>interface permitting it to be obtained by the usual binding-specific method such as casting or by using the DOM Level 3 getInterface method. In this case the implementation obtained from the Document supports the XPath DOM module and is compatible with the XPath 1.0 specification.</p>
			<p>Evaluation of expressions with specialized extension functions or variables may not work in all implementations and is, therefore, not portable.<code>XPathEvaluator</code>implementations may be available from other sources that could provide specific support for specialized extension functions or variables as would be defined by other specifications.</p>
		</descr>
		<method id="XPathEvaluator-createExpression" name="createExpression">
			<descr>
				<p>Creates a parsed XPath expression with resolved namespaces. This is useful when an expression will be reused in an application since it makes it possible to compile the expression string into a more efficient internal form and preresolve all<termref def="dt-namespaceprefix">namespace prefixes</termref>which occur within the expression.</p>
			</descr>
			<parameters>
				<param attr="in" name="expression" type="DOMString">
					<descr>
						<p>The XPath expression string to be parsed.</p>
					</descr>
				</param>
				<param attr="in" name="resolver" type="XPathNSResolver">
					<descr>
						<p>The<code>resolver</code>permits translation of all prefixes, including the<code>xml</code>namespace prefix, within the XPath expression into appropriate<termref def="dt-namespaceURI">namespace URIs</termref>. If this is specified as<code>null</code>, any<termref def="dt-namespaceprefix">namespace prefix</termref>within the expression will result in<code>DOMException</code>being thrown with the code<code>NAMESPACE_ERR</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="XPathExpression">
				<descr>
					<p>The compiled form of the XPath expression.</p>
				</descr>
			</returns>
			<raises>
				<exception name="XPathException">
					<descr>
						<p>INVALID_EXPRESSION_ERR: Raised if the expression is not legal according to the rules of the<code>XPathEvaluator</code>.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>NAMESPACE_ERR: Raised if the expression contains<termref def="dt-namespaceprefix">namespace prefixes</termref>which cannot be resolved by the specified<code>XPathNSResolver</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method id="XPathEvaluator-createNSResolver" name="createNSResolver">
			<descr>
				<p>Adapts any DOM node to resolve namespaces so that an XPath expression can be easily evaluated relative to the context of the node where it appeared within the document. This adapter works like the DOM Level 3 method<code>lookupNamespaceURI</code>on nodes in resolving the namespaceURI from a given prefix using the current information available in the node's hierarchy at the time lookupNamespaceURI is called. also correctly resolving the implicit xml prefix.</p>
			</descr>
			<parameters>
				<param attr="in" name="nodeResolver" type="Node">
					<descr>
						<p>The node to be used as a context for namespace resolution.</p>
					</descr>
				</param>
			</parameters>
			<returns type="XPathNSResolver">
				<descr>
					<p>
						<code>XPathNSResolver</code>which resolves namespaces with respect to the definitions in scope for a specified node.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method id="XPathEvaluator-evaluate" name="evaluate">
			<descr>
				<p>Evaluates an XPath expression string and returns a result of the specified type if possible.</p>
			</descr>
			<parameters>
				<param attr="in" name="expression" type="DOMString">
					<descr>
						<p>The XPath expression string to be parsed and evaluated.</p>
					</descr>
				</param>
				<param attr="in" name="contextNode" type="Node">
					<descr>
						<p>The<code>context</code>is context node for the evaluation of this XPath expression. If the XPathEvaluator was obtained by casting the<code>Document</code>then this must be owned by the same document and must be a<code>Document</code>,<code>Element</code>,<code>Attribute</code>,<code>Text</code>,<code>CDATASection</code>,<code>Comment</code>,<code>ProcessingInstruction</code>, or<code>XPathNamespace</code>node. If the context node is a<code>Text</code>or a<code>CDATASection</code>, then the context is interpreted as the whole logical text node as seen by XPath, unless the node is empty in which case it may not serve as the XPath context.</p>
					</descr>
				</param>
				<param attr="in" name="resolver" type="XPathNSResolver">
					<descr>
						<p>The<code>resolver</code>permits translation of all prefixes, including the<code>xml</code>namespace prefix, within the XPath expression into appropriate<termref def="dt-namespaceURI">namespace URIs</termref>. If this is specified as<code>null</code>, any<termref def="dt-namespaceprefix">namespace prefix</termref>within the expression will result in<code>DOMException</code>being thrown with the code<code>NAMESPACE_ERR</code>.</p>
					</descr>
				</param>
				<param attr="in" name="type" type="unsigned short">
					<descr>
						<p>If a specific<code>type</code>is specified, then the result will be returned as the corresponding type.</p>
						<p>For XPath 1.0 results, this must be one of the codes of the<code>XPathResult</code>interface.</p>
					</descr>
				</param>
				<param attr="in" name="result" type="DOMObject">
					<descr>
						<p>The<code>result</code>specifies a specific result object which may be reused and returned by this method. If this is specified as<code>null</code>or the implementation does not reuse the specified result, a new result object will be constructed and returned.</p>
						<p>For XPath 1.0 results, this object will be of type<code>XPathResult</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMObject">
				<descr>
					<p>The result of the evaluation of the XPath expression.</p>
					<p>For XPath 1.0 results, this object will be of type<code>XPathResult</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="XPathException">
					<descr>
						<p>INVALID_EXPRESSION_ERR: Raised if the expression is not legal according to the rules of the<code>XPathEvaluator</code>i</p>
						<p>TYPE_ERR: Raised if the result cannot be converted to return the specified type.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>NAMESPACE_ERR: Raised if the expression contains<termref def="dt-namespaceprefix">namespace prefixes</termref>which cannot be resolved by the specified<code>XPathNSResolver</code>.</p>
						<p>WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this<code>XPathEvaluator</code>.</p>
						<p>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request type is not permitted by this<code>XPathEvaluator</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface id="XPathExpression" name="XPathExpression">
		<descr>
			<p>The<code>XPathExpression</code>interface represents a parsed and resolved XPath expression.</p>
		</descr>
		<method id="XPathExpression-evaluate" name="evaluate">
			<descr>
				<p>Evaluates this XPath expression and returns a result.</p>
			</descr>
			<parameters>
				<param attr="in" name="contextNode" type="Node">
					<descr>
						<p>The<code>context</code>is context node for the evaluation of this XPath expression.</p>
						<p>If the XPathEvaluator was obtained by casting the<code>Document</code>then this must be owned by the same document and must be a<code>Document</code>,<code>Element</code>,<code>Attribute</code>,<code>Text</code>,<code>CDATASection</code>,<code>Comment</code>,<code>ProcessingInstruction</code>, or<code>XPathNamespace</code>node.</p>
						<p>If the context node is a<code>Text</code>or a<code>CDATASection</code>, then the context is interpreted as the whole logical text node as seen by XPath, unless the node is empty in which case it may not serve as the XPath context.</p>
					</descr>
				</param>
				<param attr="in" name="type" type="unsigned short">
					<descr>
						<p>If a specific<code>type</code>is specified, then the result will be coerced to return the specified type relying on XPath conversions and fail if the desired coercion is not possible. This must be one of the type codes of<code>XPathResult</code>.</p>
					</descr>
				</param>
				<param attr="in" name="result" type="DOMObject">
					<descr>
						<p>The<code>result</code>specifies a specific result object which may be reused and returned by this method. If this is specified as<code>null</code>or the implementation does not reuse the specified result, a new result object will be constructed and returned.</p>
						<p>For XPath 1.0 results, this object will be of type<code>XPathResult</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMObject">
				<descr>
					<p>The result of the evaluation of the XPath expression.</p>
					<p>For XPath 1.0 results, this object will be of type<code>XPathResult</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: Raised if the result cannot be converted to return the specified type.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by the XPathEvaluator that created this<code>XPathExpression</code>.</p>
						<p>NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request type is not permitted by this<code>XPathExpression</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface id="XPathNSResolver" name="XPathNSResolver">
		<descr>
			<p>The<code>XPathNSResolver</code>interface permit<code>prefix</code>strings in the expression to be properly bound to<code>namespaceURI</code>strings.<code>XPathEvaluator</code>can construct an implementation of<code>XPathNSResolver</code>from a node, or the interface may be implemented by any application.</p>
		</descr>
		<method name="lookupNamespaceURI" id="XPathNSResolver-lookupNamespaceURI">
			<descr>
				<p>Look up the<termref def="dt-namespaceURI">namespace URI</termref>associated to the given<termref def="dt-namespaceprefix">namespace prefix</termref>. The XPath evaluator must never call this with a<code>null</code>or empty argument, because the result of doing this is undefined.</p>
			</descr>
			<parameters>
				<param attr="in" type="DOMString" name="prefix">
					<descr>
						<p>The prefix to look for.</p>
					</descr>
				</param>
			</parameters>
			<returns type="DOMString">
				<descr>
					<p>Returns the associated<termref def="dt-namespaceURI">namespace URI</termref>or<code>null</code>if none is found.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface id="XPathResult" name="XPathResult">
		<descr>
			<p>The<code>XPathResult</code>interface represents the result of the evaluation of an XPath 1.0 expression within the context of a particular node. Since evaluation of an XPath expression can result in various result types, this object makes it possible to discover and manipulate the type and value of the result.</p>
		</descr>
		<group id="XPathResultType" name="XPathResultType">
			<descr>
				<p>An integer indicating what type of result this is.</p>
				<p>If a specific<code>type</code>is specified, then the result will be returned as the corresponding type, usingwhere required and possible.</p>
			</descr>
			<constant id="XPathResult-ANY-TYPE" name="ANY_TYPE" type="unsigned short" value="0">
				<descr>
					<p>This code does not represent a specific type. An evaluation of an XPath expression will never produce this type. If this type is requested, then the evaluation returns whatever type naturally results from evaluation of the expression.</p>
					<p>If the natural result is a node set when<code>ANY_TYPE</code>was requested, then<code>UNORDERED_NODE_ITERATOR_TYPE</code>is always the resulting type. Any other representation of a node set must be explicitly requested.</p>
				</descr>
			</constant>
			<constant id="XPathResult-NUMBER-TYPE" name="NUMBER_TYPE" type="unsigned short" value="1">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>. Document modification does not invalidate the number, but may mean that reevaluation would not yield the same number.</p>
				</descr>
			</constant>
			<constant id="XPathResult-STRING-TYPE" name="STRING_TYPE" type="unsigned short" value="2">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>. Document modification does not invalidate the string, but may mean that the string no longer corresponds to the current document.</p>
				</descr>
			</constant>
			<constant id="XPathResult-BOOLEAN-TYPE" name="BOOLEAN_TYPE" type="unsigned short" value="3">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>. Document modification does not invalidate the boolean, but may mean that reevaluation would not yield the same boolean.</p>
				</descr>
			</constant>
			<constant id="XPathResult-UNORDERED-NODE-ITERATOR-TYPE" name="UNORDERED_NODE_ITERATOR_TYPE" type="unsigned short" value="4">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>that will be accessed iteratively, which may not produce nodes in a particular order. Document modification invalidates the iteration.</p>
					<p>This is the default type returned if the result is a node set and<code>ANY_TYPE</code>is requested.</p>
				</descr>
			</constant>
			<constant id="XPathResult-ORDERED-NODE-ITERATOR-TYPE" name="ORDERED_NODE_ITERATOR_TYPE" type="unsigned short" value="5">
				<descr>
					<p>The result is a node set as defined by<bibref ref="XPath10"/>that will be accessed iteratively, which will produce document-ordered nodes. Document modification invalidates the iteration.</p>
				</descr>
			</constant>
			<constant id="XPathResult-UNORDERED-NODE-SNAPSHOT-TYPE" name="UNORDERED_NODE_SNAPSHOT_TYPE" type="unsigned short" value="6">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>that will be accessed as a snapshot list of nodes that may not be in a particular order. Document modification does not invalidate the snapshot but may mean that reevaluation would not yield the same snapshot and nodes in the snapshot may have been altered, moved, or removed from the document.</p>
				</descr>
			</constant>
			<constant id="XPathResult-ORDERED-NODE-SNAPSHOT-TYPE" name="ORDERED_NODE_SNAPSHOT_TYPE" type="unsigned short" value="7">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>that will be accessed as a snapshot list of nodes that will be in original document order. Document modification does not invalidate the snapshot but may mean that reevaluation would not yield the same snapshot and nodes in the snapshot may have been altered, moved, or removed from the document.</p>
				</descr>
			</constant>
			<constant id="XPathResult-ANY-UNORDERED-NODE-TYPE" name="ANY_UNORDERED_NODE_TYPE" type="unsigned short" value="8">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>and will be accessed as a single node, which may be<code>null</code>if the node set is empty. Document modification does not invalidate the node, but may mean that the result node no longer corresponds to the current document. This is a convenience that permits optimization since the implementation can stop once any node in the resulting set has been found.</p>
					<p>If there is more than one node in the actual result, the single node returned might not be the first in document order.</p>
				</descr>
			</constant>
			<constant id="XPathResult-FIRST-ORDERED-NODE-TYPE" name="FIRST_ORDERED_NODE_TYPE" type="unsigned short" value="9">
				<descr>
					<p>The result is aas defined by<bibref ref="XPath10"/>and will be accessed as a single node, which may be<code>null</code>if the node set is empty. Document modification does not invalidate the node, but may mean that the result node no longer corresponds to the current document. This is a convenience that permits optimization since the implementation can stop once the first node in document order of the resulting set has been found.</p>
					<p>If there are more than one node in the actual result, the single node returned will be the first in document order.</p>
				</descr>
			</constant>
		</group>
		<attribute id="XPathResult-resultType" type="unsigned short" name="resultType" readonly="yes">
			<descr>
				<p>A code representing the type of this result, as defined by the type constants.</p>
			</descr>
		</attribute>
		<attribute id="XPathResult-numberValue" type="double" name="numberValue" readonly="yes">
			<descr>
				<p>The value of this number result. If the native double type of the DOM binding does not directly support the exact IEEE 754 result of the XPath expression, then it is up to the definition of the binding to specify how the XPath number is converted to the native binding number.</p>
			</descr>
			<getraises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>NUMBER_TYPE</code>.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute id="XPathResult-stringValue" type="DOMString" name="stringValue" readonly="yes">
			<descr>
				<p>The value of this string result.</p>
			</descr>
			<getraises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>STRING_TYPE</code>.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute id="XPathResult-booleanValue" type="boolean" name="booleanValue" readonly="yes">
			<descr>
				<p>The value of this boolean result.</p>
			</descr>
			<getraises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>BOOLEAN_TYPE</code>.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute id="XPathResult-singleNodeValue" type="Node" name="singleNodeValue" readonly="yes">
			<descr>
				<p>The value of this single node result, which may be<code>null</code>.</p>
			</descr>
			<getraises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>ANY_UNORDERED_NODE_TYPE</code>or<code>FIRST_ORDERED_NODE_TYPE</code>.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute type="boolean" readonly="yes" name="invalidIteratorState" id="XPathResult-invalid-iterator-state">
			<descr>
				<p>Signifies that the iterator has become invalid. True if<code>resultType</code>is<code>UNORDERED_NODE_ITERATOR_TYPE</code>or<code>ORDERED_NODE_ITERATOR_TYPE</code>and the document has been modified since this result was returned.</p>
			</descr>
		</attribute>
		<attribute type="unsigned long" readonly="yes" name="snapshotLength" id="XPathResult-snapshot-length">
			<descr>
				<p>The number of nodes in the result snapshot. Valid values for snapshotItem indices are<code>0</code>to<code>snapshotLength-1</code>inclusive.</p>
			</descr>
			<getraises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>UNORDERED_NODE_SNAPSHOT_TYPE</code>or<code>ORDERED_NODE_SNAPSHOT_TYPE</code>.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<method id="XPathResult-iterateNext" name="iterateNext">
			<descr>
				<p>Iterates and returns the next node from the node set or<code>null</code>if there are no more nodes.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>Returns the next node.</p>
				</descr>
			</returns>
			<raises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>UNORDERED_NODE_ITERATOR_TYPE</code>or<code>ORDERED_NODE_ITERATOR_TYPE</code>.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: The document has been mutated since the result was returned.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method id="XPathResult-snapshotItem" name="snapshotItem">
			<descr>
				<p>Returns the<code>index</code>th item in the snapshot collection. If<code>index</code>is greater than or equal to the number of nodes in the list, this method returns<code>null</code>. Unlike the iterator result, the snapshot does not become invalid, but may not correspond to the current document if it is mutated.</p>
			</descr>
			<parameters>
				<param id="XPathResult-snapshot-item-index" name="index" type="unsigned long" attr="in">
					<descr>
						<p>Index into the snapshot collection.</p>
					</descr>
				</param>
			</parameters>
			<returns type="Node">
				<descr>
					<p>The node at the<code>index</code>th position in the<code>NodeList</code>, or<code>null</code>if that is not a valid index.</p>
				</descr>
			</returns>
			<raises>
				<exception name="XPathException">
					<descr>
						<p>TYPE_ERR: raised if<code>resultType</code>is not<code>UNORDERED_NODE_SNAPSHOT_TYPE</code>or<code>ORDERED_NODE_SNAPSHOT_TYPE</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface id="XPathNamespace" name="XPathNamespace" inherits="Node">
		<descr>
			<p>The<code>XPathNamespace</code>interface is returned by<code>XPathResult</code>interfaces to represent the XPath namespace node type that DOM lacks. There is no public constructor for this node type. Attempts to place it into a hierarchy or a NamedNodeMap result in a<code>DOMException</code>with the code<code>HIERARCHY_REQUEST_ERR</code>. This node is<termref def="dt-readonly-node">read only</termref>, so methods or setting of attributes that would mutate the node result in a DOMException with the code<code>NO_MODIFICATION_ALLOWED_ERR</code>.</p>
			<p>The core specification describes attributes of the<code>Node</code>interface that are different for different node types but does not describe<code>XPATH_NAMESPACE_NODE</code>, so here is a description of those attributes for this node type. All attributes of<code>Node</code>not described in this section have a<code>null</code>or<code>false</code>value.</p>
			<p>
				<code>ownerDocument</code>matches the<code>ownerDocument</code>of the<code>ownerElement</code>even if the element is later adopted.</p>
			<p>
				<code>nodeName</code>is always the string "<code>#namespace</code>".</p>
			<p>
				<code>prefix</code>is the prefix of the namespace represented by the node.</p>
			<p>
				<code>localName</code>is the same as<code>prefix</code>.</p>
			<p>
				<code>nodeType</code>is equal to<code>XPATH_NAMESPACE_NODE</code>.</p>
			<p>
				<code>namespaceURI</code>is the namespace URI of the namespace represented by the node.</p>
			<p>
				<code>nodeValue</code>is the same as<code>namespaceURI</code>.</p>
			<p>
				<code>adoptNode</code>,<code>cloneNode</code>, and<code>importNode</code>fail on this node type by raising a<code>DOMException</code>with the code<code>NOT_SUPPORTED_ERR</code>.</p>
			<note>
				<p>In future versions of the XPath specification, the definition of a namespace node may be changed incomatibly, in which case incompatible changes to field values may be required to implement versions beyond XPath 1.0.</p>
			</note>
		</descr>
		<group id="XPathNodeType" name="XPathNodeType">
			<descr>
				<p>An integer indicating which type of node this is.</p>
				<note>
					<p>There is currently only one type of node which is specific to XPath. The numbers in this list must not collide with the values assigned to core node types.</p>
				</note>
			</descr>
			<constant id="XPATH_NAMESPACE_NODE" name="XPATH_NAMESPACE_NODE" type="unsigned short" value="13">
				<descr>
					<p>The node is a<code>Namespace</code>.</p>
				</descr>
			</constant>
		</group>
		<attribute type="Element" readonly="yes" name="ownerElement" id="XPathNamespace-ownerElement">
			<descr>
				<p>The<code>Element</code>on which the namespace was in scope when it was requested. This does not change on a returned namespace node even if the document changes such that the namespace goes out of scope on that<termref def="dt-element">element</termref>and this node is no longer found there by XPath.</p>
			</descr>
		</attribute>
	</interface>
	<interface name="NodeIterator" id="Traversal-NodeIterator" since="DOM Level 2">
		<descr>
			<p>
				<code>Iterators</code>are used to step through a set of nodes, e.g. the set of nodes in a<code>NodeList</code>, the document subtree governed by a particular<code>Node</code>, the results of a query, or any other set of nodes. The set of nodes to be iterated is determined by the implementation of the<code>NodeIterator</code>. DOM Level 2 specifies a single<code>NodeIterator</code>implementation for document-order traversal of a document subtree. Instances of these iterators are created by calling<code>DocumentTraversal</code>
				<code>.createNodeIterator()</code>.</p>
		</descr>
		<attribute id="Traversal-NodeIterator-root" name="root" type="Node" readonly="yes">
			<descr>
				<p>The root node of the<code>NodeIterator</code>, as specified when it was created.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-NodeIterator-whatToShow" name="whatToShow" type="unsigned long" readonly="yes">
			<descr>
				<p>This attribute determines which node types are presented via the iterator. The available set of constants is defined in the<code>NodeFilter</code>interface.Nodes not accepted by<code>whatToShow</code>will be skipped, but their children may still be considered. Note that this skip takes precedence over the filter, if any.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-NodeIterator-filter" name="filter" type="NodeFilter" readonly="yes">
			<descr>
				<p>The<code>NodeFilter</code>used to screen nodes.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-NodeIterator-expandEntityReferences" name="expandEntityReferences" type="boolean" readonly="yes">
			<descr>
				<p>The value of this flag determines whether the children of entity reference nodes are visible to the iterator. If false, theyand their<termref def="dt-descendant">descendants</termref>will be rejected. Note that this rejection takes precedence over<code>whatToShow</code>and the filter. Also note that this is currently the only situation where<code>NodeIterators</code>may reject a complete subtree rather than skipping individual nodes.</p>
				<p/>
				<p>To produce a view of the document that has entity references expanded and does not expose the entity reference node itself, use the<code>whatToShow</code>flags to hide the entity reference node and set<code>expandEntityReferences</code>to true when creating the iterator. To produce a view of the document that has entity reference nodes but no entity expansion, use the<code>whatToShow</code>flags to show the entity reference node and set<code>expandEntityReferences</code>to false.</p>
			</descr>
		</attribute>
		<method name="nextNode" id="Traversal-NodeIterator-nextNode">
			<descr>
				<p>Returns the next node in the set and advances the position of the iterator in the set. After a<code>NodeIterator</code>is created, the first call to<code>nextNode()</code>returns the first node in the set.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The next<code>Node</code>in the set being iterated over, or<code>null</code>if there are no more members in that set.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if this method is called after the<code>detach</code>method was invoked.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="previousNode" id="Traversal-NodeIterator-previousNode">
			<descr>
				<p>Returns the previous node in the set and moves the position of the<code>NodeIterator</code>backwards in the set.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The previous<code>Node</code>in the set being iterated over, or<code>null</code>if there are no more members in that set.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if this method is called after the<code>detach</code>method was invoked.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="detach" id="Traversal-NodeIterator-detach">
			<descr>
				<p>Detaches the<code>NodeIterator</code>from the set which it iterated over, releasing any computational resources and placing the iterator in the INVALID state. After<code>detach</code>has been invoked, calls to<code>nextNode</code>or<code>previousNode</code>will raise the exception INVALID_STATE_ERR.</p>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="NodeFilter" id="Traversal-NodeFilter" since="DOM Level 2" role="special">
		<descr>
			<p>Filters are objects that know how to "filter out" nodes. If a<code>NodeIterator</code>or<code>TreeWalker</code>is given a<code>NodeFilter</code>, it applies the filter before it returns the next node. If the filter says to accept the node, the traversal logic returns it; otherwise, traversal looks for the next node and pretends that the node that was rejected was not there.</p>
			<p>The DOM does not provide any filters.<code>NodeFilter</code>is just an interface that users can implement to provide their own filters.</p>
			<p>
				<code>NodeFilters</code>do not need to know how to traverse from node to node, nor do they need to know anything about the data structure that is being traversed. This makes it very easy to write filters, since the only thing they have to know how to do is evaluate a single node. One filter may be used with a number of different kinds of traversals, encouraging code reuse.</p>
		</descr>
		<group name="Constants returned by acceptNode" id="Traversal-NodeFilter-acceptNode-constants">
			<descr>
				<p>The following constants are returned by the acceptNode() method:</p>
			</descr>
			<constant name="FILTER_ACCEPT" type="short" value="1">
				<descr>
					<p>Accept the node. Navigation methods defined for<code>NodeIterator</code>or<code>TreeWalker</code>will return this node.</p>
				</descr>
			</constant>
			<constant name="FILTER_REJECT" type="short" value="2">
				<descr>
					<p>Reject the node. Navigation methods defined for<code>NodeIterator</code>or<code>TreeWalker</code>will not return this node. For<code>TreeWalker</code>, the children of this node will also be rejected.<code>NodeIterators</code>treat this as a synonym for<code>FILTER_SKIP</code>.</p>
				</descr>
			</constant>
			<constant name="FILTER_SKIP" type="short" value="3">
				<descr>
					<p>Skip this single node. Navigation methods defined for<code>NodeIterator</code>or<code>TreeWalker</code>will not return this node. For both<code>NodeIterator</code>and<code>TreeWalker</code>, the children of this node will still be considered.</p>
				</descr>
			</constant>
		</group>
		<group id="Traversal-NodeFilter-whatToShow-constants" name="Constants for whatToShow">
			<descr>
				<p>These are the available values for the<code>whatToShow</code>parameter used in<code>TreeWalkers</code>and<code>NodeIterators</code>. They are the same as the set of possible types for<code>Node</code>, and their values are derived by using a bit position corresponding to the value of<code>nodeType</code>for the equivalent node type.If a bit in<code>whatToShow</code>is set false, that will be taken as a request to skip over this type of node; the behavior in that case is similar to that of<code>FILTER_SKIP</code>.</p>
				<p>Note that if node types greater than 32 are ever introduced, they may not be individually testable via<code>whatToShow</code>. If that need should arise, it can be handled by selecting<code>SHOW_ALL</code>together with an appropriate<code>NodeFilter</code>.</p>
			</descr>
			<constant name="SHOW_ALL" type="unsigned long" value="0xFFFFFFFF">
				<descr>
					<p>Show all<code>Nodes</code>.</p>
				</descr>
			</constant>
			<constant name="SHOW_ELEMENT" type="unsigned long" value="0x00000001">
				<descr>
					<p>Show<code>Element</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_ATTRIBUTE" type="unsigned long" value="0x00000002">
				<descr>
					<p>Show<code>Attr</code>nodes. This is meaningful only when creating an iterator or tree-walker with an attribute node as its<code>root</code>; in this case, it means that the attribute node will appear in the first position of the iteration or traversal. Since attributes are never children of other nodes, they do not appear when traversing over the document tree.</p>
				</descr>
			</constant>
			<constant name="SHOW_TEXT" type="unsigned long" value="0x00000004">
				<descr>
					<p>Show<code>Text</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_CDATA_SECTION" type="unsigned long" value="0x00000008">
				<descr>
					<p>Show<code>CDATASection</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_ENTITY_REFERENCE" type="unsigned long" value="0x00000010">
				<descr>
					<p>Show<code>EntityReference</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_ENTITY" type="unsigned long" value="0x00000020">
				<descr>
					<p>Show<code>Entity</code>nodes. This is meaningful only when creating an iterator or tree-walker with an<code>Entity</code>node as its<code>root</code>; in this case, it means that the<code>Entity</code>node will appear in the first position of the traversal. Since entities are not part of the document tree, they do not appear when traversing over the document tree.</p>
				</descr>
			</constant>
			<constant name="SHOW_PROCESSING_INSTRUCTION" type="unsigned long" value="0x00000040">
				<descr>
					<p>Show<code>ProcessingInstruction</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_COMMENT" type="unsigned long" value="0x00000080">
				<descr>
					<p>Show<code>Comment</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_DOCUMENT" type="unsigned long" value="0x00000100">
				<descr>
					<p>Show<code>Document</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_DOCUMENT_TYPE" type="unsigned long" value="0x00000200">
				<descr>
					<p>Show<code>DocumentType</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_DOCUMENT_FRAGMENT" type="unsigned long" value="0x00000400">
				<descr>
					<p>Show<code>DocumentFragment</code>nodes.</p>
				</descr>
			</constant>
			<constant name="SHOW_NOTATION" type="unsigned long" value="0x00000800">
				<descr>
					<p>Show<code>Notation</code>nodes. This is meaningful only when creating an iterator or tree-walker with a<code>Notation</code>node as its<code>root</code>; in this case, it means that the<code>Notation</code>node will appear in the first position of the traversal. Since notations are not part of the document tree, they do not appear when traversing over the document tree.</p>
				</descr>
			</constant>
		</group>
		<method name="acceptNode" id="Traversal-NodeFilter-acceptNode">
			<descr>
				<p>Test whether a specified node is visible in the logical view of a<code>TreeWalker</code>or<code>NodeIterator</code>. This function will be called by the implementation of<code>TreeWalker</code>and<code>NodeIterator</code>; it is not normally called directly from user code. (Though you could do so if you wanted to use the same filter to guide your own application logic.)</p>
			</descr>
			<parameters>
				<param name="n" type="Node" attr="in">
					<descr>
						<p>The node to check to see if it passes the filter or not.</p>
					</descr>
				</param>
			</parameters>
			<returns type="short">
				<descr>
					<p>a constant to determine whether the node is accepted, rejected, or skipped, as defined.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="TreeWalker" id="Traversal-TreeWalker" since="DOM Level 2">
		<descr>
			<p>
				<code>TreeWalker</code>objects are used to navigate a document tree or subtree using the view of the document defined by their<code>whatToShow</code>flags and filter (if any). Any function which performs navigation using a<code>TreeWalker</code>will automatically support any view defined by a<code>TreeWalker</code>.</p>
			<p>Omitting nodes from the logical view of a subtree can result in a structure that is substantially different from the same subtree in the complete, unfiltered document. Nodes that are<termref def="dt-sibling">siblings</termref>in the<code>TreeWalker</code>view may be children of different, widely separated nodes in the original view. For instance, consider a<code>NodeFilter</code>that skips all nodes except for Text nodes and the root node of a document. In the logical view that results, all text nodes will be<termref def="dt-sibling">siblings</termref>and appear as direct children of the root node, no matter how deeply nested the structure of the original document.</p>
		</descr>
		<attribute id="Traversal-TreeWalker-root" name="root" type="Node" readonly="yes">
			<descr>
				<p>The<code>root</code>node of the<code>TreeWalker</code>, as specified when it was created.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-TreeWalker-whatToShow" name="whatToShow" type="unsigned long" readonly="yes">
			<descr>
				<p>This attribute determines which node types are presented via the<code>TreeWalker</code>. The available set of constants is defined in the<code>NodeFilter</code>interface.Nodes not accepted by<code>whatToShow</code>will be skipped, but their children may still be considered. Note that this skip takes precedence over the filter, if any.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-TreeWalker-filter" name="filter" type="NodeFilter" readonly="yes">
			<descr>
				<p>The filter used to screen nodes.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-TreeWalker-expandEntityReferences" name="expandEntityReferences" type="boolean" readonly="yes">
			<descr>
				<p>The value of this flag determines whether the children of entity reference nodes are visible to the<code>TreeWalker</code>. If false, theyand their<termref def="dt-descendant">descendants</termref>will be rejected. Note that this rejection takes precedence over<code>whatToShow</code>and the filter, if any.</p>
				<p>To produce a view of the document that has entity references expanded and does not expose the entity reference node itself, use the<code>whatToShow</code>flags to hide the entity reference node and set<code>expandEntityReferences</code>to true when creating the<code>TreeWalker</code>. To produce a view of the document that has entity reference nodes but no entity expansion, use the<code>whatToShow</code>flags to show the entity reference node and set<code>expandEntityReferences</code>to false.</p>
			</descr>
		</attribute>
		<attribute id="Traversal-TreeWalker-currentNode" name="currentNode" type="Node" readonly="no">
			<descr>
				<p>The node at which the<code>TreeWalker</code>is currently positioned.</p>
				<p>Alterations to the DOM tree may cause the current node to no longer be accepted by the<code>TreeWalker</code>'s associated filter.<code>currentNode</code>may also be explicitly set to any node, whether or not it is within the subtree specified by the<code>root</code>node or would be accepted by the filter and<code>whatToShow</code>flags. Further traversal occurs relative to<code>currentNode</code>even if it is not part of the current view, by applying the filters in the requested direction; if no traversal is possible,<code>currentNode</code>is not changed.</p>
			</descr>
			<setraises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if an attempt is made to set<code>currentNode</code>to<code>null</code>.</p>
					</descr>
				</exception>
			</setraises>
		</attribute>
		<method name="parentNode" id="Traversal-TreeWalker-parentNode">
			<descr>
				<p>Moves to and returns the closest visible<termref def="dt-ancestor">ancestor</termref>node of the current node. If the search for<code>parentNode</code>attempts to step upward from the<code>TreeWalker</code>'s<code>root</code>node, or if it fails to find a visible<termref def="dt-ancestor">ancestor</termref>node, this method retains the current position and returns<code>null</code>.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new<termref def="dt-parent">parent</termref>node, or<code>null</code>if the current node has no parentin the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="firstChild" id="Traversal-TreeWalker-firstChild">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the first visible<termref def="dt-child">child</termref>of the current node, and returns the new node. If the current node has no visible children, returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no visible childrenin the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="lastChild" id="Traversal-TreeWalker-lastChild">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the last visible<termref def="dt-child">child</termref>of the current node, and returns the new node. If the current node has no visible children, returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no childrenin the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="previousSibling" id="Traversal-TreeWalker-previousSibling">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the previous<termref def="dt-sibling">sibling</termref>of the current node, and returns the new node. If the current node has no visible previous<termref def="dt-sibling">sibling</termref>, returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no previous<termref def="dt-sibling">sibling</termref>.in the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="nextSibling" id="Traversal-TreeWalker-nextSibling">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the next<termref def="dt-sibling">sibling</termref>of the current node, and returns the new node. If the current node has no visible next<termref def="dt-sibling">sibling</termref>, returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no next<termref def="dt-sibling">sibling</termref>.in the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="previousNode" id="Traversal-TreeWalker-previousNode">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the previous visible node in document order relative to the current node, and returns the new node. If the current node has no previous node,or if the search for<code>previousNode</code>attempts to step upward from the<code>TreeWalker</code>'s<code>root</code>node,returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no previous nodein the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
		<method name="nextNode" id="Traversal-TreeWalker-nextNode">
			<descr>
				<p>Moves the<code>TreeWalker</code>to the next visible node in document order relative to the current node, and returns the new node. If the current node has no next node, or if the search for nextNode attempts to step upward from the<code>TreeWalker</code>'s<code>root</code>node, returns<code>null</code>, and retains the current node.</p>
			</descr>
			<parameters/>
			<returns type="Node">
				<descr>
					<p>The new node, or<code>null</code>if the current node has no next nodein the<code>TreeWalker</code>'s logical view.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<interface name="DocumentTraversal" id="Traversal-Document" since="DOM Level 2">
		<descr>
			<p>
				<code>DocumentTraversal</code>contains methods that create iterators and tree-walkers to traverse a node and its children in document order (depth first, pre-order traversal, which is equivalent to the order in which the start tags occur in the text representation of the document). In DOMs which support the Traversal feature,<code>DocumentTraversal</code>will be implemented by the same objects that implement the Document interface.</p>
		</descr>
		<method name="createNodeIterator" id="Traversal-NodeIteratorFactory-createNodeIterator">
			<descr>
				<p>Create a new<code>NodeIterator</code>over the subtree rooted at the specified node.</p>
			</descr>
			<parameters>
				<param name="root" type="Node" attr="in">
					<descr>
						<p>The node which will be iterated together with its children. The iterator is initially positioned just before this node. The<code>whatToShow</code>flags and the filter, if any, are not considered when setting this position. The root must not be<code>null</code>.</p>
					</descr>
				</param>
				<param name="whatToShow" type="unsigned long" attr="in">
					<descr>
						<p>This flag specifies which node types may appear in the logical view of the tree presented by the iterator. See the description of<code>NodeFilter</code>for the set of possible<code>SHOW_</code>values.</p>
						<p>These flags can be combined using<code>OR</code>.</p>
					</descr>
				</param>
				<param name="filter" type="NodeFilter" attr="in">
					<descr>
						<p>The<code>NodeFilter</code>to be used with this<code>TreeWalker</code>, or<code>null</code>to indicate no filter.</p>
					</descr>
				</param>
				<param name="entityReferenceExpansion" type="boolean" attr="in">
					<descr>
						<p>The value of this flag determines whether entity reference nodes are expanded.</p>
					</descr>
				</param>
			</parameters>
			<returns type="NodeIterator">
				<descr>
					<p>The newly created<code>NodeIterator</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the specified<code>root</code>is<code>null</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="createTreeWalker" id="NodeIteratorFactory-createTreeWalker">
			<descr>
				<p>Create a new<code>TreeWalker</code>over the subtree rooted at the specified node.</p>
			</descr>
			<parameters>
				<param name="root" type="Node" attr="in">
					<descr>
						<p>The node which will serve as the<code>root</code>for the<code>TreeWalker</code>. The<code>whatToShow</code>flags and the<code>NodeFilter</code>are not considered when setting this value; any node type will be accepted as the<code>root</code>. The<code>currentNode</code>of the<code>TreeWalker</code>is initialized to this node, whether or not it is visible. The<code>root</code>functions as a stopping point for traversal methods that look upward in the document structure, such as<code>parentNode</code>and nextNode. The<code>root</code>must not be<code>null</code>.</p>
					</descr>
				</param>
				<param name="whatToShow" type="unsigned long" attr="in">
					<descr>
						<p>This flag specifies which node types may appear in the logical view of the tree presented by the tree-walker. See the description of<code>NodeFilter</code>for the set of possible SHOW_ values.</p>
						<p>These flags can be combined using<code>OR</code>.</p>
					</descr>
				</param>
				<param name="filter" type="NodeFilter" attr="in">
					<descr>
						<p>The<code>NodeFilter</code>to be used with this<code>TreeWalker</code>, or<code>null</code>to indicate no filter.</p>
					</descr>
				</param>
				<param name="entityReferenceExpansion" type="boolean" attr="in">
					<descr>
						<p>If this flag is false, the contents of<code>EntityReference</code>nodes are not presented in the logical view.</p>
					</descr>
				</param>
			</parameters>
			<returns type="TreeWalker">
				<descr>
					<p>The newly created<code>TreeWalker</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NOT_SUPPORTED_ERR: Raised if the specified<code>root</code>is<code>null</code>.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="Range" id="Level-2-Range-idl" since="DOM Level 2">
		<descr/>
		<attribute name="startContainer" type="Node" readonly="yes" id="Level-2-Range-attr-startParent">
			<descr>
				<p>Node within which the Range begins</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute name="startOffset" type="long" readonly="yes" id="Level-2-Range-attr-startOffset">
			<descr>
				<p>Offset within the starting node of the Range.</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute name="endContainer" type="Node" readonly="yes" id="Level-2-Range-attr-endParent">
			<descr>
				<p>Node within which the Range ends</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute name="endOffset" type="long" readonly="yes" id="Level-2-Range-attr-endOffset">
			<descr>
				<p>Offset within the ending node of the Range.</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute name="collapsed" type="boolean" readonly="yes" id="Level-2-Range-attr-collapsed">
			<descr>
				<p>TRUE if the Range is collapsed</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<attribute name="commonAncestorContainer" type="Node" readonly="yes" id="Level-2-Range-attr-commonParent">
			<descr>
				<p>The<termref def="dt-deepest">deepest</termref>common<termref def="td-ancestor-container">ancestor container</termref>of the Range's two boundary-points.</p>
			</descr>
			<getraises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</getraises>
		</attribute>
		<method name="setStart" id="Level2-Range-method-setStart">
			<descr>
				<p>Sets the attributes describing the start of the Range.</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>The<code>refNode</code>value. This parameter must be different from<code>null</code>.</p>
					</descr>
				</param>
				<param name="offset" type="long" attr="in">
					<descr>
						<p>The<code>startOffset</code>value.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if<code>refNode</code>or an ancestor of<code>refNode</code>is an Entity, Notation, or DocumentType node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if<code>offset</code>is negative or greater than the number of child units in<code>refNode</code>. Child units are<termref def="dt-16-bit-unit">16-bit units</termref>if<code>refNode</code>is a type of CharacterData node (e.g., a Text or Comment node) or a ProcessingInstruction node. Child units are Nodes in all other cases.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setEnd" id="Level2-Range-method-setEnd">
			<descr>
				<p>Sets the attributes describing the end of a Range.</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>The<code>refNode</code>value. This parameter must be different from<code>null</code>.</p>
					</descr>
				</param>
				<param name="offset" type="long" attr="in">
					<descr>
						<p>The<code>endOffset</code>value.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if<code>refNode</code>or an ancestor of<code>refNode</code>is an Entity, Notation, or DocumentType node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INDEX_SIZE_ERR: Raised if<code>offset</code>is negative or greater than the number of child units in<code>refNode</code>. Child units are<termref def="dt-16-bit-unit">16-bit units</termref>if<code>refNode</code>is a type of CharacterData node (e.g., a Text or Comment node) or a ProcessingInstruction node. Child units are Nodes in all other cases.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setStartBefore" id="Level2-Range-setStartBefore">
			<descr>
				<p>Sets the start position to be before a node</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>Range starts before<code>refNode</code>
						</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if the root container of<code>refNode</code>is not an Attr, Document, or DocumentFragment node or if<code>refNode</code>is a Document, DocumentFragment, Attr, Entity, or Notation node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setStartAfter" id="Level2-Range-method-setStartAfter">
			<descr>
				<p>Sets the start position to be after a node</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>Range starts after<code>refNode</code>
						</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if the root container of<code>refNode</code>is not an Attr, Document, or DocumentFragment node or if<code>refNode</code>is a Document, DocumentFragment, Attr, Entity, or Notation node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setEndBefore" id="Level2-Range-method-setEndBefore">
			<descr>
				<p>Sets the end position to be before a node.</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>Range ends before<code>refNode</code>
						</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if the root container of<code>refNode</code>is not an Attr, Document, or DocumentFragment node or if<code>refNode</code>is a Document, DocumentFragment, Attr, Entity, or Notation node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="setEndAfter" id="Level2-Range-method-setEndAfter">
			<descr>
				<p>Sets the end of a Range to be after a node</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>Range ends after<code>refNode</code>.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if the root container of<code>refNode</code>is not an Attr, Document or DocumentFragment node or if<code>refNode</code>is a Document, DocumentFragment, Attr, Entity, or Notation node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="collapse" id="Level2-Range-method-collapse">
			<descr>
				<p>Collapse a Range onto one of its boundary-points</p>
			</descr>
			<parameters>
				<param name="toStart" type="boolean" attr="in">
					<descr>
						<p>If TRUE, collapses the Range onto its start; if FALSE, collapses it onto its end.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="selectNode" id="Level2-Range-method-selectNode">
			<descr>
				<p>Select a node and its contents</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>The node to select.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if an ancestor of<code>refNode</code>is an Entity, Notation or DocumentType node or if<code>refNode</code>is a Document, DocumentFragment, Attr, Entity, or Notation node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="selectNodeContents" id="Level2-Range-method-selectNodeContents">
			<descr>
				<p>Select the contents within a node</p>
			</descr>
			<parameters>
				<param name="refNode" type="Node" attr="in">
					<descr>
						<p>Node to select from</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if<code>refNode</code>or an ancestor of<code>refNode</code>is an Entity, Notation or DocumentType node.</p>
					</descr>
				</exception>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<group id="Level2-Range-compareHow" name="CompareHow">
			<descr>
				<p>Passed as a parameter to the<code>compareBoundaryPoints</code>method.</p>
			</descr>
			<constant name="START_TO_START" type="unsigned short" value="0">
				<descr>
					<p>Compare start boundary-point of<code>sourceRange</code>to start boundary-point of Range on which<code>compareBoundaryPoints</code>is invoked.</p>
				</descr>
			</constant>
			<constant name="START_TO_END" type="unsigned short" value="1">
				<descr>
					<p>Compare start boundary-point of<code>sourceRange</code>to end boundary-point of Range on which<code>compareBoundaryPoints</code>is invoked.</p>
				</descr>
			</constant>
			<constant name="END_TO_END" type="unsigned short" value="2">
				<descr>
					<p>Compare end boundary-point of<code>sourceRange</code>to end boundary-point of Range on which<code>compareBoundaryPoints</code>is invoked.</p>
				</descr>
			</constant>
			<constant name="END_TO_START" type="unsigned short" value="3">
				<descr>
					<p>Compare end boundary-point of<code>sourceRange</code>to start boundary-point of Range on which<code>compareBoundaryPoints</code>is invoked.</p>
				</descr>
			</constant>
		</group>
		<method name="compareBoundaryPoints" id="Level2-Range-method-compareBoundaryPoints">
			<descr>
				<p>Compare the boundary-points of two Ranges in a document.</p>
			</descr>
			<parameters>
				<param name="how" type="unsigned short" attr="in">
					<descr>
						<p>A code representing the type of comparison, as defined above.</p>
					</descr>
				</param>
				<param name="sourceRange" type="Range" attr="in">
					<descr>
						<p>The<code>Range</code>on which this current<code>Range</code>is compared to.</p>
					</descr>
				</param>
			</parameters>
			<returns type="short">
				<descr>
					<p>-1, 0 or 1 depending on whether the corresponding boundary-point of the Range is respectively before, equal to, or after the corresponding boundary-point of<code>sourceRange</code>.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>WRONG_DOCUMENT_ERR: Raised if the two Ranges are not in the same Document or DocumentFragment.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="deleteContents" id="Level2-Range-method-deleteContents">
			<descr>
				<p>Removes the contents of a Range from the containing document or document fragment without returning a reference to the removed content.</p>
			</descr>
			<parameters/>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if any portion of the content of the Range is read-only or any of the nodes that contain any of the content of the Range are read-only.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="extractContents" id="Level2-Range-method-extractContents">
			<descr>
				<p>Moves the contents of a Range from the containing document or document fragment to a new DocumentFragment.</p>
			</descr>
			<parameters/>
			<returns type="DocumentFragment">
				<descr>
					<p>A DocumentFragment containing the extracted contents.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if any portion of the content of the Range is read-only or any of the nodes which contain any of the content of the Range are read-only.</p>
						<p>HIERARCHY_REQUEST_ERR: Raised if a DocumentType node would be extracted into the new DocumentFragment.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="cloneContents" id="Level2-Range-method-cloneContents">
			<descr>
				<p>Duplicates the contents of a Range</p>
			</descr>
			<parameters/>
			<returns type="DocumentFragment">
				<descr>
					<p>A DocumentFragment that contains content equivalent to this Range.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>HIERARCHY_REQUEST_ERR: Raised if a DocumentType node would be extracted into the new DocumentFragment.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="insertNode" id="Level2-Range-method-insertNode">
			<descr>
				<p>Inserts a node into the Document or DocumentFragment at the start of the Range. If the container is a Text node, this will be split at the start of the Range (as if the Text node's splitText method was performed at the insertion point) and the insertion will occur between the two resulting Text nodes. Adjacent Text nodes will not be automatically merged. If the node to be inserted is a DocumentFragment node, the children will be inserted rather than the DocumentFragment node itself.</p>
			</descr>
			<parameters>
				<param name="newNode" type="Node" attr="in">
					<descr>
						<p>The node to insert at the start of the Range</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if an<termref def="td-ancestor-container">ancestor container</termref>of the start of the Range is read-only.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newNode</code>and the<termref def="td-container">container</termref>of the start of the Range were not created from the same document.</p>
						<p>HIERARCHY_REQUEST_ERR: Raised if the<termref def="td-container">container</termref>of the start of the Range is of a type that does not allow children of the type of<code>newNode</code>or if<code>newNode</code>is an ancestor of the<termref def="td-container">container</termref>.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
				<exception name="RangeException">
					<descr>
						<p>INVALID_NODE_TYPE_ERR: Raised if<code>newNode</code>is an Attr, Entity, Notation, or Document node.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="surroundContents" id="Level2-Range-method-surroundContents">
			<descr>
				<p>Reparents the contents of the Range to the given node and inserts the node at the position of the start of the Range.</p>
			</descr>
			<parameters>
				<param name="newParent" type="Node" attr="in">
					<descr>
						<p>The node to surround the contents with.</p>
					</descr>
				</param>
			</parameters>
			<returns type="void">
				<descr>
					<p/>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>NO_MODIFICATION_ALLOWED_ERR: Raised if an<termref def="td-ancestor-container">ancestor container</termref>of either boundary-point of the Range is read-only.</p>
						<p>WRONG_DOCUMENT_ERR: Raised if<code>newParent</code>and the<termref def="td-container">container</termref>of the start of the Range were not created from the same document.</p>
						<p>HIERARCHY_REQUEST_ERR: Raised if the<termref def="td-container">container</termref>of the start of the Range is of a type that does not allow children of the type of<code>newParent</code>or if<code>newParent</code>is an ancestor of the<termref def="td-container">container</termref>or if<code>node</code>would end up with a child node of a type not allowed by the type of<code>node</code>.</p>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
				<exception name="RangeException">
					<descr>
						<p>BAD_BOUNDARYPOINTS_ERR: Raised if the Range<termref def="td-partially-selected">partially selects</termref>a non-text node.</p>
						<p>INVALID_NODE_TYPE_ERR: Raised if<code>node</code>is an Attr, Entity, DocumentType, Notation, Document, or DocumentFragment node.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="cloneRange" id="Level2-Range-method-clone">
			<descr>
				<p>Produces a new Range whose boundary-points are equal to the boundary-points of the Range.</p>
			</descr>
			<parameters/>
			<returns type="Range">
				<descr>
					<p>The duplicated Range.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="toString" id="Level2-Range-method-toString">
			<descr>
				<p>Returns the contents of a Range as a string. This string contains only the data characters, not any markup.</p>
			</descr>
			<parameters/>
			<returns type="DOMString">
				<descr>
					<p>The contents of the Range.</p>
				</descr>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
		<method name="detach" id="Level2-Range-method-detach">
			<descr>
				<p>Called to indicate that the Range is no longer in use and that the implementation may relinquish any resources associated with this Range. Subsequent calls to any methods or attribute getters on this Range will result in a<code>DOMException</code>being thrown with an error code of<code>INVALID_STATE_ERR</code>.</p>
			</descr>
			<parameters/>
			<returns type="void">
				<descr/>
			</returns>
			<raises>
				<exception name="DOMException">
					<descr>
						<p>INVALID_STATE_ERR: Raised if<code>detach()</code>has already been invoked on this object.</p>
					</descr>
				</exception>
			</raises>
		</method>
	</interface>
	<interface name="DocumentRange" id="Level-2-DocumentRange-idl" since="DOM Level 2">
		<descr/>
		<method name="createRange" id="Level2-DocumentRange-method-createRange">
			<descr>
				<p>This interface can be obtained from the object implementing the<code>Document</code>interface using binding-specific casting methods.</p>
			</descr>
			<parameters/>
			<returns type="Range">
				<descr>
					<p>The initial state of the Range returned from this method is such that both of its boundary-points are positioned at the beginning of the corresponding Document, before any content. The Range returned can only be used to select content associated with this Document, or with DocumentFragments and Attrs for which this Document is the<code>ownerDocument</code>.</p>
				</descr>
			</returns>
			<raises/>
		</method>
	</interface>
	<exception name="RangeException" id="RangeException" since="DOM Level 2">
		<descr>
			<p>Range operations may throw a<code>RangeException</code>as specified in their method descriptions.</p>
		</descr>
		<component id="RangeExceptionComponent" name="code">
			<typename>unsigned short</typename>
		</component>
	</exception>
	<group id="RangeExceptionCode" name="RangeExceptionCode">
		<descr>
			<p>An integer indicating the type of error generated.</p>
		</descr>
		<constant name="BAD_BOUNDARYPOINTS_ERR" type="unsigned short" value="1">
			<descr>
				<p>If the boundary-points of a Range do not meet specific requirements.</p>
			</descr>
		</constant>
		<constant name="INVALID_NODE_TYPE_ERR" type="unsigned short" value="2">
			<descr>
				<p>If the<termref def="td-container">container</termref>of an boundary-point of a Range is being set to either a node of an invalid type or a node with an ancestor of an invalid type.</p>
			</descr>
		</constant>
	</group>
</library>
